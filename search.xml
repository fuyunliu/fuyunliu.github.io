<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sqlalchemy 基本用法]]></title>
    <url>%2F2019%2F05%2F12%2Fsqlalchemy-usage%2F</url>
    <content type="text"><![CDATA[Sqlalchemy 基本用法 通用导入12345678910from sqlalchemy import create_enginefrom sqlalchemy.orm import scoped_session, sessionmakerfrom sqlalchemy import Column, Integer, String, ForeignKey, Booleanfrom sqlalchemy.orm import relationshipfrom sqlalchemy.ext.declarative import declarative_baseengine = create_engine('sqlite:///test.db', echo=True)Base = declarative_base()db_session = scoped_session(sessionmaker(bind=engine))Base.query = db_session.query_property() 一对一1234567891011121314class Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) name = Column(String) child_id = Column(Integer, ForeignKey('child.id'))class Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) name = Column(String) parent = relationship('Parent', backref='child', uselist=False) 一对多12345678910111213141516171819# the one sideclass Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) name = Column(String) # children = relationship("Child", back_populates="parent") children = relationship("Child", backref="parent", lazy="dynamic")# the many sideclass Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) name = Column(String) parent_id = Column(Integer, ForeignKey('parent.id')) # parent = relationship("Parent", back_populates="children") # parent = relationship("Parent", backref="children") 多对一12345678910111213141516# the many sideclass Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) name = Column(String) child_id = Column(Integer, ForeignKey('child.id'))# the one sideclass Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) name = Column(String) parents = relationship('Parent', backref='child', lazy='dynamic') 多对多123456789101112131415161718192021222324252627282930class Department(Base): __tablename__ = 'department' id = Column(Integer, primary_key=True) name = Column(String) employees = relationship( 'Employee', secondary='department_employee_link' )class Employee(Base): __tablename__ = 'employee' id = Column(Integer, primary_key=True) name = Column(String) hired_on = Column( DateTime, default=func.now()) departments = relationship( 'Department', secondary='department_employee_link' )class DepartmentEmployeeLink(Base): __tablename__ = 'department_employee_link' department_id = Column(Integer, ForeignKey('department.id'), primary_key=True) department = relationship('Department') employee_id = Column(Integer, ForeignKey('employee.id'), primary_key=True) employee = relationship('Employee') 自身多对多1234567891011121314151617181920212223class Follow(Base): __tablename__ = 'me_follow_you' me_id = Column(Integer, ForeignKey('users.id'), primary_key=True) me = relationship('User', foreign_keys=[me_id]) you_id = Column(Integer, ForeignKey('users.id'), primary_key=True) you = relationship('User', foreign_keys=[you_id]) created = Column(DateTime(timezone=True), default=datetime.utcnow)class User(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(64)) # stars=我关注的人 fans=我的粉丝 stars = relationship('User', secondary='me_follow_you', primaryjoin='User.id==Follow.me_id', secondaryjoin='User.id==Follow.you_id', backref=backref('fans', lazy='dynamic'), lazy='dynamic') 自身一对一123456class Node(Base): __tablename__ = 'node' id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey('node.id')) data = Column(String(50)) parent = relationship("Node", remote_side=[id]) 创建表1234def init_db(): from sqlalchemy import create_engine engine = create_engine('sqlite:///test.db', echo=True) Base.metadata.create_all(engine) backref 和 back_populates1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Parent 下添加 `children = relationship("Child", back_populates="parent")`创建p1 = Parent()和c1 = Child()失败，原因是One or more mappers failed to initialize，即back_populates必须在关系两端同时指定Parent下添加 `children = relationship("Child", back_populates="parent")`Child下添加 `parent = relationship("Parent", back_populates="children")`Parent Attribute:Parent.children Parent.id Parent.metadata Parent.name Parent.queryChild Attribute:Child.id Child.metadata Child.name Child.parent Child.parent_id Child.queryp1 = Parent()c1 = Child()c1.parent = p1 or p1.children.append(c1)Parent下添加 `children = relationship("Child", backref="parent")`Parent Attribute:Parent.children Parent.id Parent.metadata Parent.name Parent.queryChild Attribute:Child.id Child.metadata Child.name Child.parent_id Child.queryp1 = Parent()c1 = Child()c1.parent = p1 or p1.children.append(c1)可以看出使用backref时，实例化c1时会自动在c1对象上添加parent属性此后再检查:hasattr(Child, 'parent') // Truehasattr(c1, 'parent') // Truehasattr(Parent, 'children') // Truehasattr(p1, 'children') // TrueChild 下添加 `parent = relationship("Parent", backref="children")` 情况和 3 相同Parent下添加 `children = relationship("Child", backref="parent")`Child下添加 `parent = relationship("Parent", backref="children")`创建p1 = Parent()和c1 = Child()失败，原因是One or more mappers failed to initialize因此两者只能使用其中之一lazy 指定如何加载相关记录，默认值是"select" select 首次访问时按需加载 immediate 源对象加载后就加载 joined 加载记录,但使用联结 subquery 立即加载,但使用子查询 noload 永不加载 dynamic 不加载记录,但提供加载记录的查询lazy = "dynamic"只能用于collections，不立即查询出结果集，而是提供一系列结果集的方法，可以基于结果集再次进行更精确的查找 default 和 server_default default 是在 ORM 层设置默认值，server_default 是在表结构上设置默认值 onupdate 在 ORM 层生效，server_onupdate 在数据库生效，在 MySQL 上 ON UPDATE 是MySQL在背后创建了 trigger，而在 PostgreSQL 上你必须手动创建 trigger 1234567891011121314from datetime import datetimefrom sqlalchemy import func, sql, textclass Record(Base): __tablename__ = 'records id = Column(Integer, primary_key=True) name = Column(String(64), server_default=text('name')) created = Column(DateTime(timezone=True), default=datetime.utcnow) # created = Column(DateTime(timezone=True), server_default=func.now()) # created = Column(DateTime(timezone=True), server_default=func.current_timestamp()) updated = Column(DateTime(timezone=True), server_default=func.current_timestamp(), onupdate=func.current_timestamp()) deleted = Column(Boolean, default=False) # deleted = Column(Boolean, server_default=sql.expression.false()) 为flask_sqlalchemy扩展BaseQuery方法12345678910from flask_sqlalchemy import SQLAlchemy, BaseQueryfrom sqlalchemy import funcclass CustomQuery(BaseQuery): def count_all(self): return self.with_entities(func.count()).scalar()db = SQLAlchemy(query_class=CustomQuery)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2019%2F04%2F12%2Fdocker-usage%2F</url>
    <content type="text"><![CDATA[list docker cli commands docker --help docker contianer --help docker version docker --version docker info docker info list image docker image ls or docker images list container docker container ls docker container ls --all # all mode docker container ls -aq # all in quite mode run image docker run hello-world docker run -d -p 6379:6379 redis login running container docker exec -it &lt;name&gt; bash]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F01%2F15%2Ftreenode%2F</url>
    <content type="text"><![CDATA[LeetCode 二叉树题解汇总 二叉树定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 相同的树123456def is_same_tree(p, q): if p is None: return not q if q is None: return not p return p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right) 对称的树123456789101112def is_symmetric(root): if not root: return True return symmetric(root.left, root.right)def symmetric(l1, l2): if l1 is None: return not l2 if l2 is None: return not l1 return l1.val == l2.val and symmetric(l1.left, l2.right) and symmetric(l1.right, l2.left) 层次遍历给定一个二叉树，返回其按层次遍历的节点值。 12345678910111213def add(node, level, res): if node is None: return if len(res) &lt; level: res.append([]) res[level - 1].append(node.val) add(node.left, level + 1, res) add(node.right, level + 1, res)def level_order(root): res = [] add(root, 1, res) return res 最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 12def max_depth(root): return 1 + max(map(max_depth, (root.left, root.right))) if root else 0 最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 123456789101112131415def min_depth(root): if root is None: return 0 if root.left is None: return 1 + min_depth(root.right) if root.right is None: return 1 + min_depth(root.left) return 1 + min(map(min_depth, (root.left, root.right)))# 更简洁的写法def min_depth(root): if root is None: return 0 depth_under_root = map(min_depth, (root.left, root.right)) return 1 + (min(depth_under_root) or max(depth_under_root)) 将有序数组转化为二叉树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 1234567def sorted_array_to_balanced_tree(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_balanced_tree(nums[:mid]) root.right = sorted_array_to_balanced_tree(nums[mid + 1:]) 平衡二叉树一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 123456789def hight(node): if node is None: return 0 return 1 + max(map(hight, (node.left, node.right)))def is_balanced(root): if root is None: return True return abs(hight(root.left) - hight(root.right)) &lt;= 1 and is_balanced(root.left) and is_balanced(root.right) 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 123456def has_path_sum(root, sums): if root is None: return False if root.left or root.right: return has_path_sum(root.left, sums - root.val) or has_path_sum(root.right, sums - root.val) return sums == root.val]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 处理 Csv 文件常见错误]]></title>
    <url>%2F2018%2F12%2F03%2Fcsv-error%2F</url>
    <content type="text"><![CDATA[在用 Python 处理 csv 文件时遇到2个错误，记录下处理方法。 字段包含 NULL 值csv 文件中字段包含 NULL 值会出错，解决方法是读取文件时把 NULL 值替换为空字符串。 12345import csvwith open('test.csv', 'rt', encoding='utf-8') as f: fc = csv.DictReader((line.replace('\0', '') for line in f)) # do something with fc OverflowError and maxInt1234567891011121314151617181920import csvimport sysmaxInt = sys.maxsizedecrement = Truewhile decrement: # decrease the maxInt value by factor 10 # as long as the OverflowError occurs. decrement = False try: csv.field_size_limit(maxInt) except OverflowError: maxInt = int(maxInt / 10) decrement = Truewith open('test.csv', 'rt', encoding='utf-8') as f: fc = csv.DictReader(f) # do something with fc]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 安装 PhantomJS]]></title>
    <url>%2F2018%2F11%2F21%2Fcentos-install-phantomjs%2F</url>
    <content type="text"><![CDATA[PhantomJS 已经不再开发了，seleniumn 也警告使用 PhantomJS 是过时的，推荐使用 headless 版的 Chrome 或者 Firefox，但是有时候需要用到，够用就行，而且在 Linux 下安装也相对简单。 安装 fontconfig 依赖1yum install -y fontconfig freetype freetype-devel fontconfig-devel libstdc++ 下载 PhantomJS 并解压1234567891011121314151617# 安装到此目录cd /usr/local# 下载wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2# 解压tar -jxvf phantomjs-2.1.1-linux-x86_64.tar.bz2# 重命名mv phantomjs-2.1.1-linux-x86_64 phantomjs# 添加软链接ln -s /usr/local/phantomjs/bin/phantomjs /usr/bin/phantomjs# 验证phantomjs --version 用 selenium 驱动 PhantomJS12345678910from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities# 更改浏览器头dcap = dict(DesiredCapabilities.PHANTOMJS)dcap["phantomjs.page.settings.userAgent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"driver = webdriver.PhantomJS(desired_capabilities=dcap)driver.set_page_load_timeout(10)driver.set_script_timeout(10)driver.get("https://www.baidu.com") 推荐使用的 Chrome 用法1234567891011121314151617181920212223242526from selenium import webdriverfrom selenium.webdriver.chrome.options import Options# 无界面浏览器options = Options()options.add_argument('headless')options.add_argument('disable-gpu')options.add_argument('window-size=1200x600')# 禁用 javascriptprefs = &#123;'profile.managed_default_content_settings.javascript': 2&#125;options.add_experimental_option("prefs", prefs)# 禁止弹出式窗口prefs = &#123;"profile.default_content_setting_values.notifications": 2&#125;options.add_experimental_option("prefs", prefs)# 禁用图片prefs = &#123;'profile.managed_default_content_settings.images': 2&#125;options.add_experimental_option("prefs", prefs)driver = webdriver.Chrome(chrome_options=options)# 执行JSdriver.execute_script('window.scrollTo(0, 0)') # scroll to topdriver.execute_script('window.scrollTo(0, document.body.scrollHeight)') # end]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 通过 Thrift 操作 Hbase]]></title>
    <url>%2F2018%2F11%2F14%2Fhbase-thrift%2F</url>
    <content type="text"><![CDATA[记录 Python 通过 Thrift 操作 Hbase 的通用操作方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159from thrift.transport import TSocketfrom thrift.protocol import TBinaryProtocolfrom thrift.transport import TTransportfrom elasticsearch import Elasticsearchfrom hbase import Hbase# Connect to HBase Thrift servertransport = TTransport.TBufferedTransport(TSocket.TSocket('localhost', 9090))protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)# Create and open the client connectionclient = Hbase.Client(protocol)transport.open()# Connect to Elasticsearch serveres = Elasticsearch('localhost', http_auth=('username', 'password'), port='9200', timeout=30, max_retries=10, retry_on_timeout=True )def fetch_one(index, doc_type, body, size=1): """查询es获取第一条匹配的数据 Arguments: index &#123;str&#125; -- 索引 doc_type &#123;str&#125; -- 类型 body &#123;dict&#125; -- 查询语句 Keyword Arguments: size &#123;int&#125; -- 返回数量 (default: &#123;1&#125;) Returns: dict -- 一条数据，没有结果返回 None """ res = es.search(index=index, doc_type=doc_type, scroll='2m', body=body, size=size) hits = res['hits']['hits'] return hits[0] if hits else Nonedef fetch_all(index, doc_type, body, size=100): """查询es获取所有匹配的结果 Arguments: index &#123;str&#125; -- 索引 doc_type &#123;str&#125; -- 类型 body &#123;dict&#125; -- 查询语句 Keyword Arguments: size &#123;int&#125; -- 返回数量 (default: &#123;100&#125;) Returns: list -- 结果集 """ res = es.search(index=index, doc_type=doc_type, scroll='2m', body=body, size=size) return res['hits']['hits']def build_term(field, value): """term Arguments: field &#123;str&#125; -- 字段 value &#123;str&#125; -- 值 Returns: dict -- 查询语句 """ body = &#123; "query": &#123; "term": &#123; field: &#123; "value": value &#125; &#125; &#125; &#125; return bodydef build_terms(field, values): """terms Arguments: field &#123;str&#125; -- 字段 values &#123;list&#125; -- 列表 Returns: dict -- 查询语句 """ body = &#123; "query": &#123; "terms": &#123; field: values &#125; &#125; &#125; return bodydef get_row_with_columns(table_name, rowkey, columns): """根据 rowkey 从 hbase 获取一条数据 Arguments: table_name &#123;str&#125; -- 表名 rowkey &#123;str&#125; -- rowkey attributes &#123;list&#125; -- 属性列表 Returns: dict -- 一条数据，没有则返回None """ table_name = table_name.encode() rowkey = rowkey.encode() columns = [('0:' + c).encode() for c in columns] res = client.getRowWithColumns(table_name, rowkey, columns, None) if not res: return None d = &#123; k.decode().split(':')[1]: v.value.decode() for k, v in res[0].columns.items() &#125; d['rowkey'] = res[0].row.decode() return ddef get_rows_with_columns(table_name, rowkeys, columns): """根据 rowkeys 从 hbase 获取所有匹配的数据 Arguments: table_name &#123;str&#125; -- 表名 rowkeys &#123;list&#125; -- rowkey 列表 columns &#123;list&#125; -- 指定返回字段 Returns: list -- 数据结果集 """ data = [] table_name = table_name.encode() rowkeys = [k.encode() for k in rowkeys] columns = [('0:' + c).encode() for c in columns] res = client.getRowsWithColumns(table_name, rowkeys, columns, None) for r in res: d = &#123; k.decode().split(':')[1]: v.value.decode() for k, v in r.columns.items() &#125; d['rowkey'] = r.row.decode() data.append(d) return data]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asyncio 笔记]]></title>
    <url>%2F2018%2F11%2F11%2Fasyncio-tutorial%2F</url>
    <content type="text"><![CDATA[并发是指一次处理多件事。 并行是指一次做多件事。 二者不同，但是有联系。 一个关于结构，一个关于执行。 并发用于制定方案，用来解决可能（但未必）并行的问题。 ——Rob Pike Go 语言的创造者之一 异步版 hello-world12345678910111213import asyncioasync def main(): print('hello') await asyncio.sleep(.1) print('world')# python3.7 提供asyncio.run(main())# main 函数是个协程，直接运行不会执行操作# main() --&gt; &lt;coroutine object main at 0x109be6d48&gt; 运行协程的三种方式 asyncio.run() 使用 await 关键字 123456789101112131415161718import asyncioimport timeasync def say_after(delay, what): await asyncio.sleep(delay) print(what)async def main(): print(f"started at &#123;time.strftime('%X')&#125;") await say_after(1, 'hello') await say_after(2, 'world') print(f"finished at &#123;time.strftime('%X')&#125;")asyncio.run(main()) 使用 asyncio.create_task() 创建一个 Task 对象 1234567891011# 直接对上面的 main 函数进行修改async def main(): t1 = asyncio.create_task(say_after(1, 'hello')) t2 = asyncio.create_task(say_after(2, 'world')) print(f"started at &#123;time.strftime('%X')&#125;") await t1 await t2 print(f"finished at &#123;time.strftime('%X')&#125;") Awaitable 对象awaitable 对象是指可以在 await 表达式中使用的对象。 coroutines, Tasks 和 Futures 是 awaitable 对象。 协程 coroutines 1234567891011121314151617import asyncioasync def nested(): return 42async def main(): # 这中方式不会执行 nested 函数 nested() # await print(await nested())asyncio.run(main()) 任务 Tasks 12345678910111213import asyncioasync def nested(): return 42async def main(): t = asyncio.create_task(nested()) await tasyncio.run(main()) 期物 Futures 并发执行 Tasks使用 asyncio.gather 并发执行 Tasks 123456789101112131415161718192021import asyncioasync def factorial(name, number): f = 1 for i in range(2, number + 1): print(f"Task &#123;name&#125;: Compute factorial(&#123;i&#125;)...") await asyncio.sleep(1) f *= i print(f"Task &#123;name&#125;: factorial(&#123;number&#125;) = &#123;f&#125;")async def main(): await asyncio.gather( factorial('A', 2), factorial('B', 3), factorial('C', 4), )asyncio.run(main()) 线程和协程的对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 线程版以动画形式显示文本旋转指针import threadingimport itertoolsimport timeimport sysclass Signal: go = Truedef spin(msg, signal): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char + ' ' + msg write(status) flush() write('\x08' * len(status)) time.sleep(.1) if not signal.go: break write(' ' * len(status) + '\x08' * len(status))def slow_funtion(): time.sleep(3) return 42def supervisor(): signal = Signal() spinner = threading.Thread( target=spin, args=('thinking!', signal)) print('spinner object: ', spinner) spinner.start() result = slow_funtion() signal.go = False spinner.join() return resultdef main(): result = supervisor() print('Answer: ', result)if __name__ == '__main__': main() 123456789101112131415161718192021222324252627282930313233343536373839404142# 协程版以动画形式显示文本旋转指针import asyncioimport itertoolsimport sysasync def spin(msg): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char + ' ' + msg write(status) flush() write('\x08' * len(status)) try: await asyncio.sleep(.1) except asyncio.CancelledError: break write(' ' * len(status) + '\x08' * len(status))async def slow_funtion(): await asyncio.sleep(3) return 42async def supervisor(): spinner = asyncio.create_task(spin('thinking!')) print('spinner object: ', spinner) result = await slow_funtion() spinner.cancel() return result# 一般执行方式loop = asyncio.get_event_loop()result = loop.run_until_complete(supervisor())loop.close()print('Answer: ', result)# python3.7 执行方式asyncio.run(supervisor()) Task 对象像是实现协作式多任务的库（如 gevent）中的绿色线程（green thread）。 Task 对象用于驱动协程，Thread 对象用于调用可调用对象。 Task 对象不由自己手动实例化，而是由 asyncio.create_task 方法获取。 获取的 Task 对象已经排定了运行时间，而 Thread 实例需要调用 start 方法运行。 异步版 slow_funtion 是协程，由 await （就是 yield from）驱动。 终止线程需要借助外部变量 go,终止 Task 可以调用 Task.cancel() 实例方法，在协程内部抛出 CancelledError 异常，协程内部也可以捕获这个异常，处理终止请求。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外国小说鉴赏辞典]]></title>
    <url>%2F2018%2F11%2F03%2Fforeign-novel-appreciation-dictionary%2F</url>
    <content type="text"><![CDATA[外国小说鉴赏辞典，从图书馆拍来的目录，纯手码，很累！ 古代至19世纪中期卷 书名 国籍 作者 阿玛莉亚 阿根廷 马莫尔 魂归故里 波兰 克拉舍夫斯基 春香传 朝鲜 佚名 痴儿西木传 德国 格里美尔斯豪森 少年维特的烦恼 德国 歌德 威廉·麦斯特的学习时代 德国 歌德 亲和力 德国 歌德 金罐 德国 霍夫曼 侏儒查赫斯 德国 霍夫曼 雄猫穆尔的生活观 德国 霍夫曼 温亭娜 德国 富凯 彼得·史勒密尔的奇怪故事 德国 沙米索 茵梦湖 德国 施托姆 驿站长 俄国 普希金 黑桃皇后 俄国 普希金 上尉的女儿 俄国 普希金 狂人日记 俄国 果戈里 塔拉斯·布利巴 俄国 果戈里 外套 俄国 果戈里 死魂灵 俄国 果戈里 谁之罪 俄国 赫尔岑 偷东西的喜鹊 俄国 赫尔岑 平凡的故事 俄国 冈察洛夫 当代英雄 俄国 莱蒙托夫 木木 俄国 屠格涅夫 白夜 俄国 陀思妥耶夫斯基 巨人传 法国 拉伯雷 吉尔·布拉斯 法国 勒萨日 波斯人信札 法国 孟德斯鸠 查第格 法国 伏尔泰 老实人 法国 伏尔泰 玛农·列斯戈 法国 普莱服神甫 新爱洛伊丝 法国 卢梭 爱弥儿 法国 卢梭 拉摩的侄子 法国 狄德罗 定命论者雅克和他的主人 法国 狄德罗 阿达拉 法国 夏多布里昂 阿尔芒丝 法国 司汤达 红与黑 法国 司汤达 巴马修道院 法国 司汤达 驴皮记 法国 巴尔扎克 欧也妮·葛朗台 法国 巴尔扎克 高老头 法国 巴尔扎克 幻灭 法国 巴尔扎克 邦斯舅舅 法国 巴尔扎克 三个火枪手 法国 大仲马 基督山恩仇记 法国 大仲马 巴黎圣母院 法国 雨果 高龙巴 法国 梅里美 嘉尔曼 法国 梅里美 巴黎的秘密 法国 欧仁·苏 安吉堡的磨工 法国 乔治·桑 一个世纪的忏悔 法国 缪塞 外祖母 捷克 涅姆佐娃 癞皮鹦鹉 墨西哥 利萨尔迪 瑞普·凡·温克尔 美国 欧文 睡谷的传说 美国 欧文 最后的莫西干人 美国 库柏 杀鹿人 美国 库柏 拉帕其尼医生的女儿 美国 霍桑 红字 美国 霍桑 七个尖角顶的宅第 美国 霍桑 黑猫 美国 爱伦·坡 厄舍府的倒塌 美国 爱伦·坡 毛格街血案 美国 爱伦·坡 汤姆叔叔的小屋 美国 斯托夫人 白鲸 美国 麦尔维尔 竹取物语 日本 佚名 源氏物语 日本 紫式部 平家物语 日本 佚名 浮世澡堂 日本 式亭三马 绿衣亨利 瑞士 凯勒 小癞子 西班牙 佚名 堂吉诃德 西班牙 塞万提斯 金驴记 古罗马 阿普列乌斯 十日谈 意大利 卜伽丘 太阳城 意大利 康帕内拉 约婚夫妇 意大利 孟佐尼 坎特伯雷故事集 英国 乔叟 天路历程 英国 班扬 鲁宾逊漂流记 英国 笛福 格列佛游记 英国 斯威夫特 帕梅拉 英国 理查森 大伟人江奈生·魏尔德传 英国 菲尔丁 汤姆·琼斯 英国 菲尔丁 感伤的旅程 英国 斯特恩 蓝登传 英国 斯摩莱特 威克菲牧师传 英国 哥尔斯密 爱丁堡监狱 英国 司各特 艾凡赫 英国 司各特 理智与情感 英国 奥斯丁 傲慢与偏见 英国 奥斯丁 爱玛 英国 奥斯丁 玛丽·巴顿 英国 盖斯凯尔夫人 名利场 英国 萨克雷 钮可谟一家 英国 李敦 庞贝城的末日 英国 狄更斯 匹克维克外传 英国 狄更斯 雾都孤儿 英国 狄更斯 老古玩店 英国 狄更斯 大卫·考坡菲 英国 狄更斯 简·爱 英国 夏洛蒂·勃朗特 呼啸山庄 英国 艾米莉·勃朗特 19世纪下半期卷 书名 国籍 作者 为了面包 波兰 显克微支 火与剑 波兰 显克微支 洪流 波兰 显克微支 十字军骑士 波兰 显克微支 傀儡 波兰 普鲁斯 福地 波兰 莱蒙特 三色紫罗兰 德国 史托姆 白马骑士 德国 史托姆 艾菲·布里斯特 德国 冯塔纳 奥勃洛摩夫 俄国 冈察洛夫 悬崖 俄国 冈察洛夫 罗亭 俄国 屠格涅夫 贵族之家 俄国 屠格涅夫 前夜 俄国 屠格涅夫 初恋 俄国 屠格涅夫 父与子 俄国 屠格涅夫 罪与罚 俄国 陀思妥耶夫斯基 白痴 俄国 陀思妥耶夫斯基 群魔 俄国 陀思妥耶夫斯基 卡拉马佐夫兄弟 俄国 陀思妥耶夫斯基 怎么办？ 俄国 车尔尼雪夫斯基 琉森 俄国 列夫·托尔斯泰 哥萨克 俄国 列夫·托尔斯泰 战争与和平 俄国 列夫·托尔斯泰 安娜·卡列尼娜 俄国 列夫·托尔斯泰 伊万·伊利奇之死 俄国 列夫·托尔斯泰 复活 俄国 列夫·托尔斯泰 大堂神父 俄国 列斯科夫 左撇子 俄国 列斯科夫 盲音乐家 俄国 柯罗连科 棕榈 俄国 迦尔洵 变色龙 俄国 契诃夫 苦恼 俄国 契诃夫 草原 俄国 契诃夫 第六病室 俄国 契诃夫 装在套子里的人 俄国 契诃夫 悲惨世界 法国 雨果 海上劳工 法国 雨果 笑面人 法国 雨果 九三年 法国 雨果 包法利夫人 法国 福楼拜 萨朗波 法国 福楼拜 情感教育 法国 福楼拜 格兰特船长的儿女 法国 凡尔纳 起义者 法国 瓦莱斯 小酒店 法国 左拉 萌芽 法国 左拉 金钱 法国 左拉 小东西 法国 都德 最后一课 法国 都德 苔依丝 法国 法郎士 羊脂球 法国 莫泊桑 一生 法国 莫泊桑 我的叔叔于勒 法国 莫泊桑 项链 法国 莫泊桑 漂亮朋友 法国 莫泊桑 起义者 菲律宾 黎萨尔 玛丽亚 哥伦比亚 伊萨克斯 马格斯·哈弗拉尔 荷兰 穆尔塔图里 野姑娘芭拉 捷克 聂姆佐娃 庄园内外 捷克 聂姆佐娃 竞选州长 美国 马克·吐温 汤姆·索亚历险记 美国 马克·吐温 王子与贫儿 美国 马克·吐温 哈克贝里·芬历险记 美国 马克·吐温 塞拉斯·拉帕姆的发迹 美国 豪威尔斯 黛西·米勒 美国 詹姆斯 一位女士的画像 美国 詹姆斯 嘉莉妹妹 美国 德莱塞 饥饿 挪威 汉姆生 阿马罗神父的罪恶 葡萄牙 克罗兹 舞姬 日本 森鸥外 浮云 日本 二叶亭四迷 慈悲心肠 西班牙 佩雷斯·加尔多斯 庭长夫人 西班牙 克拉林 金人 匈牙利 约卡伊·莫尔 圣彼得的伞 匈牙利 米克沙特·卡尔曼 奇婚记 匈牙利 米克沙特·卡尔曼 斯巴达克思 意大利 乔万尼奥里 女乞丐 印度 泰戈尔 饥饿的石头 印度 泰戈尔 妻子和女儿 英国 盖斯凯尔夫人 艰难时世 英国 狄更斯 双城记 英国 狄更斯 远大前程 英国 狄更斯 教师 英国 夏洛蒂·勃朗特 亚当·贝德 英国 乔治·艾略特 佛洛斯河磨坊 英国 乔治·艾略特 织工马南转 英国 乔治·艾略特 米德尔马契 英国 乔治·艾略特 远离尘嚣 英国 哈代 还乡 英国 哈代 卡斯特桥市长 英国 哈代 德伯家的苔丝 英国 哈代 无名的裘德 英国 哈代 化身博士 英国 斯蒂文森 诱拐 英国 斯蒂文森 金银岛 英国 斯蒂文森 道林·格雷的画像 英国 王尔德 黑暗的心 英国 康拉德 吉姆爷 英国 康拉德 牛虻 英国 伏尼契 丛林故事 英国 吉卜林 时间机器 英国 威尔斯 马丁·里瓦斯 智利 布莱斯特·加纳 20世纪前期卷 书名 国籍 作者 都柏林人 爱尔兰 乔伊斯 一个青年艺术家的画像 爱尔兰 乔伊斯 尤利西斯 爱尔兰 乔伊斯 一个陌生女人的来信 奥地利 茨威格 变形记 奥地利 卡夫卡 饥饿艺术家 奥地利 卡夫卡 城堡 奥地利 卡夫卡 地洞 奥地利 卡夫卡 农民 波兰 莱蒙特 征服者贝莱 丹麦 尼克索 垃圾教授 德国 亨利希·曼 臣仆 德国 亨利希·曼 布登勃洛克一家 德国 托马斯·曼 死于威尼斯 德国 托马斯·曼 魔山 德国 托马斯·曼 荒原狼 德国 黑塞 纳尔齐斯与歌尔德蒙 德国 黑塞 柏林，亚历山大广场 德国 德布林 西线无战事 德国 雷马克 《基督与反基督》三部曲 俄国 梅列日科夫斯基 决斗 俄国 库普林 石榴石手镯 俄国 库普林 乡村 俄国 布宁 阿尔谢尼耶夫的一生 俄国 布宁 红笑 俄国 安德烈耶夫 七个被绞死者的故事 俄国 安德烈耶夫 企鹅岛 法国 法郎士 诸神渴了 法国 法郎士 约翰·克里斯朵夫 法国 罗曼·罗兰 母与子 法国 罗曼·罗兰 伪币制造者 法国 纪德 追寻逝去的时光 法国 普鲁斯特 火线-一个步兵班的日记 法国 巴比塞 苔蕾丝·德斯盖鲁 法国 莫里亚克 旋涡 哥伦比亚 里维拉 好兵帅克 捷克 哈谢克 折断的翅膀 黎巴嫩 纪伯伦 麦琪的礼物 美国 欧·亨利 最后一片叶子 美国 欧·亨利 章鱼 美国 诺里斯 珍尼姑娘 美国 德莱塞 美国悲剧 美国 德莱塞 啊，拓荒者！ 美国 凯瑟 荒野的呼唤 美国 杰克·伦敦 小城畸人 美国 杰克·伦敦 了不起的盖茨比 美国 菲茨杰拉德 喧哗与骚动 美国 福克纳 我弥留之际 美国 福克纳 太阳照常升起 美国 海明威 永别了，武器 美国 海明威 情侣 缅甸 詹姆斯拉觉 劳伦斯之女克里斯丁 挪威 温塞特 我是猫 日本 夏目漱石 棉被 日本 田山花袋 破戒 日本 岛崎藤村 新珠 日本 菊池宽 罗生门 日本 芥川龙之介 橘子 日本 芥川龙之介 竹林中 日本 芥川龙之介 太阳 日本 横光利一 没有太阳的街 日本 德永直 蟹工船 日本 小林多喜二 雅考伯·冯·贡腾 瑞士 罗伯特·瓦尔泽 母亲 苏联 高尔基 奥库罗夫镇 苏联 高尔基 阿尔塔莫诺夫家的事业 苏联 高尔基 彼得堡 苏联 别雷 我们 苏联 扎米亚京 孽卵 苏联 布尔加科夫 狗心 苏联 布尔加科夫 第四十一 苏联 拉夫列尼约夫 基坑 苏联 普拉东诺夫 伊斯坦布尔的姑娘 土耳其 君泰金 堂娜芭芭拉 委内瑞拉 加列戈斯 迷雾 西班牙 乌纳穆诺 碧血黄沙 西班牙 布拉斯科·伊巴涅斯 孤独者 意大利 皮兰德娄 坛子 意大利 皮兰德娄 已故的帕斯卡尔 意大利 皮兰德娄 沉船 印度 泰戈尔 戈拉 印度 泰戈尔 斯里甘特 印度 查特吉 仁爱道院 印度 普列姆昌德 半斤小麦 印度 普列姆昌德 有产业的人 英国 高尔斯华绥 穿破裤子的慈善家 英国 特莱赛尔 人生的枷锁 英国 毛姆 看得见风景房间 英国 福斯特 印度之行 英国 福斯特 密林中的村庄 英国 伦纳德·伍尔夫 达洛卫夫人 英国 弗吉尼亚·伍尔夫 到灯塔去 英国 弗吉尼亚·伍尔夫 儿子与情人 英国 劳伦斯 虹 英国 劳伦斯 查泰莱夫人的情人 英国 劳伦斯 20世纪中期卷 书名 国籍 作者 小径分岔的花园 阿根廷 博尔赫斯 环形废墟 阿根廷 博尔赫斯 人树 澳大利亚 怀特 一杯茶 澳大利亚 怀特 象棋的故事 奥地利 茨威格 无边的土地 巴西 亚马多 绿蒂在魏玛 德国 托马斯·曼 玻璃球游戏 德国 黑塞 戈雅 德国 福伊希特万格 凯旋门 德国 雷马克 第七个十字架 德国 西格斯 迷惘 德国 卡内蒂 小丑之见 德国 伯尔 淡漠的人 德国 伦茨 铁皮鼓 德国 格拉斯 猫与鼠 德国 格拉斯 分裂的天空 德国 沃尔夫 俄罗斯森林 俄罗斯 列昂诺夫 伊万·杰尼索维奇的一天 俄罗斯 索尔仁尼琴 癌病房 俄罗斯 索尔仁尼琴 蒂博一家 法国 马丁·杜·加尔 蛇结 法国 莫里亚克 小王子 法国 圣埃克絮佩里 人的命运 法国 马尔罗 法兰西组曲 法国 内米洛夫斯基 恶心 法国 萨特 墙 法国 萨特 局外人 法国 加缪 鼠疫 法国 加缪 弗兰德公路 法国 西蒙 琴声如诉 法国 杜拉斯 橡皮 法国 罗伯-格里耶 窥视者 法国 罗伯-格里耶 变 法国 布托尔 你好，忧愁 法国 萨冈 伊萨贝尔在马孔多观雨时的独白 哥伦比亚 马尔克斯 百年孤独 哥伦比亚 马尔克斯 消失了的足迹 古巴 卡彭铁尔 查密莉雅 吉尔吉斯斯坦 艾特玛托夫 愚人船 美国 波特 北回归线 美国 米勒 夜色温柔 美国 菲茨杰拉德 八月之光 美国 福克纳 押沙龙，押沙龙！ 美国 福克纳 熊 美国 福克纳 乞力马扎罗的雪 美国 海明威 老人与海 美国 海明威 洛丽塔 美国 博纳科夫 市场街的斯宾诺莎 美国 辛格 店员 美国 马拉默德 魔桶 美国 马拉默德 赫索格 美国 贝娄 伤心咖啡馆之歌 美国 麦卡勒斯 麦田里的守望者 美国 塞林格 在路上 美国 凯鲁亚克 五号屠场 美国 冯内古特 第二十二条军规 美国 海勒 裸者与死者 美国 梅勒 好人难寻 美国 奥康纳 他们 美国 奥茨 城市与狗 秘鲁 略萨 最明净的地区 墨西哥 富恩特斯 诺言 瑞士 迪伦马特 细雪 日本 谷崎润一郎 上海 日本 横光利一 来到农村的文工队 日本 德永直 雪国 日本 川端康成 睡美人 日本 川端康成 “帝国银行事件”之谜 日本 松本清账 西阵之蝶 日本 水上勉 骏河夫人 日本 司马辽太郎 潮骚 日本 三岛由纪夫 金阁寺 日本 三岛由纪夫 黑衣 日本 有吉佐和子 饲育 日本 大江健三郎 万延元年的足球 日本 大江健三郎 苦难的历程 苏联 阿列克赛·托尔斯泰 日瓦戈医生 苏联 帕斯捷尔纳克 大师和玛格丽特 苏联 布尔加科夫 静静的顿河 苏联 肖洛霍夫 一个人的遭遇 苏联 肖洛霍夫 基督的最后诱惑 希腊 卡赞扎基斯 房间与街道 意大利 摩拉维亚 分成两半的子爵 意大利 卡尔维诺 刀锋 英国 毛姆 海浪 英国 伍尔夫 美妙的新世界 英国 赫胥黎 城堡 英国 克罗宁 一九八四 英国 奥威尔 问题的核心 英国 格林 蝇王 英国 戈尔丁 发条橙 英国 伯吉斯 沙堡 英国 默多克 金色笔记 英国 莱辛 幸运的吉姆 英国 艾米斯 法国中尉的女人 英国 福尔斯 戈丹 印度 普列姆昌德 黑水洋彼岸 印度 安纳德 20世纪后期卷 书名 国籍 作者 蜘蛛女之吻 阿根廷 普伊格 平民史诗 埃及 马哈福兹 风暴眼 澳大利亚 怀特 美好的美好的时光 奥地利 耶利内克 钢琴教师 奥地利 耶利内克 情欲 奥地利 耶利内克 浪女回归 巴西 亚马多 我坐在彼得拉河畔哭泣 巴西 科埃略 韦罗妮卡决定去死 巴西 科埃略 方尖碑 白俄罗斯 贝科夫 战争中没有女性 白俄罗斯 阿列克茜叶维契 惊马奔逃 德国 瓦尔泽 我的世纪 德国 格拉斯 献词 德国 施特劳斯 香水-一个谋杀犯的故事 德国 聚斯金德 白比姆黑耳朵 俄罗斯 特罗耶波尔斯基 一幅画 俄罗斯 格拉宁 永远十九岁 俄罗斯 巴拉克诺夫 百慕大三角 俄罗斯 邦达列夫 鱼王 俄罗斯 阿斯塔菲耶夫 被取消的演出 俄罗斯 奥库扎瓦 活下去，并且要记住 俄罗斯 拉斯普京 告别马焦拉 俄罗斯 拉斯普京 命运线 俄罗斯 哈里托诺夫 书市上的斯薇特兰娜 俄罗斯 马卡宁 美狄娅和她的孩子们 俄罗斯 乌利茨卡娅 夏伯阳与虚空 俄罗斯 佩列文 乡间的房子 俄罗斯 瓦尔拉莫夫 暗店街 法国 莫迪亚诺 我走了 法国 艾什诺兹 流浪的星星 法国 克莱齐奥 霍乱时期的爱情 哥伦比亚 马尔克斯 乙火 韩国 金东里 一日长于百年 吉尔吉斯斯坦 艾特玛托夫 断头台 吉尔吉斯斯坦 艾特玛托夫 斯通家史札记 加拿大 希尔兹 笑忘录 捷克 昆拉德 不能承受的生命之轻 捷克 昆拉德 冤家，一个爱情故事 美国 辛格 童爱 美国 辛格 杜宾的传记 美国 马拉默德 洪堡的礼物 美国 贝娄 更多的人死于心碎 美国 贝娄 时震 美国 冯内古特 刽子手之歌 美国 梅勒 苏菲的抉择 美国 斯泰伦 情欲艺术家 美国 霍克斯 铁草 美国 肯尼迪 最蓝的眼睛 美国 莫里森 所罗门之歌 美国 莫里森 白雪公主后传 美国 巴塞尔姆 拉格泰姆时代 美国 多克特罗 兔子回家 美国 厄普代克 变形记 美国 厄普代克 反生活 美国 罗斯 人性的污点 美国 罗斯 遗产-一个真实的故事 美国 罗斯 骏马长嘶 美国 麦卡锡 孤独鸽 美国 麦克默特里 葡萄园 美国 品钦 幽灵之家 美国 阿连德 不规则飞行 美国 纳尔逊 紫色 美国 沃克 纽约女人未眠夜 美国 提尔曼 一千英亩 美国 斯迈利 时时刻刻 美国 坎宁安 达·芬奇密码 美国 布朗 神圣的夜晚 摩洛哥 杰伦 帝国轶闻 墨西哥 帕索 七月的人民 南非 戈迪默 耻 南非 库切 修道院纪事 葡萄牙 萨拉马戈 失明症漫记 葡萄牙 萨拉马戈 失乐园 日本 渡边淳一 挪威的森林 日本 村上春树 无限近似于透明的蓝 日本 村上龙 厨房 日本 吉本芭娜娜 印第安的最后夏天 瑞士 谢赛克斯 哈扎尔辞典 塞尔维亚 帕维奇 老人 苏联 特里丰诺夫 红莓 苏联 舒克申 我的名字叫红 土耳其 帕慕克 独裁者的葬礼 委内瑞拉 彼特里 请听清风倾诉 乌拉圭 奥内蒂 为亡灵弹奏 西班牙 塞拉 无命运的人生 匈牙利 凯尔泰斯 蓝山 以色列 沙莱夫 玫瑰的名字 意大利 埃科 阿纳泰的贝壳 意大利 斯戈隆 人性的因素 英国 格林 河湾 英国 奈保尔 抵达之谜 英国 奈保尔 来自无人地带的明信片 英国 钱伯斯 隐之书 英国 拜厄特 时间中的孩子 英国 麦克尤恩 化学 英国 斯威夫特 长日留痕 英国 石黑一雄 卑微的神灵 印度 罗易 夜阑更深 印度尼西亚 维查雅 人世间 印度尼西亚 普拉姆迪亚 旁边的花园 智利 多诺索]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask v0.1 源码阅读]]></title>
    <url>%2F2018%2F09%2F27%2Funderstand-flask-v01%2F</url>
    <content type="text"><![CDATA[flask v0.1 是第一个发布的版本，单文件版，v0.4 是 flask 的最后一个单文件版本，文章中 flask 的源码有修改，因为依赖包有更新。 导包部分1234567891011121314151617181920212223242526272829303132333435363738394041424344# python2.5 版本加入 with 语句，低于 2.5 需要引入，高于则忽略。from __future__ import with_statementimport osimport sys# 没有用到from threading import local# jinja2 模板引擎from jinja2 import Environment, PackageLoader, FileSystemLoader# Flask 的 Request 和 Response 继承自 werkzeug 的 Request 和 Responsefrom werkzeug.wrappers import Request as RequestBase, Response as ResponseBase# 最后几行 _request_ctx_stack, current_app, request, session, g 用到。from werkzeug.local import LocalStack, LocalProxy# 用于测试请求上下文，在 Flask 类的方法 test_request_context 中调用，已失效。# 最新版 test_request_context 方法调用 flask.testing 的 make_test_environ_builder，最终调用 werkzeug.test 的 EnvironBuilder。from werkzeug import create_environfrom werkzeug.utils import cached_propertyfrom werkzeug.wsgi import SharedDataMiddleware# 路由from werkzeug.routing import Map, Rule# 错误处理from werkzeug.exceptions import HTTPException, InternalServerError# flask 自带的 session 用到from werkzeug.contrib.securecookie import SecureCookie# 没有用到，作为对外接口from werkzeug import abort, redirectfrom jinja2 import Markup, escape# 用于获取应用程序根目录try: import pkg_resources pkg_resources.resource_streamexcept (ImportError, AttributeError): pkg_resources = None Request 和 Responseflask 的 Request 和 Response 继承自 werkzeug 的 Request 和 Response。 如果你想要自定义 Request 和 Response，你可以继承这两个类，然后指定 Flask 的 request_class 和 response_class。 123456789101112131415161718192021222324252627282930313233343536class Request(RequestBase): """请求类""" def __init__(self, environ): RequestBase.__init__(self, environ) # WSGI 环境 self.endpoint = None # 视图函数的键名 self.view_args = None # 视图函数的参数class Response(ResponseBase): """响应类""" default_mimetype = 'text/html'class _RequestGlobals(object): passclass _RequestContext(object): """请求上下文""" def __init__(self, app, environ): self.app = app self.url_adapter = app.url_map.bind_to_environ(environ) self.request = app.request_class(environ) self.session = app.open_session(self.request) # 带上下文的 session self.g = _RequestGlobals() # 带上下文的 g self.flashes = None def __enter__(self): _request_ctx_stack.push(self) def __exit__(self, exc_type, exc_value, tb): if tb is None or not self.app.debug: _request_ctx_stack.pop() 几个有用的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def url_for(endpoint, **values): """函数跳转 endpoint: Flask 类有个 view_functions 字典，存储的就是 endpoint 和 视图函数的映射关系，默认 endpoint 是视图函数的名字 values: 路由传过来的参数 """ return _request_ctx_stack.top.url_adapter.build(endpoint, values)def flash(message): """ 消息闪现，存储在 session 中，是个列表 """ session['_flashes'] = (session.get('_flashes', [])) + [message]def get_flashed_messages(): """ 把 session 中存储的消息全部 pop 出来并返回 """ flashes = _request_ctx_stack.top.flashes if flashes is None: _request_ctx_stack.top.flashes = flashes = \ session.pop('_flashes', []) return flashesdef render_template(template_name, **context): """ 从文件渲染模板 """ current_app.update_template_context(context) return current_app.jinja_env.get_template(template_name).render(context)def render_template_string(source, **context): """ 从字符串渲染模板 """ current_app.update_template_context(context) return current_app.jinja_env.from_string(source).render(context)def _default_template_ctx_processor(): """ 模板处理，使得在所有模板中可以使用 request, session 和 g 三个全局变量 """ reqctx = _request_ctx_stack.top return dict( request=reqctx.request, session=reqctx.session, g=reqctx.g )def _get_package_path(name): """根据名字获取模块的路径""" try: return os.path.abspath(os.path.dirname(sys.modules[name].__file__)) except (KeyError, AttributeError): return os.getcwd() Flask 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355class Flask(object): """ Flask 类实现了一个 WSGI 应用，只要将包或者模块的名字传递给它 一旦创建的时候，它将首先注册视图函数、路由映射、模板配置等等几个重要的对象 传入包的名字是用于解决应用内部资源的引用，具体请查看 open_resource 函数 一般情况下，你只需要这样创建： from flask import Flask app = Flask(__name__) """ # 请求类 request_class = Request # 响应类 response_class = Response # 静态文件路径，设置为 None 可以禁用 static_path = '/static' # 密钥，用于 cookies 签名验证 secret_key = None # 基于 cookie 的 session 的名字 session_cookie_name = 'session' # 默认会直接传给 jinja2 的 options 参数值 jinja_options = dict( autoescape=True, extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_'] ) def __init__(self, package_name): # 调试模式开关，设置 True 以打开调试模式 # 在调试模式下，应用程序出错会有特殊的错误页面以供调试 # 并且服务会监控文件的变化，文件发生变化会重载服务 self.debug = False # 包或者模块的名字，一旦设置好了就不要改动 self.package_name = package_name # 应用程序顶级目录 self.root_path = _get_package_path(self.package_name) # 包含所有注册好的视图函数字典，键是函数的名字，也用于生成 URL # 值就是函数本身，可以用 route 装饰器注册一个函数 self.view_functions = &#123;&#125; # 所有注册好的错误处理函数，键是错误代码，值是处理函数 # 可以用 errorhandler 注册一个错误处理函数 self.error_handlers = &#123;&#125; # 预处理函数，每次请求之前会执行，用 before_request 装饰器注册 self.before_request_funcs = [] # 后处理函数，每次请求完成以后执行，函数会截获响应并且改变它 # 用 after_request 装饰器注册 self.after_request_funcs = [] # 模板上下文处理器，默认有一个处理函数 _default_template_ctx_processor # 默认的函数功能是向模板上下文添加三个对象 request, session, g # 每个函数执行不需要参数，返回值为字典，用于填充模板上下文 self.template_context_processors = [_default_template_ctx_processor] # 路由映射，在 werkzeug.routing.Map self.url_map = Map() # 架起一个静态资源服务，一般用于开发环境，生产环境用 nginx if self.static_path is not None: self.url_map.add(Rule(self.static_path + '/&lt;filename&gt;', build_only=True, endpoint='static')) if pkg_resources is not None: target = (self.package_name, 'static') else: target = os.path.join(self.root_path, 'static') self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123; self.static_path: target &#125;) # jinja2 模板配置，包括模板目录和默认开启的功能 self.jinja_env = Environment(loader=self.create_jinja_loader(), **self.jinja_options) # 这是两个模板能用到的函数 # url_for 用于根据 endpoint 获取 URL # get_flashed_messages 用于获取消息闪现 self.jinja_env.globals.update( url_for=url_for, get_flashed_messages=get_flashed_messages ) def create_jinja_loader(self): """ 加载模板目录，默认目录为 templates """ if pkg_resources is None: return FileSystemLoader(os.path.join(self.root_path, 'templates')) return PackageLoader(self.package_name) def update_template_context(self, context): """ 为模板上下文注入几个常用的变量，比如 request, session, g context 为填充模板上下文的字典 """ reqctx = _request_ctx_stack.top for func in self.template_context_processors: context.update(func()) def run(self, host='localhost', port=5000, **options): """ 运行开发服务器 """ from werkzeug import run_simple if 'debug' in options: self.debug = options.pop('debug') options.setdefault('use_reloader', self.debug) options.setdefault('use_debugger', self.debug) return run_simple(host, port, self, **options) def test_client(self): """ 为应用程序创建一个测试客户端 """ from werkzeug import Client return Client(self, self.response_class, use_cookies=True) def open_resource(self, resource): """ 动态加载模块 """ if pkg_resources is None: return open(os.path.join(self.root_path, resource), 'rb') return pkg_resources.resource_stream(self.package_name, resource) def open_session(self, request): """ 创建一个 session，secret_key 必须设置 基于 werkzeug.contrib.securecookie.SecureCookie """ key = self.secret_key if key is not None: return SecureCookie.load_cookie(request, self.session_cookie_name, secret_key=key) def save_session(self, session, response): """ 保存 session """ if session is not None: session.save_cookie(response, self.session_cookie_name) def add_url_rule(self, rule, endpoint, **options): """ 创建 URL 和视图函数的映射规则，等同于 route 装饰器 只是 add_url_rule 并没有为视图函数注册一个 endpoint 这一步也就是向 view_functions 字典添加 endpoint: view_func 键值对 以下： @app.route('/') def index(): pass 等同于： def index(): pass app.add_url_rule('index', '/') app.view_functions['index'] = index options: 参数选项详见 werkzeug.routing.Rule """ options['endpoint'] = endpoint options.setdefault('methods', ('GET',)) self.url_map.add(Rule(rule, **options)) def route(self, rule, **options): """ 为给定的 URL 注册一个视图函数 用法： @app.route('/') def index(): return 'Hello World' 变量部分可以用尖括号(``/user/&lt;username&gt;``)指定，默认接受任何不带斜杆的字符串 变量也可以指定一个转换器，以指定类型的参数： =========== =========================================== int 整数 float 浮点数 path 路径 =========== =========================================== 值得注意的是 Flask 如何处理结尾的斜杆，核心思路是保证每个 URL 唯一： 1、如果配置了一个带结尾斜杆的 URL，用户请求不带结尾斜杆的这个 URL，则跳转到带结尾斜杆的页面。 2、如果配置了一个不带结尾斜杆的 URL，用户请求带结尾斜杆的这个 URL，则触发404错误。 这和 web 服务器处理静态资源 static 的逻辑是一样的 参数： rule: URL 字符串 methods: 允许的请求方法，是个列表，默认只接受 GET 请求和隐式的 HEAD subdomain: 指定子域名 strict_slashes: 上述对结尾斜杆处理的开关 options: 参数选项详见 `werkzeug.routing.Rule` """ def decorator(f): self.add_url_rule(rule, f.__name__, **options) self.view_functions[f.__name__] = f return f return decorator def errorhandler(self, code): """ 注册一个错误码处理函数 用法： @app.errorhandler(404) def page_not_found(): return 'This page does not exist', 404 等同于： def page_not_found(): return 'This page does not exist', 404 app.error_handlers[404] = page_not_found 参数： code: 错误码 """ def decorator(f): self.error_handlers[code] = f return f return decorator def before_request(self, f): """注册一个预处理函数""" self.before_request_funcs.append(f) return f def after_request(self, f): """注册一个后处理函数""" self.after_request_funcs.append(f) return f def context_processor(self, f): """注册一个模板上下文处理函数""" self.template_context_processors.append(f) return f def match_request(self): """ 根据当前请求的路由去和url_map匹配，拿到 enpoint 和 view_args endpoint: 端点，是 view_functions 中对应视图函数的key view_args: 视图函数的参数 """ rv = _request_ctx_stack.top.url_adapter.match() request.endpoint, request.view_args = rv return rv def dispatch_request(self): """ 首先调用上面的 match_request 方法拿到 endpoint 和 view_args 根据 endpoint 可以从 view_functions 找到对应的视图函数 再传入视图函数的参数 view_args，并返回结果，这个结果只是函数的返回值 并没有包装成响应类 response_class，可以调用 make_response 方法生成响应 如果函数执行失败，则根据错误码调用对应的错误处理函数 """ try: endpoint, values = self.match_request() return self.view_functions[endpoint](**values) except HTTPException, e: handler = self.error_handlers.get(e.code) if handler is None: return e return handler(e) except Exception, e: handler = self.error_handlers.get(500) if self.debug or handler is None: raise return handler(e) def make_response(self, rv): """ 将视图函数的返回值包装成一个真实的响应类 response_class 函数的返回值支持以下几种类型： ======================= =========================================== response_class: 响应类本身，原样返回 str: 字符串，创建相应类并返回 unicode: unicode 编码，utf-8编码后创建相应类并返回 tuple: 元组，解包元组传入参数创建响应类并返回 a WSGI function: WSGI 函数 ======================= =========================================== 参数： rv: 视图函数的返回值 """ if isinstance(rv, self.response_class): return rv # basestring 是 str 和 unicode 的超类，只支持 python2 if isinstance(rv, basestring): return self.response_class(rv) if isinstance(rv, tuple): return self.response_class(*rv) return self.response_class.force_type(rv, request.environ) def preprocess_request(self): """ 在分发请求之前执行所有的预处理函数，如果预处理函数有返回值不为 None 则返回结果并中断其余的预处理 """ for func in self.before_request_funcs: rv = func() if rv is not None: return rv def process_response(self, response): """ 依次传入响应并执行所有的后处理函数，返回新的响应 """ session = _request_ctx_stack.top.session if session is not None: # 保存 `session` self.save_session(session, response) for handler in self.after_request_funcs: response = handler(response) return response def wsgi_app(self, environ, start_response): """ WSGI 应用，可以用中间件包装： app.wsgi_app = MyMiddleware(app.wsgi_app) 参数： environ: WSGI 环境，是一个字典，包含了所有请求的信息 start_response: 回调函数 """ with self.request_context(environ): rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() response = self.make_response(rv) response = self.process_response(response) return response(environ, start_response) def request_context(self, environ): """ 通过给定的 WSGI 环境创建一个请求上下文，并把它绑定到当前上下文中 必须通过 with 语句使用，因为 request 对象只在请求上下文 也就是 with 语句块中起作用 用法如下： with app.request_context(environ): do_something_with(request) 参数： environ: WSGI 环境 """ return _RequestContext(self, environ) def test_request_context(self, *args, **kwargs): """ 测试请求上下文，参数详见 werkzeug.create_environ """ return self.request_context(create_environ(*args, **kwargs)) def __call__(self, environ, start_response): """调用 wsgi_app 方法""" return self.wsgi_app(environ, start_response) 全局变量12345_request_ctx_stack = LocalStack()current_app = LocalProxy(lambda: _request_ctx_stack.top.app)request = LocalProxy(lambda: _request_ctx_stack.top.request)session = LocalProxy(lambda: _request_ctx_stack.top.session)g = LocalProxy(lambda: _request_ctx_stack.top.g) werkzeug 的 Local，LocalStack 和 LocalProxyFlask 中有两个上下文（Context）： 应用上下文（App Context） 请求上下文（Request Context） 上下文就是函数运行时所需要的外部变量，当我们运行一个简单的求和函数 sum 是不需要外部变量的，而像 Flask 中的视图函数运行需要知道当前的请求的路由、表单和请求方法等等一些信息。 Django 和 Tornado 把视图函数所需要的外部信息封装成一个对象 Request，并把这个对象当作参数传给视图函数，无论视图函数有没有用到，所以编写 Django 的视图函数会到处都见到一个 request 参数。 而 Flask 则使用了类似 Thread Local 的对象，它可以隔离多线程/协程之间的状态，使得多线程/协程像操作一个全局变量一样操作各自的状态而互不影响，原理就是使用当前的线程ID作为命名空间，保存多份字典，每个线程只获取各自线程ID对应的字典。 Flask 并没有使用 Python 标准库的 Thread Local，而是用了 werkzeug 实现的 Local。 Local 和 threading.local 相似，但是 Local 在 Greenlet 可用的情况下优先使用 getcurrent 获取当前线程ID，用以支持 Gevent 调度。 Local 还有一个 __release_local__ 方法，用以释放当前线程存储的状态信息。 LocalStack 是基于 Local 实现的栈结构，可以入栈（push）、出栈（pop）和获取栈顶对象（top）。 LocalProxy 是作为 Local 的一个代理模式，它接受一个 callable 对象，注意参数不是 Local 实例，这个 callable 对象返回的结果才是 Local 实例，所有对于 LocalProxy 对象的操作都会转发到对应的 Local。 上 当 app = Flask(__name__) 实例化一个 Flask App 时，App Context 并没有立即被入栈，LocalStack 栈顶元素是空的，返回 None 值，current_app，request，session 和 g 也是 unbound 状态，此时使用这些对象会引发 RuntimeError，解决方法是手动将 app.app_context() 入栈。 当 Flask 应用被 werkzeug 自带的开发服务器或者 gunicorn 用于生产的这类 WSGI 服务器架起的时候，每一个请求进来之前会自动将请求上下文（Request Context）入栈。 应用上下文（App Context）在 flask v0.1 版本的源码中没有，后面版本引入，应用上下文也会自动入栈，后面待看。 threading.local 使用： Flask 的 App Context 使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190# 优先使用 Greenlet 的线程IDtry: from greenlet import getcurrent as get_identexcept ImportError: try: from thread import get_ident except ImportError: from _thread import get_identclass Local(object): # 固定属性 __slots__ = ('__storage__', '__ident_func__') def __init__(self): # 数据存储，是一个字典 object.__setattr__(self, '__storage__', &#123;&#125;) # 获取当前线程ID的方法 object.__setattr__(self, '__ident_func__', get_ident) def __iter__(self): """以生成器的方式返回字典的所有元素""" return iter(self.__storage__.items()) def __call__(self, proxy): """创建一个 LocalProxy""" return LocalProxy(self, proxy) def __release_local__(self): """清空当前线程/协程所保存的数据""" self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): """属性访问""" try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): """属性设置""" ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): """属性删除""" try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name)class LocalStack(object): """ Local 的栈结构实现 """ def __init__(self): # Local 实例 self._local = Local() def __release_local__(self): # 释放当前线程的数据 self._local.__release_local__() def _get__ident_func__(self): # 返回获取当前线程ID的函数 return self._local.__ident_func__ def _set__ident_func__(self, value): # 设置获取当前线程ID的函数 object.__setattr__(self._local, '__ident_func__', value) __ident_func__ = property(_get__ident_func__, _set__ident_func__) del _get__ident_func__, _set__ident_func__ def __call__(self): """返回一个 LocalProxy 对象，该对象始终指向 LocalStack 实例的栈顶元素""" def _lookup(): rv = self.top if rv is None: raise RuntimeError('object unbound') return rv return LocalProxy(_lookup) def push(self, obj): """入栈""" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): """出栈""" stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): """获取栈顶元素""" try: return self._local.stack[-1] except (AttributeError, IndexError): return None@implements_boolclass LocalProxy(object): """ Local 的代理模式实现，所有对 LocalProxy 对象的操作，包括属性访问、方法调用和二元操作 都会转发到那个 callable 参数返回的 Local 对象上 """ __slots__ = ('__local', '__dict__', '__name__', '__wrapped__') def __init__(self, local, name=None): # 把 callable 参数绑定到 __local 属性上 object.__setattr__(self, '_LocalProxy__local', local) # 代理名字 object.__setattr__(self, '__name__', name) if callable(local) and not hasattr(local, '__release_local__'): # 注意这里的参数 local 仅仅是一个 callable 对象 # 该对象执行返回的结果才是 Local 实例 object.__setattr__(self, '__wrapped__', local) def _get_current_object(self): """获取当前 Local 实例""" if not hasattr(self.__local, '__release_local__'): return self.__local() try: return getattr(self.__local, self.__name__) except AttributeError: raise RuntimeError('no object bound to %s' % self.__name__) @property def __dict__(self): try: return self._get_current_object().__dict__ except RuntimeError: raise AttributeError('__dict__') def __repr__(self): try: obj = self._get_current_object() except RuntimeError: return '&lt;%s unbound&gt;' % self.__class__.__name__ return repr(obj) def __bool__(self): try: return bool(self._get_current_object()) except RuntimeError: return False def __unicode__(self): try: return unicode(self._get_current_object()) # noqa except RuntimeError: return repr(self) def __dir__(self): try: return dir(self._get_current_object()) except RuntimeError: return [] def __getattr__(self, name): if name == '__members__': return dir(self._get_current_object()) return getattr(self._get_current_object(), name) def __setitem__(self, key, value): self._get_current_object()[key] = value def __delitem__(self, key): del self._get_current_object()[key] # 下面的源码省略，LocalProxy 重写了所有的魔法方法]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDS for MySQL 备份文件恢复到自建数据库]]></title>
    <url>%2F2018%2F09%2F13%2Frds-for-mysql%2F</url>
    <content type="text"><![CDATA[云数据库MySQL版使用开源软件Percona Xtrabackup对数据库进行备份，所以您可以使用该软件将云数据库MySQL的备份文件恢复到自建数据库中，本文将介绍详细的操作步骤。 软件说明 MySQL 5.6.41 Percona XtraBackup 2.2.9 rds_backup_extract.sh 解压数据库备份文件12unzip -P密码 mysql_data_backup.tar.gz.zipbash rds_backup_extract -f mysql_data_backup.tar.gz -C /data/mysql/data 修改配置文件 backup-my.cnf 如下123456789101112131415161718# This MySQL options file was generated by innobackupex.# The MySQL server[mysqld]innodb_checksum_algorithm=innodb# innodb_log_checksum_algorithm=innodbinnodb_data_file_path=ibdata1:200M:autoextendinnodb_log_files_in_group=2innodb_log_file_size=1572864000# innodb_fast_checksum=false# innodb_page_size=16384# innodb_log_block_size=512innodb_undo_directory=.innodb_undo_tablespaces=0# rds_encrypt_data=false# innodb_encrypt_algorithm=aes_128_ecb 修改文件属主1chown -R mysql:mysql /data/mysql/data 恢复数据文件12chmod 400 /data/mysql/data/backup-my.cnfinnobackupex --defaults-file=/data/mysql/data/backup-my.cnf --apply-log /data/mysql/data 启动数据库并登入验证1mysqld_safe --defaults-file=/data/mysql/data/backup-my.cnf --user=mysql --datadir=/data/mysql/data --skip-grant-tables &amp; 新建用户恢复完成后，表 mysql.user 中是不包含 RDS 中创建的用户，需要新建，新建用户前请执行如下 SQL： 12345delete from mysql.db where user&lt;&gt;'root' and char_length(user)&gt;0;delete from mysql.tables_priv where user&lt;&gt;'root' and char_length(user)&gt;0;flush privileges; 参考链接阿里云数据备份/恢复]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 离线安装 MySQL]]></title>
    <url>%2F2018%2F09%2F06%2Fcentos-install-mysql%2F</url>
    <content type="text"><![CDATA[记录一下 CentOS 离线安装 MySQL 并配置多实列主从复制的过程，如果有旧版 Mariadb，先卸载旧版 Mariadb。 卸载系统自带的 Mariadb123rpm -qa|grep mariadb # 查询出已安装的 mariadbrpm -e --nodeps filename # 上面列出的所有文件rm -f /etc/my.cnf # 删除配置文件 创建 mysql 用户组12groupadd mysqluseradd -g mysql mysql 下载安装包1wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz 解压文件到目录 /usr/local123456789101112131415cp mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz /usr/local/mysql-8.0.12-linux-glibc2.12-x86_64.tar.xzcd /usr/local# xz 结尾的是经过两层压缩的压缩包# 先解压 xzxz -d your_file_name.tar.xz# 再解压 tartar -xvf your_file_name.tar# 或者直接解压tar xvJf your_file_name.tar.xztar xvJf mysql-8.0.12-linux-glibc2.12-x86_64.tar.xzmv mysql-8.0.12-linux-glibc2.12-x86_64 mysql 配置 /etc/my.cnf1234567891011121314151617181920212223242526272829[mysqld_multi]mysqld = /usr/local/mysql/bin/mysqld_safemysqladmin = /usr/local/mysql/bin/mysqladminuser = root# The MySQL server###############################################################################[mysqld1]port =33306datadir =/data/mysqldata/data1socket =/var/lib/mysql/mysql1.sockpid-file =/var/lib/mysql/mysql1.piduser =mysqlserver_id =33306log_bin =/data/mysqldata/data1/mysql-binlog_bin_index =/data/mysqldata/data1/mysql-bin.indexexpire_logs_days =10 # 按需设置过期时间，表示保留最近10天的日志###############################################################################[mysqld2]port =33307datadir =/data/mysqldata/data2socket =/var/lib/mysql/mysql2.sockpid-file =/var/lib/mysql/mysql2.piduser =mysqlserver_id =33307log_bin =/data/mysqldata/data2/mysql-binlog_bin_index =/data/mysqldata/data2/mysql-bin.indexexpire_logs_days =10 # 按需设置过期时间，表示保留最近10天的日志############################################################################### 初始化数据目录123456789101112131415161718192021mkdir /var/lib/mysqlchown -R mysql:mysql /var/lib/mysqlmkdir /data/mysqldatachown -R mysql:mysql /data/mysqldatamkdir /data/mysqldata/data1chown -R mysql:mysql /data/mysqldata/data1mkdir /data/mysqldata/data2chown -R mysql:mysql /data/mysqldata/data2cd /usr/local/mysql/bin# 这种初始化数据库目录的方式过时了./mysql_install_db --basedir=/usr/local/mysql --datadir=/data/mysqldata/data1 --user=mysql./mysql_install_db --basedir=/usr/local/mysql --datadir=/data/mysqldata/data2 --user=mysql# 新的初始化数据库目录方式，会在终端打印一个临时登入密码。./mysqld --initialize --basedir=/usr/local/mysql --datadir=/data/mysqldata/data1 --user=mysql --console./mysqld --initialize --basedir=/usr/local/mysql --datadir=/data/mysqldata/data2 --user=mysql --console 启动实例1234cd /usr/local/mysql/binmysqld_multi start 1mysqld_multi start 2mysqld_multi report 主库创建同步账号12345678910111213141516171819202122232425262728293031# 用刚才初始化数据库目录生成的临时密码登入./mysql -S /var/lib/mysql/mysql1.sock -p your-password# 如果忘记密码，可以在 my.cnf 的 mysqld 块中添加一行 skip-grant-tables = 1# 可以进行无密码登入，修改成功之后去掉这一行然后重启数据库。# 修改 root 密码USE mysql;UPDATE user SET authentication_string = PASSWORD('new-password'), password_expired = 'N', password_last_changed = NOW() WHERE user = 'root';FLUSH PRIVILEGES;# 授权账户使得局域网内的机器可以访问数据库GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'new-password' WITH GRANT OPTION;# 创建一个同步账户CREATE USER 'repl'@'%' IDENTIFIED BY 'repl-password';GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';# 查看状态SHOW MASTER STATUS;SHOW BINARY LOGS;# 如果忘记设置日志过期时间，可以进入数据库进行全局设置，并手动清理过期日志# 不要在数据库目录进行删除日志，这样会使得数据库日志索引不一致，导致自动清理失效SET GLOBAL EXPIRE_LOGS_DAYS = 10;FLUSH LOGS; # 触发日志清理，一般是在有新的日志生成的时候触发检查一次。SHOW BINARY LOGS;# 也可以手动删除某个日志之前的所有日志PURGE BINARY LOGS TO 'mysql-bin.000080'; # 删除 80 之前的日志SHOW BINARY LOGS; 从库配置123456789101112131415# 修改从库的配置文件server-id =2relay-log =/dbdata/data/relay-logrelay-log-index =/dbdata/data/relay-log.index# 进入数据库执行CHANGE MASTER TOMASTER_HOST=‘master_host_name’, # 主库的主机名MASTER_PORT=port_number # 主库的端口号MASTER_USER=‘replication_user_name’, # 复制的数据库用户名MASTER_PASSWORD=‘replication_password’, # 复制的用户密码MASTER_LOG_FILE=‘recorded_log_file_name’, # 主库的日志文件名MASTER_LOG_POS=recorded_log_position; # 主库的日志文件位置start slave;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium 在 Ubuntu 服务器上的使用]]></title>
    <url>%2F2018%2F08%2F13%2Fselenium-linux%2F</url>
    <content type="text"><![CDATA[安装 chrome1234wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -echo 'deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main' | sudo tee /etc/apt/sources.list.d/google-chrome.listsudo apt-get updatesudo apt-get install google-chrome-stable 安装 chromedriver1234wget -N https://chromedriver.storage.googleapis.com/2.41/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedrivercp chromedriver /usr/bin/ 安装 Xvfb12345sudo apt-get -y install xvfb gtk2-engines-pixbufsudo apt-get -y install xfonts-cyrillic xfonts-100dpi xfonts-75dpi xfonts-base xfonts-scalable# 截图功能，可选sudo apt-get -y install imagemagick x11-appsXvfb -ac :99 -screen 0 1280x1024x16 &amp; export DISPLAY=:99 测试脚本12345678910from selenium import webdriverchrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')driver = webdriver.Chrome(chrome_options=chrome_options,executable_path='/usr/bin/chromedriver')driver.get("https://www.baidu.com")print(driver.title)driver.quit() 遇到的问题ubuntu server 18.04 虽然内置 python3 版本，但是没有 pip在 /etc/apt/sources.list 添加下列源 1234deb http://cn.archive.ubuntu.com/ubuntu bionic main multiverse restricted universedeb http://cn.archive.ubuntu.com/ubuntu bionic-updates main multiverse restricted universedeb http://cn.archive.ubuntu.com/ubuntu bionic-security main multiverse restricted universedeb http://cn.archive.ubuntu.com/ubuntu bionic-proposed main multiverse restricted universe 12sudo apt-get updatesudo apt-get install python3-pip 再用 pip 安装 selenium1pip3 install selenium]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 Python 的关键字 Yield]]></title>
    <url>%2F2018%2F03%2F14%2Funderstand-yield%2F</url>
    <content type="text"><![CDATA[为了理解什么是yield,你必须理解什么是生成器。 在理解生成器之前，让我们先走近迭代。 当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象。 123mylist = [1, 2, 3, 4, 5]for i in mylist: print(i) 所有你可以使用for…in…语法的叫做一个迭代器，列表，字符串，文件等等，你经常使用它们是因为你可以如你所愿的读取其中的元素，但是你把所有的值都存储到了内存中，如果你有大量数据的话这个方式并不是你想要的。 生成器是可以迭代的，但是你只可以读取它一次，因为它并不把所有的值放在内存中，它是实时地生成数据。 123mygenerator = (x * x for x in range(5))for i in mygenerator: print(i) 你不可以再次迭代生成器 1234try: next(mygenerator)except StopIteration: print("停止迭代") yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器。 123def create_generator(): for i in range(5): yield i * i 如果函数内部使用 return，则返回 0。 1234mygenerator = create_generator()for i in mygenerator: print(i) 斐波拉契数列 12345def fib(): x, y = 0, 1 while True: x, y = y, x + y yield x 获取斐波拉契数列前10个 12import itertoolslist(itertools.islice(fib(), 10)) 杨辉三角 12345def triangle(): a = [1] while True: yield a a = [sum(i) for i in zip([0] + a, a + [0])] 输出前10行杨辉三角 12import pprintlist(itertools.islice(triangle(), 10)) 控制迭代器的穷尽 12345678910111213141516171819202122232425262728293031323334class Bank(): crisis = False # crisis是危机的意思 def create_atm(self): while not self.crisis: yield "$100"bank = Bank() # 创建一个银行corner_street_atm = bank.create_atm() # 创建一个ATM机print([next(corner_street_atm) for _ in range(5)])bank.crisis = True # 危机来了try: print(next(corner_street_atm))except StopIteration: print("corner_street_atm: no more money!")try: wall_street_atm = bank.create_atm() print(next(wall_street_atm))except StopIteration: print("wall_street_atm: no more money!")bank.crisis = False # 问题是，即使改变crisis的值，ATM依然是空的try: print(next(corner_street_atm))except StopIteration: print("crisis is %s, and still no more money!" % bank.crisis)# 重新创建一个ATM机，现在有钱了brand_new_atm = bank.create_atm()print([next(brand_new_atm) for _ in range(5)]) itertools 模块包含了许多特殊的迭代方法 比赛中4匹马可能到达终点的先后顺序的可能情况 12345import pprinthorses = [1, 2, 3, 4]races = itertools.permutations(horses)print(races)pprint.pprint(list(races)) 一个实现了 __iter__ 方法的对象是可迭代的，一个实现了 __next__ 方法的对象是迭代器。 12345678910111213141516class Fibs(): def __init__(self): self.a = 0 self.b = 1 def __next__(self): self.a, self.b = self.b, self.a + self.b return self.a def __iter__(self): return selffibs = Fibs()print([next(fibs) for _ in range(10)])]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法的 Python 实现]]></title>
    <url>%2F2018%2F03%2F14%2F8-sort-algorithm%2F</url>
    <content type="text"><![CDATA[插入排序1234567891011def insert_sort(lists): count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists 希尔排序123456789101112131415161718def shell_sort(lists): count = len(lists) step = 2 group = count // step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group //= step return lists 冒泡排序1234567def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 快速排序123456789101112131415161718192021qs = lambda xs: ((len(xs) &lt;= 1 and [xs]) or [qs([x for x in xs[1:] if x &lt; xs[ 0]]) + [xs[0]] + qs([x for x in xs[1:] if x &gt;= xs[0]])])[0]def quick_sort(lists, left=0, right=9): if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 选择排序123456789def select_sort(lists): count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists 堆排序1234567891011121314151617181920212223242526def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size // 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size)def build_heap(lists, size): for i in range(0, (size // 2))[::-1]: adjust_heap(lists, i, size)def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) return lists 归并排序12345678910111213141516171819202122def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return resultdef merge_sort(lists): if len(lists) &lt;= 1: return lists num = len(lists) // 2 left = merge_sort(lists[:num]) right = merge_sort(lists[num:]) return merge(left, right) 基数排序1234567891011121314import mathdef radix_sort(lists, radix=10): k = int(math.ceil(math.log(max(lists), radix))) bucket = [[] for _ in range(radix)] for i in range(1, k + 1): for j in lists: bucket[j // (radix**(i - 1)) % radix].append(j) del lists[:] for z in bucket: lists += z del z[:] return lists 测试12345678910111213141516171819202122232425262728293031323334353637import randomoriginal_test = list(random.randint(1, 100) for _ in range(10))print("原始列表： %s" % original_test)# 插入排序insert_test = insert_sort(original_test)# 希尔排序shell_test = shell_sort(original_test)# 冒泡排序bubble_test = bubble_sort(original_test)快速排序quick_test = quick_sort(original_test)# 直接选择排序select_test = select_sort(original_test)# 堆排序heap_test = heap_sort(original_test)# 归并排序merge_test = merge_sort(original_test)# 基数排序radix_test = radix_sort(original_test)print("插入排序： %s" % insert_test)print("希尔排序： %s" % shell_test)print("冒泡排序： %s" % bubble_test)print("快速排序： %s" % quick_test)print("直接选择排序：%s" % select_test)print("堆排序： %s" % heap_test)print("归并排序： %s" % merge_test)print("基数排序： %s" % radix_test)print("快速排序： %s" % qs(original_test)) 本文来自：八大排序算法的 Python 实现]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Screen 用法]]></title>
    <url>%2F2018%2F03%2F13%2Fscreen-usage%2F</url>
    <content type="text"><![CDATA[GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。 安装 screen1yum install -y screen screen 常用命令新建一个Screen Session 1screen -S session_name 将当前Screen Session放到后台 1CTRL + A + D 唤起一个Screen Session 1screen -r session_name 分享一个Screen Session 1screen -x session_name 终止一个Screen Session 123exitorCTRL + D 默认显示一屏的内容，要查看之前内容，如下操作： 1Ctrl + A ESC 列表所有的会话 1screen -ls 进入某个会话 1screen -r session_name 如果进不去，则 1screen -d session_name 再 1screen -r session_name ctrl + A + N 切换窗口]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种启动 Flask 应用的方式]]></title>
    <url>%2F2018%2F03%2F12%2Fflask-start-up%2F</url>
    <content type="text"><![CDATA[记录几种启动 Flask 应用的方式 首先写一个简单的 index.py 12345678910# -*- coding: utf-8 -*-from flask import Flaskapp = Flask(__name__)@app.route('/', methods=['GET'])def hello(): return 'hello, world!' 最简单的启动方式12if __name__ == '__main__': app.run() 这只能用于开发模式，可以设置debug=True开启调试模式，并且这是单线程同步的。 用 tornado 驱动 flask写一个server.py，并将上面index.py中的启动代码去掉，终端运行python server.py。 123456789# -*- coding: utf-8 -*-from tornado.wsgi import WSGIContainerfrom tornado.httpserver import HTTPServerfrom tornado.ioloop import IOLoopfrom index import apphttp_server = HTTPServer(WSGIContainer(app))http_server.listen(5000) # flask默认的端口IOLoop.instance().start() 这也是同步的，同一时间只能处理一个请求，可以写个简单的接口测试一下。 123456789101112131415161718192021# -*- coding: utf-8 -*-import timefrom flask import Flaskapp = Flask(__name__)@app.route('/', methods=['GET'])def hello(): return 'hello, world!'@app.route('/test', methods=['GET'])def test(): for n in range(10): print(n) time.sleep(2) return 'hello' 用postman同时发起5个请求，后台按顺序打印0-9，5个请求是一个一个执行的。 用 twisted 驱动 flask这个可以同时处理多个请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-import timefrom flask import Flaskapp = Flask(__name__)@app.route('/', methods=['GET'])def hello(): return 'hello, world!'@app.route('/test', methods=['GET'])def test(): for n in range(10): print(n) time.sleep(2) return 'hello'if __name__ == "__main__": reactor_args = &#123;&#125; def run_twisted_wsgi(): from twisted.internet import reactor from twisted.web.server import Site from twisted.web.wsgi import WSGIResource resource = WSGIResource(reactor, reactor.getThreadPool(), app) site = Site(resource) reactor.listenTCP(5000, site) reactor.run(**reactor_args) if app.debug: # Disable twisted signal handlers in development only. reactor_args['installSignalHandlers'] = 0 # Turn on auto reload. import werkzeug.serving run_twisted_wsgi = werkzeug.serving.run_with_reloader(run_twisted_wsgi) run_twisted_wsgi()if __name__ == '__main__': app.run()]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 编译安装 Python3]]></title>
    <url>%2F2018%2F03%2F12%2Fcentos-install-python3%2F</url>
    <content type="text"><![CDATA[记录一下 CentOS 编译安装 Python3 的过程。 安装 openssl1yum install -y openssl-static 安装 gcc1yum install -y gcc 安装 sqlite-devel少了这步的话，python3的一些库如twisted使用不正常，会提示缺少_sqlit3。 1yum install -y sqlite-devel 下载 python3 包1wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz 解压1tar -zxvf Python-3.6.4.tgz 配置12cd Python-3.6.4./configure --prefix=/usr/local/python3 --enable-loadable-sqlite-extensions --enable-optimizations 编译安装1make &amp;&amp; make install 添加软连接1ln -s /usr/local/python3/bin/python3 /usr/bin/python3 后记检查是否安装成功 1python3 --version yum 搜索可用包 1yum search python3 | grep devel 一键更新 python 包 1pip list --outdated --format=freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 脚本自动重载]]></title>
    <url>%2F2018%2F03%2F09%2Fpython-reloader%2F</url>
    <content type="text"><![CDATA[Django 和 Flask 应用开启 debug 模式之后都能检测代码的变化然后自动重载，于是去找实现代码，发现 Flask 是用的 werkzeug 库里面的功能，而 Django 的不好用于自己写的脚本，因为和 Django 应用结合了。 下面是 werkzeug 中的 _reloader 模块中的 run_with_reloader 函数。 12345678910111213141516def run_with_reloader(main_func, extra_files=None, interval=1, reloader_type='auto'): """Run the given function in an independent python interpreter.""" import signal reloader = reloader_loops[reloader_type](extra_files, interval) signal.signal(signal.SIGTERM, lambda *args: sys.exit(0)) try: if os.environ.get('WERKZEUG_RUN_MAIN') == 'true': t = threading.Thread(target=main_func, args=()) t.setDaemon(True) t.start() reloader.run() else: sys.exit(reloader.restart_with_reloader()) except KeyboardInterrupt: pass 用法如下 1234567891011import timedef main(): while True: print("hello, world!") time.sleep(2)if __name__ == '__main__': run_with_reloader(main) 但是执行函数不能传参，修改 run_with_reloader 如下 123456789101112131415161718192021def run_with_reloader(main_func, args=(), kwargs=None, extra_files=None, interval=1, reloader_type='auto'): """Run the given function in an independent python interpreter.""" import os import sys import signal import threading from werkzeug._reloader import reloader_loops reloader = reloader_loops[reloader_type](extra_files, interval) signal.signal(signal.SIGTERM, lambda *args: sys.exit(0)) try: if os.environ.get('WERKZEUG_RUN_MAIN') == 'true': t = threading.Thread(target=main_func, args=args, kwargs=kwargs) t.setDaemon(True) t.start() reloader.run() else: sys.exit(reloader.restart_with_reloader()) except KeyboardInterrupt: pass 然后就能传参了 123456789101112import timedef main(name, age): while True: print("hello, ", name, '!') time.sleep(2) print(age)if __name__ == '__main__': run_with_reloader(main, args=('foo', 20))]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
</search>
