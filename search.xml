<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八大排序算法的 Python 实现</title>
    <url>/2018/03/14/8-sort-algorithm/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    count = <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, count):</span><br><span class="line">        key = lists[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> lists[j] &gt; key:</span><br><span class="line">                lists[j + <span class="number">1</span>] = lists[j]</span><br><span class="line">                lists[j] = key</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="/images/Insertion_sort_animation.gif" class="lazyload" data-srcset="/images/Insertion_sort_animation.gif" srcset="data:image/png;base64,666" alt="insert_sort"></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    count = <span class="built_in">len</span>(lists)</span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    group = count // step</span><br><span class="line">    <span class="keyword">while</span> group &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, group):</span><br><span class="line">            j = i + group</span><br><span class="line">            <span class="keyword">while</span> j &lt; count:</span><br><span class="line">                k = j - group</span><br><span class="line">                key = lists[j]</span><br><span class="line">                <span class="keyword">while</span> k &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> lists[k] &gt; key:</span><br><span class="line">                        lists[k + group] = lists[k]</span><br><span class="line">                        lists[k] = key</span><br><span class="line">                    k -= group</span><br><span class="line">                j += group</span><br><span class="line">        group //= step</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sorting_shellsort_anim.gif" class="lazyload" data-srcset="/images/Sorting_shellsort_anim.gif" srcset="data:image/png;base64,666" alt="shell_sort"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    count = <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> lists[i] &gt; lists[j]:</span><br><span class="line">                lists[i], lists[j] = lists[j], lists[i]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bubble_sort_animation.gif" class="lazyload" data-srcset="/images/Bubble_sort_animation.gif" srcset="data:image/png;base64,666" alt="bubble_sort"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs = <span class="keyword">lambda</span> xs: ((<span class="built_in">len</span>(xs) &lt;= <span class="number">1</span> <span class="keyword">and</span> [xs]) <span class="keyword">or</span> [qs([x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; xs[</span><br><span class="line">                 <span class="number">0</span>]]) + [xs[<span class="number">0</span>]] + qs([x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= xs[<span class="number">0</span>]])])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">lists, left=<span class="number">0</span>, right=<span class="number">9</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span> lists</span><br><span class="line">    key = lists[left]</span><br><span class="line">    low = left</span><br><span class="line">    high = right</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        lists[left] = lists[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        lists[right] = lists[left]</span><br><span class="line">    lists[right] = key</span><br><span class="line">    quick_sort(lists, low, left - <span class="number">1</span>)</span><br><span class="line">    quick_sort(lists, left + <span class="number">1</span>, high)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sorting_quicksort_anim.gif" class="lazyload" data-srcset="/images/Sorting_quicksort_anim.gif" srcset="data:image/png;base64,666" alt="quick_sort"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    count = <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        <span class="built_in">min</span> = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> lists[<span class="built_in">min</span>] &gt; lists[j]:</span><br><span class="line">                <span class="built_in">min</span> = j</span><br><span class="line">        lists[<span class="built_in">min</span>], lists[i] = lists[i], lists[<span class="built_in">min</span>]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/Selection_sort_animation.gif" class="lazyload" data-srcset="/images/Selection_sort_animation.gif" srcset="data:image/png;base64,666" alt="select_sort"></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span>(<span class="params">lists, i, size</span>):</span></span><br><span class="line">    lchild = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    rchild = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    <span class="built_in">max</span> = i</span><br><span class="line">    <span class="keyword">if</span> i &lt; size // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> lists[lchild] &gt; lists[<span class="built_in">max</span>]:</span><br><span class="line">            <span class="built_in">max</span> = lchild</span><br><span class="line">        <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> lists[rchild] &gt; lists[<span class="built_in">max</span>]:</span><br><span class="line">            <span class="built_in">max</span> = rchild</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> != i:</span><br><span class="line">            lists[<span class="built_in">max</span>], lists[i] = lists[i], lists[<span class="built_in">max</span>]</span><br><span class="line">            adjust_heap(lists, <span class="built_in">max</span>, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">lists, size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, (size // <span class="number">2</span>))[::-<span class="number">1</span>]:</span><br><span class="line">        adjust_heap(lists, i, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(lists)</span><br><span class="line">    build_heap(lists, size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size)[::-<span class="number">1</span>]:</span><br><span class="line">        lists[<span class="number">0</span>], lists[i] = lists[i], lists[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(lists, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sorting_heapsort_anim.gif" class="lazyload" data-srcset="/images/Sorting_heapsort_anim.gif" srcset="data:image/png;base64,666" alt="heap_sort"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lists</span><br><span class="line">    num = <span class="built_in">len</span>(lists) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(lists[:num])</span><br><span class="line">    right = merge_sort(lists[num:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Merge_sort_animation2.gif" class="lazyload" data-srcset="/images/Merge_sort_animation2.gif" srcset="data:image/png;base64,666" alt="merge_sort"></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span>(<span class="params">lists, radix=<span class="number">10</span></span>):</span></span><br><span class="line">    k = <span class="built_in">int</span>(math.ceil(math.log(<span class="built_in">max</span>(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j // (radix**(i - <span class="number">1</span>)) % radix].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<p><img src="/images/radix_sort.gif" class="lazyload" data-srcset="/images/radix_sort.gif" srcset="data:image/png;base64,666" alt="merge_sort"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">original_test = <span class="built_in">list</span>(random.randint(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">&quot;原始列表：    %s&quot;</span> % original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line">insert_test = insert_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 希尔排序</span></span><br><span class="line">shell_test = shell_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line">bubble_test = bubble_sort(original_test)</span><br><span class="line"></span><br><span class="line">快速排序</span><br><span class="line">quick_test = quick_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接选择排序</span></span><br><span class="line">select_test = select_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line">heap_test = heap_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line">merge_test = merge_sort(original_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line">radix_test = radix_sort(original_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;插入排序：    %s&quot;</span> % insert_test)</span><br><span class="line">print(<span class="string">&quot;希尔排序：    %s&quot;</span> % shell_test)</span><br><span class="line">print(<span class="string">&quot;冒泡排序：    %s&quot;</span> % bubble_test)</span><br><span class="line">print(<span class="string">&quot;快速排序：    %s&quot;</span> % quick_test)</span><br><span class="line">print(<span class="string">&quot;直接选择排序：%s&quot;</span> % select_test)</span><br><span class="line">print(<span class="string">&quot;堆排序：      %s&quot;</span> % heap_test)</span><br><span class="line">print(<span class="string">&quot;归并排序：    %s&quot;</span> % merge_test)</span><br><span class="line">print(<span class="string">&quot;基数排序：    %s&quot;</span> % radix_test)</span><br><span class="line">print(<span class="string">&quot;快速排序：    %s&quot;</span> % qs(original_test))</span><br></pre></td></tr></table></figure>

<p>本文来自：<a href="http://python.jobbole.com/82270">八大排序算法的 Python 实现</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Asyncio 笔记</title>
    <url>/2018/11/11/asyncio-tutorial/</url>
    <content><![CDATA[<!-- toc -->

<!-- markdownlint-disable MD033 -->

<blockquote><p>并发是指一次处理多件事。
并行是指一次做多件事。
二者不同，但是有联系。
一个关于结构，一个关于执行。
并发用于制定方案，用来解决可能（但未必）并行的问题。</p>
<p align="right">——Rob Pike
Go 语言的创造者之一</p></blockquote>

<a id="more"></a>

<hr>
<h2 id="异步版-hello-world"><a href="#异步版-hello-world" class="headerlink" title="异步版 hello-world"></a>异步版 <code>hello-world</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">.1</span>)</span><br><span class="line">    print(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.7 提供</span></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># main 函数是个协程，直接运行不会执行操作</span></span><br><span class="line"><span class="comment"># main() --&gt; &lt;coroutine object main at 0x109be6d48&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="运行协程的三种方式"><a href="#运行协程的三种方式" class="headerlink" title="运行协程的三种方式"></a>运行协程的三种方式</h2><ul>
<li><code>asyncio.run()</code></li>
<li>使用 <code>await</code> 关键字</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span>(<span class="params">delay, what</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>asyncio.create_task()</code> 创建一个 <code>Task</code> 对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接对上面的 main 函数进行修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">    t2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> t1</span><br><span class="line">    <span class="keyword">await</span> t2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Awaitable-对象"><a href="#Awaitable-对象" class="headerlink" title="Awaitable 对象"></a>Awaitable 对象</h2><p><code>awaitable</code> 对象是指可以在 <code>await</code> 表达式中使用的对象。</p>
<p><code>coroutines</code>, <code>Tasks</code> 和 <code>Futures</code> 是 <code>awaitable</code> 对象。</p>
<ul>
<li>协程 <code>coroutines</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这中方式不会执行 nested 函数</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># await</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<ul>
<li>任务 <code>Tasks</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t = asyncio.create_task(nested())</span><br><span class="line">    <span class="keyword">await</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<ul>
<li>期物 <code>Futures</code></li>
</ul>
<h2 id="并发执行-Tasks"><a href="#并发执行-Tasks" class="headerlink" title="并发执行 Tasks"></a>并发执行 Tasks</h2><p>使用 <code>asyncio.gather</code> 并发执行 <code>Tasks</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">name, number</span>):</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h2 id="线程和协程的对比"><a href="#线程和协程的对比" class="headerlink" title="线程和协程的对比"></a>线程和协程的对比</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程版以动画形式显示文本旋转指针</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>:</span></span><br><span class="line">    go = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span>(<span class="params">msg, signal</span>):</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">&#x27;|/-\\&#x27;</span>):</span><br><span class="line">        status = char + <span class="string">&#x27; &#x27;</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">&#x27;\x08&#x27;</span> * <span class="built_in">len</span>(status))</span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> signal.go:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    write(<span class="string">&#x27; &#x27;</span> * <span class="built_in">len</span>(status) + <span class="string">&#x27;\x08&#x27;</span> * <span class="built_in">len</span>(status))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_funtion</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span>():</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(</span><br><span class="line">        target=spin,</span><br><span class="line">        args=(<span class="string">&#x27;thinking!&#x27;</span>, signal))</span><br><span class="line">    print(<span class="string">&#x27;spinner object: &#x27;</span>, spinner)</span><br><span class="line">    spinner.start()</span><br><span class="line">    result = slow_funtion()</span><br><span class="line">    signal.go = <span class="literal">False</span></span><br><span class="line">    spinner.join()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = supervisor()</span><br><span class="line">    print(<span class="string">&#x27;Answer: &#x27;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 协程版以动画形式显示文本旋转指针</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">spin</span>(<span class="params">msg</span>):</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">&#x27;|/-\\&#x27;</span>):</span><br><span class="line">        status = char + <span class="string">&#x27; &#x27;</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">&#x27;\x08&#x27;</span> * <span class="built_in">len</span>(status))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    write(<span class="string">&#x27; &#x27;</span> * <span class="built_in">len</span>(status) + <span class="string">&#x27;\x08&#x27;</span> * <span class="built_in">len</span>(status))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">slow_funtion</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisor</span>():</span></span><br><span class="line">    spinner = asyncio.create_task(spin(<span class="string">&#x27;thinking!&#x27;</span>))</span><br><span class="line">    print(<span class="string">&#x27;spinner object: &#x27;</span>, spinner)</span><br><span class="line">    result = <span class="keyword">await</span> slow_funtion()</span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般执行方式</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">result = loop.run_until_complete(supervisor())</span><br><span class="line">loop.close()</span><br><span class="line">print(<span class="string">&#x27;Answer: &#x27;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.7 执行方式</span></span><br><span class="line">asyncio.run(supervisor())</span><br></pre></td></tr></table></figure>

<ul>
<li>Task 对象像是实现协作式多任务的库（如 <code>gevent</code>）中的绿色线程（<code>green thread</code>）。</li>
<li>Task 对象用于驱动协程，Thread 对象用于调用可调用对象。</li>
<li>Task 对象不由自己手动实例化，而是由 <code>asyncio.create_task</code> 方法获取。</li>
<li>获取的 Task 对象已经排定了运行时间，而 Thread 实例需要调用 <code>start</code> 方法运行。</li>
<li>异步版 <code>slow_funtion</code> 是协程，由 <code>await</code> （就是 <code>yield from</code>）驱动。</li>
<li>终止线程需要借助外部变量 <code>go</code>,终止 Task 可以调用 <code>Task.cancel()</code> 实例方法，在协程内部抛出 <code>CancelledError</code> 异常，协程内部也可以捕获这个异常，处理终止请求。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 离线安装 MySQL</title>
    <url>/2018/09/06/centos-install-mysql/</url>
    <content><![CDATA[<p>记录一下 CentOS 离线安装 MySQL 并配置多实列主从复制的过程，<br>如果有旧版 Mariadb，先卸载旧版 Mariadb。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="卸载系统自带的-Mariadb"><a href="#卸载系统自带的-Mariadb" class="headerlink" title="卸载系统自带的 Mariadb"></a>卸载系统自带的 Mariadb</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mariadb        <span class="comment"># 查询出已安装的 mariadb</span></span><br><span class="line">rpm -e --nodeps filename    <span class="comment"># 上面列出的所有文件</span></span><br><span class="line">rm -f /etc/my.cnf           <span class="comment"># 删除配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="创建-mysql-用户组"><a href="#创建-mysql-用户组" class="headerlink" title="创建 mysql 用户组"></a>创建 mysql 用户组</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure>

<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="解压文件到目录-usr-local"><a href="#解压文件到目录-usr-local" class="headerlink" title="解压文件到目录 /usr/local"></a>解压文件到目录 /usr/local</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz /usr/<span class="built_in">local</span>/mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xz 结尾的是经过两层压缩的压缩包</span></span><br><span class="line"><span class="comment"># 先解压 xz</span></span><br><span class="line">xz -d your_file_name.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再解压 tar</span></span><br><span class="line">tar -xvf your_file_name.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接解压</span></span><br><span class="line">tar xvJf your_file_name.tar.xz</span><br><span class="line"></span><br><span class="line">tar xvJf mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line">mv mysql-8.0.12-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure>

<h2 id="配置-etc-my-cnf"><a href="#配置-etc-my-cnf" class="headerlink" title="配置 /etc/my.cnf"></a>配置 /etc/my.cnf</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysqld_multi]</span><br><span class="line">mysqld     = /usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe</span><br><span class="line">mysqladmin = /usr/<span class="built_in">local</span>/mysql/bin/mysqladmin</span><br><span class="line">user       = root</span><br><span class="line"></span><br><span class="line"><span class="comment"># The MySQL server</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line">[mysqld1]</span><br><span class="line">port                =33306</span><br><span class="line">datadir             =/data/mysqldata/data1</span><br><span class="line">socket              =/var/lib/mysql/mysql1.sock</span><br><span class="line">pid-file            =/var/lib/mysql/mysql1.pid</span><br><span class="line">user                =mysql</span><br><span class="line">server_id           =33306</span><br><span class="line">log_bin             =/data/mysqldata/data1/mysql-bin</span><br><span class="line">log_bin_index       =/data/mysqldata/data1/mysql-bin.index</span><br><span class="line">expire_logs_days    =10  <span class="comment"># 按需设置过期时间，表示保留最近10天的日志</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line">[mysqld2]</span><br><span class="line">port                =33307</span><br><span class="line">datadir             =/data/mysqldata/data2</span><br><span class="line">socket              =/var/lib/mysql/mysql2.sock</span><br><span class="line">pid-file            =/var/lib/mysql/mysql2.pid</span><br><span class="line">user                =mysql</span><br><span class="line">server_id           =33307</span><br><span class="line">log_bin             =/data/mysqldata/data2/mysql-bin</span><br><span class="line">log_bin_index       =/data/mysqldata/data2/mysql-bin.index</span><br><span class="line">expire_logs_days    =10  <span class="comment"># 按需设置过期时间，表示保留最近10天的日志</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /var/lib/mysql</span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br><span class="line"></span><br><span class="line">mkdir /data/mysqldata</span><br><span class="line">chown -R mysql:mysql /data/mysqldata</span><br><span class="line"></span><br><span class="line">mkdir /data/mysqldata/data1</span><br><span class="line">chown -R mysql:mysql /data/mysqldata/data1</span><br><span class="line"></span><br><span class="line">mkdir /data/mysqldata/data2</span><br><span class="line">chown -R mysql:mysql /data/mysqldata/data2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种初始化数据库目录的方式过时了</span></span><br><span class="line">./mysql_install_db --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysqldata/data1 --user=mysql</span><br><span class="line">./mysql_install_db --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysqldata/data2 --user=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新的初始化数据库目录方式，会在终端打印一个临时登入密码。</span></span><br><span class="line">./mysqld --initialize --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysqldata/data1 --user=mysql --console</span><br><span class="line">./mysqld --initialize --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysqldata/data2 --user=mysql --console</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line">mysqld_multi start 1</span><br><span class="line">mysqld_multi start 2</span><br><span class="line">mysqld_multi report</span><br></pre></td></tr></table></figure>

<h2 id="主库创建同步账号"><a href="#主库创建同步账号" class="headerlink" title="主库创建同步账号"></a>主库创建同步账号</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用刚才初始化数据库目录生成的临时密码登入</span></span><br><span class="line">./mysql -S /var/lib/mysql/mysql1.sock -p your-password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果忘记密码，可以在 my.cnf 的 mysqld 块中添加一行 skip-grant-tables = 1</span></span><br><span class="line"><span class="comment"># 可以进行无密码登入，修改成功之后去掉这一行然后重启数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 root 密码</span></span><br><span class="line">USE mysql;</span><br><span class="line">UPDATE user SET authentication_string = PASSWORD(<span class="string">&#x27;new-password&#x27;</span>), password_expired = <span class="string">&#x27;N&#x27;</span>, password_last_changed = NOW() WHERE user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权账户使得局域网内的机器可以访问数据库</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;new-password&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个同步账户</span></span><br><span class="line">CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;repl-password&#x27;</span>;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">SHOW MASTER STATUS;</span><br><span class="line">SHOW BINARY LOGS;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果忘记设置日志过期时间，可以进入数据库进行全局设置，并手动清理过期日志</span></span><br><span class="line"><span class="comment"># 不要在数据库目录进行删除日志，这样会使得数据库日志索引不一致，导致自动清理失效</span></span><br><span class="line">SET GLOBAL EXPIRE_LOGS_DAYS = 10;</span><br><span class="line">FLUSH LOGS;  <span class="comment"># 触发日志清理，一般是在有新的日志生成的时候触发检查一次。</span></span><br><span class="line">SHOW BINARY LOGS;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以手动删除某个日志之前的所有日志</span></span><br><span class="line">PURGE BINARY LOGS TO <span class="string">&#x27;mysql-bin.000080&#x27;</span>;  <span class="comment"># 删除 80 之前的日志</span></span><br><span class="line">SHOW BINARY LOGS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改从库的配置文件</span></span><br><span class="line">server-id          =2</span><br><span class="line">relay-log          =/dbdata/data/relay-log</span><br><span class="line">relay-log-index    =/dbdata/data/relay-log.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入数据库执行</span></span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=‘master_host_name’, <span class="comment"># 主库的主机名</span></span><br><span class="line">MASTER_PORT=port_number <span class="comment"># 主库的端口号</span></span><br><span class="line">MASTER_USER=‘replication_user_name’, <span class="comment"># 复制的数据库用户名</span></span><br><span class="line">MASTER_PASSWORD=‘replication_password’, <span class="comment"># 复制的用户密码</span></span><br><span class="line">MASTER_LOG_FILE=‘recorded_log_file_name’, <span class="comment"># 主库的日志文件名</span></span><br><span class="line">MASTER_LOG_POS=recorded_log_position; <span class="comment"># 主库的日志文件位置</span></span><br><span class="line"></span><br><span class="line">start slave;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 编译安装 Python3</title>
    <url>/2018/03/12/centos-install-python3/</url>
    <content><![CDATA[<p>记录一下 CentOS 编译安装 Python3 的过程。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="安装系统相关依赖"><a href="#安装系统相关依赖" class="headerlink" title="安装系统相关依赖"></a>安装系统相关依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel openssl-static openssl-devel xz xz-devel libffi-devel findutils gcc wget</span><br></pre></td></tr></table></figure>

<h2 id="下载-python3-包"><a href="#下载-python3-包" class="headerlink" title="下载 python3 包"></a>下载 python3 包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.9.6/Python-3.9.6.tgz</span><br></pre></td></tr></table></figure>

<h2 id="解压到当前目录"><a href="#解压到当前目录" class="headerlink" title="解压到当前目录"></a>解压到当前目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf Python-3.9.6.tgz</span><br></pre></td></tr></table></figure>

<h2 id="进入生成的目录进行配置"><a href="#进入生成的目录进行配置" class="headerlink" title="进入生成的目录进行配置"></a>进入生成的目录进行配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3 --enable-loadable-sqlite-extensions --enable-optimizations</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="添加软连接"><a href="#添加软连接" class="headerlink" title="添加软连接"></a>添加软连接</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>yum</code> 搜索可用包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search python3 | grep devel</span><br></pre></td></tr></table></figure>

<p>一键更新 <code>python</code> 包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip list --outdated --format=freeze | grep -v <span class="string">&#x27;^\-e&#x27;</span> | cut -d = -f 1  | xargs -n1 pip install -U</span><br></pre></td></tr></table></figure>

<p>切换豆瓣源</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 编辑 .pip/pip.conf 添加如下内容</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br><span class="line"></span><br><span class="line">[list]</span><br><span class="line">format = columns</span><br></pre></td></tr></table></figure>

<p>离线安装python包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先离线下载依赖包，比如 `tensorflow-cpu`，同时会下载所有的依赖项</span></span><br><span class="line">python3 -m pip download -d packages tensorflow-cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载和目标机器对应架构的依赖包</span></span><br><span class="line"><span class="comment"># https://pip.pypa.io/en/stable/cli/pip_download/</span></span><br><span class="line">python3 -m pip download \</span><br><span class="line">    --only-binary=:all: \</span><br><span class="line">    --platform manylinux1_x86_64 --platform linux_x86_64 --platform any \</span><br><span class="line">    --python-version 36 \</span><br><span class="line">    --implementation cp \</span><br><span class="line">    --abi cp36m --abi cp36 --abi abi3 --abi none \</span><br><span class="line">    tensorflow-cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 离线安装，指定寻找包的目录为 packages</span></span><br><span class="line">python3 -m pip install --no-index --find-links=packages -r requirements.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 处理 Csv 文件常见错误</title>
    <url>/2018/12/03/csv-error/</url>
    <content><![CDATA[<p>在用 Python 处理 csv 文件时遇到2个错误，记录下处理方法。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="字段包含-NULL-值"><a href="#字段包含-NULL-值" class="headerlink" title="字段包含 NULL 值"></a>字段包含 NULL 值</h2><p>csv 文件中字段包含 NULL 值会出错，解决方法是读取文件时把 NULL 值替换为空字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    fc = csv.DictReader((line.replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> f))</span><br><span class="line">    <span class="comment"># do something with fc</span></span><br></pre></td></tr></table></figure>

<h2 id="OverflowError-and-maxInt"><a href="#OverflowError-and-maxInt" class="headerlink" title="OverflowError and maxInt"></a>OverflowError and maxInt</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">maxInt = sys.maxsize</span><br><span class="line">decrement = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> decrement:</span><br><span class="line">    <span class="comment"># decrease the maxInt value by factor 10</span></span><br><span class="line">    <span class="comment"># as long as the OverflowError occurs.</span></span><br><span class="line"></span><br><span class="line">    decrement = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        csv.field_size_limit(maxInt)</span><br><span class="line">    <span class="keyword">except</span> OverflowError:</span><br><span class="line">        maxInt = <span class="built_in">int</span>(maxInt / <span class="number">10</span>)</span><br><span class="line">        decrement = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    fc = csv.DictReader(f)</span><br><span class="line">    <span class="comment"># do something with fc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 安装 PhantomJS</title>
    <url>/2018/11/21/centos-install-phantomjs/</url>
    <content><![CDATA[<p>PhantomJS 已经不再开发了，Seleniumn 也警告使用 PhantomJS 是过时的，推荐使用 headless 版的 Chrome 或者 Firefox，但是有时候需要用到，够用就行，而且在 Linux 下安装也相对简单。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="安装-fontconfig-依赖"><a href="#安装-fontconfig-依赖" class="headerlink" title="安装 fontconfig 依赖"></a>安装 fontconfig 依赖</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y fontconfig freetype freetype-devel fontconfig-devel libstdc++</span><br></pre></td></tr></table></figure>

<h2 id="下载-PhantomJS-并解压"><a href="#下载-PhantomJS-并解压" class="headerlink" title="下载 PhantomJS 并解压"></a>下载 PhantomJS 并解压</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装到此目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -jxvf phantomjs-2.1.1-linux-x86_64.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv phantomjs-2.1.1-linux-x86_64 phantomjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加软链接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/phantomjs/bin/phantomjs /usr/bin/phantomjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">phantomjs --version</span><br></pre></td></tr></table></figure>

<h2 id="用-Sselenium-驱动-PhantomJS"><a href="#用-Sselenium-驱动-PhantomJS" class="headerlink" title="用 Sselenium 驱动 PhantomJS"></a>用 Sselenium 驱动 PhantomJS</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改浏览器头</span></span><br><span class="line">dcap = <span class="built_in">dict</span>(DesiredCapabilities.PHANTOMJS)</span><br><span class="line">dcap[<span class="string">&quot;phantomjs.page.settings.userAgent&quot;</span>] = <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;</span></span><br><span class="line">driver = webdriver.PhantomJS(desired_capabilities=dcap)</span><br><span class="line">driver.set_page_load_timeout(<span class="number">10</span>)</span><br><span class="line">driver.set_script_timeout(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="推荐使用的-Chrome-用法"><a href="#推荐使用的-Chrome-用法" class="headerlink" title="推荐使用的 Chrome 用法"></a>推荐使用的 Chrome 用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无界面浏览器</span></span><br><span class="line">options = Options()</span><br><span class="line">options.add_argument(<span class="string">&#x27;headless&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;disable-gpu&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;window-size=1200x600&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用 javascript</span></span><br><span class="line">prefs = &#123;<span class="string">&#x27;profile.managed_default_content_settings.javascript&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止弹出式窗口</span></span><br><span class="line">prefs = &#123;<span class="string">&quot;profile.default_content_setting_values.notifications&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用图片</span></span><br><span class="line">prefs = &#123;<span class="string">&#x27;profile.managed_default_content_settings.images&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(chrome_options=options)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行JS</span></span><br><span class="line">driver.execute_script(<span class="string">&#x27;window.scrollTo(0, 0)&#x27;</span>)  <span class="comment"># scroll to top</span></span><br><span class="line">driver.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)  <span class="comment"># end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>几种启动 Flask 应用的方式</title>
    <url>/2018/03/12/flask-start-up/</url>
    <content><![CDATA[<p>记录几种启动 Flask 应用的方式</p>
<a id="more"></a>

<!-- toc -->

<p>首先写一个简单的 <code>index.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最简单的启动方式"><a href="#最简单的启动方式" class="headerlink" title="最简单的启动方式"></a>最简单的启动方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>这只能用于开发模式，可以设置<code>debug=True</code>开启调试模式，并且这是单线程同步的。</p>
<h2 id="用-tornado-驱动-flask"><a href="#用-tornado-驱动-flask" class="headerlink" title="用 tornado 驱动 flask"></a>用 <code>tornado</code> 驱动 <code>flask</code></h2><p>写一个<code>server.py</code>，并将上面<code>index.py</code>中的启动代码去掉，终端运行<code>python server.py</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.wsgi <span class="keyword">import</span> WSGIContainer</span><br><span class="line"><span class="keyword">from</span> tornado.httpserver <span class="keyword">import</span> HTTPServer</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"><span class="keyword">from</span> index <span class="keyword">import</span> app</span><br><span class="line">http_server = HTTPServer(WSGIContainer(app))</span><br><span class="line">http_server.listen(<span class="number">5000</span>)  <span class="comment"># flask默认的端口</span></span><br><span class="line">IOLoop.instance().start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这也是同步的，同一时间只能处理一个请求，可以写个简单的接口测试一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        print(n)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用postman同时发起5个请求，后台按顺序打印0-9，5个请求是一个一个执行的。</p>
<h2 id="用-twisted-驱动-flask"><a href="#用-twisted-驱动-flask" class="headerlink" title="用 twisted 驱动 flask"></a>用 <code>twisted</code> 驱动 <code>flask</code></h2><p>这个可以同时处理多个请求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        print(n)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    reactor_args = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_twisted_wsgi</span>():</span></span><br><span class="line">        <span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line">        <span class="keyword">from</span> twisted.web.server <span class="keyword">import</span> Site</span><br><span class="line">        <span class="keyword">from</span> twisted.web.wsgi <span class="keyword">import</span> WSGIResource</span><br><span class="line"></span><br><span class="line">        resource = WSGIResource(reactor, reactor.getThreadPool(), app)</span><br><span class="line">        site = Site(resource)</span><br><span class="line">        reactor.listenTCP(<span class="number">5000</span>, site)</span><br><span class="line">        reactor.run(**reactor_args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> app.debug:</span><br><span class="line">        <span class="comment"># Disable twisted signal handlers in development only.</span></span><br><span class="line">        reactor_args[<span class="string">&#x27;installSignalHandlers&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Turn on auto reload.</span></span><br><span class="line">        <span class="keyword">import</span> werkzeug.serving</span><br><span class="line">        run_twisted_wsgi = werkzeug.serving.run_with_reloader(run_twisted_wsgi)</span><br><span class="line"></span><br><span class="line">    run_twisted_wsgi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 通过 Thrift 操作 Hbase</title>
    <url>/2018/11/14/hbase-thrift/</url>
    <content><![CDATA[<!-- toc -->

<p>记录 Python 通过 Thrift 操作 Hbase 的通用操作方法。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TBinaryProtocol</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">from</span> hbase <span class="keyword">import</span> Hbase</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to HBase Thrift server</span></span><br><span class="line">transport = TTransport.TBufferedTransport(TSocket.TSocket(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9090</span>))</span><br><span class="line">protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and open the client connection</span></span><br><span class="line">client = Hbase.Client(protocol)</span><br><span class="line">transport.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to Elasticsearch server</span></span><br><span class="line">es = Elasticsearch(<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">                   http_auth=(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>), port=<span class="string">&#x27;9200&#x27;</span>,</span><br><span class="line">                   timeout=<span class="number">30</span>, max_retries=<span class="number">10</span>, retry_on_timeout=<span class="literal">True</span></span><br><span class="line">                   )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_one</span>(<span class="params">index, doc_type, body, size=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询es获取第一条匹配的数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        index &#123;str&#125; -- 索引</span></span><br><span class="line"><span class="string">        doc_type &#123;str&#125; -- 类型</span></span><br><span class="line"><span class="string">        body &#123;dict&#125; -- 查询语句</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Keyword Arguments:</span></span><br><span class="line"><span class="string">        size &#123;int&#125; -- 返回数量 (default: &#123;1&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict -- 一条数据，没有结果返回 None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    res = es.search(index=index, doc_type=doc_type,</span><br><span class="line">                    scroll=<span class="string">&#x27;2m&#x27;</span>, body=body,</span><br><span class="line">                    size=size)</span><br><span class="line">    hits = res[<span class="string">&#x27;hits&#x27;</span>][<span class="string">&#x27;hits&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> hits[<span class="number">0</span>] <span class="keyword">if</span> hits <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_all</span>(<span class="params">index, doc_type, body, size=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询es获取所有匹配的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        index &#123;str&#125; -- 索引</span></span><br><span class="line"><span class="string">        doc_type &#123;str&#125; -- 类型</span></span><br><span class="line"><span class="string">        body &#123;dict&#125; -- 查询语句</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Keyword Arguments:</span></span><br><span class="line"><span class="string">        size &#123;int&#125; -- 返回数量 (default: &#123;100&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list -- 结果集</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    res = es.search(index=index, doc_type=doc_type,</span><br><span class="line">                    scroll=<span class="string">&#x27;2m&#x27;</span>, body=body,</span><br><span class="line">                    size=size)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="string">&#x27;hits&#x27;</span>][<span class="string">&#x27;hits&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_term</span>(<span class="params">field, value</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;term</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        field &#123;str&#125; -- 字段</span></span><br><span class="line"><span class="string">        value &#123;str&#125; -- 值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict -- 查询语句</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">                field: &#123;</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_terms</span>(<span class="params">field, values</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;terms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        field &#123;str&#125; -- 字段</span></span><br><span class="line"><span class="string">        values &#123;list&#125; -- 列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict -- 查询语句</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                field: values</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_row_with_columns</span>(<span class="params">table_name, rowkey, columns</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据 rowkey 从 hbase 获取一条数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        table_name &#123;str&#125; -- 表名</span></span><br><span class="line"><span class="string">        rowkey &#123;str&#125; -- rowkey</span></span><br><span class="line"><span class="string">        attributes &#123;list&#125; -- 属性列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict -- 一条数据，没有则返回None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    table_name = table_name.encode()</span><br><span class="line">    rowkey = rowkey.encode()</span><br><span class="line">    columns = [(<span class="string">&#x27;0:&#x27;</span> + c).encode() <span class="keyword">for</span> c <span class="keyword">in</span> columns]</span><br><span class="line">    res = client.getRowWithColumns(table_name, rowkey, columns, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    d = &#123;</span><br><span class="line">        k.decode().split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]: v.value.decode()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> res[<span class="number">0</span>].columns.items()</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="string">&#x27;rowkey&#x27;</span>] = res[<span class="number">0</span>].row.decode()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rows_with_columns</span>(<span class="params">table_name, rowkeys, columns</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据 rowkeys 从 hbase 获取所有匹配的数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        table_name &#123;str&#125; -- 表名</span></span><br><span class="line"><span class="string">        rowkeys &#123;list&#125; -- rowkey 列表</span></span><br><span class="line"><span class="string">        columns &#123;list&#125; -- 指定返回字段</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list -- 数据结果集</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data = []</span><br><span class="line">    table_name = table_name.encode()</span><br><span class="line">    rowkeys = [k.encode() <span class="keyword">for</span> k <span class="keyword">in</span> rowkeys]</span><br><span class="line">    columns = [(<span class="string">&#x27;0:&#x27;</span> + c).encode() <span class="keyword">for</span> c <span class="keyword">in</span> columns]</span><br><span class="line">    res = client.getRowsWithColumns(table_name, rowkeys, columns, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">        d = &#123;</span><br><span class="line">            k.decode().split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]: v.value.decode()</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> r.columns.items()</span><br><span class="line">        &#125;</span><br><span class="line">        d[<span class="string">&#x27;rowkey&#x27;</span>] = r.row.decode()</span><br><span class="line">        data.append(d)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql Tutorial</title>
    <url>/2021/03/14/postgresql-tutorial/</url>
    <content><![CDATA[<p>psql 数据库名  –连接数据库<br>select rolname,rolpassword from pg_authid;–查看用户名密码<br>select usename,passwd from pg_shadow;–查看用户名密码<br>select version();    – 查看版本<br>select current_database();–查看当前数据库<br>\l                    –查看所有数据库<br>\dt                    –查看表<br>\password username    –修改密码<br>\password           –设置密码。<br>?                  –查看psql命令列表。<br>\c [database_name]  –连接其他数据库，切换数据库。<br>\conninfo           –列出当前数据库和连接的信息。<br>\d                  –列出当前数据库的所有表格。<br>\d [table_name]     –列出某一张表格的结构。<br>\du                 –列出所有用户。<br>\e                  –打开文本编辑器。<br>help                –帮助<br>\h                  –查看SQL命令的解释，比如\h select。<br>\q                    –退出</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 脚本自动重载</title>
    <url>/2018/03/09/python-reloader/</url>
    <content><![CDATA[<p>Django 和 Flask 应用开启 debug 模式之后都能检测代码的变化然后自动重载，于是去找实现代码，发现 Flask 是用的 werkzeug 库里面的功能，而 Django 的不好用于自己写的脚本，因为和 Django 应用结合了。</p>
<a id="more"></a>

<!-- toc -->

<p>下面是 werkzeug 中的 _reloader 模块中的 run_with_reloader 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_reloader</span>(<span class="params">main_func, extra_files=<span class="literal">None</span>, interval=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      reloader_type=<span class="string">&#x27;auto&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run the given function in an independent python interpreter.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> signal</span><br><span class="line">    reloader = reloader_loops[reloader_type](extra_files, interval)</span><br><span class="line">    signal.signal(signal.SIGTERM, <span class="keyword">lambda</span> *args: sys.exit(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> os.environ.get(<span class="string">&#x27;WERKZEUG_RUN_MAIN&#x27;</span>) == <span class="string">&#x27;true&#x27;</span>:</span><br><span class="line">            t = threading.Thread(target=main_func, args=())</span><br><span class="line">            t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">            reloader.run()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.exit(reloader.restart_with_reloader())</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_with_reloader(main)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是执行函数不能传参，修改 run_with_reloader 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_reloader</span>(<span class="params">main_func, args=(<span class="params"></span>), kwargs=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      extra_files=<span class="literal">None</span>, interval=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      reloader_type=<span class="string">&#x27;auto&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run the given function in an independent python interpreter.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> signal</span><br><span class="line">    <span class="keyword">import</span> threading</span><br><span class="line">    <span class="keyword">from</span> werkzeug._reloader <span class="keyword">import</span> reloader_loops</span><br><span class="line">    reloader = reloader_loops[reloader_type](extra_files, interval)</span><br><span class="line">    signal.signal(signal.SIGTERM, <span class="keyword">lambda</span> *args: sys.exit(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> os.environ.get(<span class="string">&#x27;WERKZEUG_RUN_MAIN&#x27;</span>) == <span class="string">&#x27;true&#x27;</span>:</span><br><span class="line">            t = threading.Thread(target=main_func, args=args, kwargs=kwargs)</span><br><span class="line">            t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">            reloader.run()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.exit(reloader.restart_with_reloader())</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就能传参了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;hello, &quot;</span>, name, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run_with_reloader(main, args=(<span class="string">&#x27;foo&#x27;</span>, <span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>RDS for MySQL 备份文件恢复到自建数据库</title>
    <url>/2018/09/13/rds-for-mysql/</url>
    <content><![CDATA[<p>云数据库MySQL版使用开源软件Percona Xtrabackup对数据库进行备份，所以您可以使用该软件将云数据库MySQL的备份文件恢复到自建数据库中，本文将介绍详细的操作步骤。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="软件说明"><a href="#软件说明" class="headerlink" title="软件说明"></a>软件说明</h2><ol>
<li>MySQL 5.6.41</li>
<li>Percona XtraBackup 2.2.9</li>
<li><a href="http://oss.aliyuncs.com/aliyunecs/rds_backup_extract.sh?spm=a2c4g.11186623.2.6.3f4d5cf8Ze2ycZ&file=rds_backup_extract.sh">rds_backup_extract.sh</a></li>
</ol>
<h2 id="解压数据库备份文件"><a href="#解压数据库备份文件" class="headerlink" title="解压数据库备份文件"></a>解压数据库备份文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip -P密码 mysql_data_backup.tar.gz.zip</span><br><span class="line">bash rds_backup_extract -f mysql_data_backup.tar.gz -C /data/mysql/data</span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件-backup-my-cnf-如下"><a href="#修改配置文件-backup-my-cnf-如下" class="headerlink" title="修改配置文件 backup-my.cnf 如下"></a>修改配置文件 backup-my.cnf 如下</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This MySQL options file was generated by innobackupex.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The MySQL server</span></span><br><span class="line">[mysqld]</span><br><span class="line">innodb_checksum_algorithm=innodb</span><br><span class="line"><span class="comment"># innodb_log_checksum_algorithm=innodb</span></span><br><span class="line">innodb_data_file_path=ibdata1:200M:autoextend</span><br><span class="line">innodb_log_files_in_group=2</span><br><span class="line">innodb_log_file_size=1572864000</span><br><span class="line"><span class="comment"># innodb_fast_checksum=false</span></span><br><span class="line"><span class="comment"># innodb_page_size=16384</span></span><br><span class="line"><span class="comment"># innodb_log_block_size=512</span></span><br><span class="line">innodb_undo_directory=.</span><br><span class="line">innodb_undo_tablespaces=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rds_encrypt_data=false</span></span><br><span class="line"><span class="comment"># innodb_encrypt_algorithm=aes_128_ecb</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改文件属主"><a href="#修改文件属主" class="headerlink" title="修改文件属主"></a>修改文件属主</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /data/mysql/data</span><br></pre></td></tr></table></figure>

<h2 id="恢复数据文件"><a href="#恢复数据文件" class="headerlink" title="恢复数据文件"></a>恢复数据文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 400 /data/mysql/data/backup-my.cnf</span><br><span class="line">innobackupex --defaults-file=/data/mysql/data/backup-my.cnf --apply-log /data/mysql/data</span><br></pre></td></tr></table></figure>

<h2 id="启动数据库并登入验证"><a href="#启动数据库并登入验证" class="headerlink" title="启动数据库并登入验证"></a>启动数据库并登入验证</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqld_safe --defaults-file=/data/mysql/data/backup-my.cnf --user=mysql --datadir=/data/mysql/data --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure>

<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>恢复完成后，表 mysql.user 中是不包含 RDS 中创建的用户，需要新建，新建用户前请执行如下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.db <span class="keyword">where</span> <span class="keyword">user</span>&lt;&gt;<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> <span class="keyword">char_length</span>(<span class="keyword">user</span>)&gt;<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.tables_priv <span class="keyword">where</span> <span class="keyword">user</span>&lt;&gt;<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> <span class="keyword">char_length</span>(<span class="keyword">user</span>)&gt;<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://help.aliyun.com/knowledge_detail/41817.html">阿里云数据备份/恢复</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Screen 使用教程</title>
    <url>/2018/03/13/screen-usage/</url>
    <content><![CDATA[<p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="安装-screen"><a href="#安装-screen" class="headerlink" title="安装 screen"></a>安装 screen</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y screen</span><br></pre></td></tr></table></figure>

<h2 id="screen-常用命令"><a href="#screen-常用命令" class="headerlink" title="screen 常用命令"></a>screen 常用命令</h2><p>新建一个Screen Session</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure>

<p>将当前Screen Session放到后台</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CTRL + A + D</span><br></pre></td></tr></table></figure>

<p>唤起一个Screen Session</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure>

<p>分享一个Screen Session</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -x session_name</span><br></pre></td></tr></table></figure>

<p>终止一个Screen Session</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">or</span><br><span class="line">CTRL + D</span><br></pre></td></tr></table></figure>

<p>默认显示一屏的内容，要查看之前内容，如下操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Ctrl + A ESC</span><br></pre></td></tr></table></figure>

<p>列表所有的会话</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure>

<p>进入某个会话</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure>

<p>如果进不去，则</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -d session_name</span><br></pre></td></tr></table></figure>

<p>再</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure>

<p><code>ctrl + A + N</code> 切换窗口</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium 在 Ubuntu 服务器上的使用</title>
    <url>/2018/08/13/selenium-linux/</url>
    <content><![CDATA[<h2 id="安装-chrome"><a href="#安装-chrome" class="headerlink" title="安装 chrome"></a>安装 chrome</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&#x27;</span> | sudo tee /etc/apt/sources.list.d/google-chrome.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<!-- toc -->

<h2 id="安装-chromedriver"><a href="#安装-chromedriver" class="headerlink" title="安装 chromedriver"></a>安装 chromedriver</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -N https://chromedriver.storage.googleapis.com/2.41/chromedriver_linux64.zip</span><br><span class="line">unzip chromedriver_linux64.zip</span><br><span class="line">chmod +x chromedriver</span><br><span class="line">cp chromedriver /usr/bin/</span><br></pre></td></tr></table></figure>

<h2 id="安装-Xvfb"><a href="#安装-Xvfb" class="headerlink" title="安装 Xvfb"></a>安装 Xvfb</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install xvfb gtk2-engines-pixbuf</span><br><span class="line">sudo apt-get -y install xfonts-cyrillic xfonts-100dpi xfonts-75dpi xfonts-base xfonts-scalable</span><br><span class="line"><span class="comment"># 截图功能，可选</span></span><br><span class="line">sudo apt-get -y install imagemagick x11-apps</span><br><span class="line">Xvfb -ac :99 -screen 0 1280x1024x16 &amp; <span class="built_in">export</span> DISPLAY=:99</span><br></pre></td></tr></table></figure>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">driver = webdriver.Chrome(chrome_options=chrome_options,executable_path=<span class="string">&#x27;/usr/bin/chromedriver&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><code>ubuntu server 18.04</code> 虽然内置 <code>python3</code> 版本，但是没有 <code>pip</code><br>在 <code>/etc/apt/sources.list</code> 添加下列源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">deb http://cn.archive.ubuntu.com/ubuntu bionic main multiverse restricted universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu bionic-updates main multiverse restricted universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu bionic-security main multiverse restricted universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu bionic-proposed main multiverse restricted universe</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>

<h2 id="再用-pip-安装-selenium"><a href="#再用-pip-安装-selenium" class="headerlink" title="再用 pip 安装 selenium"></a>再用 pip 安装 selenium</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install selenium</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Session 、Cookie 和 JWT 详解</title>
    <url>/2021/04/17/session-cookie-jwt/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h2><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ol>
<a id="more"></a>

<h2 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h2><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h2 id="Session-和-Cookie-的区别"><a href="#Session-和-Cookie-的区别" class="headerlink" title="Session 和 Cookie 的区别"></a>Session 和 Cookie 的区别</h2><ol>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
<li>Cookie 是客户端技术，Session 是服务端技术，Session 借助 Cookie 存储 sessionid。</li>
<li>如果浏览器禁用 Cookie，可以使用 POST 提交 sessionid 或者使用 JWT 技术。</li>
</ol>
<h2 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ol>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ol>
<h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>解决方案：</p>
<ol>
<li>Nginx 代理</li>
<li>Jsonp 跨域</li>
<li>JWT 认证</li>
</ol>
<h2 id="JWT-数据结构"><a href="#JWT-数据结构" class="headerlink" title="JWT 数据结构"></a>JWT 数据结构</h2><h3 id="Encoded"><a href="#Encoded" class="headerlink" title="Encoded"></a>Encoded</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<h3 id="Decoded"><a href="#Decoded" class="headerlink" title="Decoded"></a>Decoded</h3><h4 id="Header-头部"><a href="#Header-头部" class="headerlink" title="Header (头部)"></a>Header (头部)</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kid&quot;</span>: <span class="string">&quot;Key ID&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cty&quot;</span>: <span class="string">&quot;Content Type&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;enc&quot;</span>: <span class="string">&quot;Encrypt Algorithm&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Payload-负载"><a href="#Payload-负载" class="headerlink" title="Payload (负载)"></a>Payload (负载)</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;issuer(签发人)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;exp&quot;</span>: <span class="string">&quot;expiration time(过期时间)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;subject(主题)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;aud&quot;</span>: <span class="string">&quot;audience(受众)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nbf&quot;</span>: <span class="string">&quot;Not Before(生效时间)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;iat&quot;</span>: <span class="string">&quot;Issued At(签发时间)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jti&quot;</span>: <span class="string">&quot;JWT ID(编号)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Signature-签名"><a href="#Signature-签名" class="headerlink" title="Signature (签名)"></a>Signature (签名)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line"></span><br><span class="line">your-256-bit-secret</span><br><span class="line"></span><br><span class="line">) secret base64 encoded</span><br></pre></td></tr></table></figure>

<p>JWT = Header.Payload.Signature</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>Session</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Instagram 的分片与 ID 设计</title>
    <url>/2020/06/03/sharding-ids-at-instagram/</url>
    <content><![CDATA[<!-- toc -->

<p>Instagram上有大量的数据，每分钟就有超过25张的图片和90个点赞。为了确保所有重要的数据都能被合理存储并且及时得被提取应用，我们对数据进行了分片（sharding）——也就是说，我们把数据放到多个桶（bucket）中，每个桶里都有一部分数据。</p>
<p>我们的应用服务器上运行的是Django， 后端数据库是PostgreSQL。对数据分片首先要决定是否要保留PostgreSQL作为主要的数据存储库，是否要采用其他的数据库。经过评估一些不同的数据库解决方案，我们最终确定最适合的方案是在PostgreSQL数据库集群上实现数据分片。</p>
<p>然而在把数据写到数据库之前，我们还要解决如何给数据（例如Instagram上发布的没一张图片）加上唯一标识符的问题。在单一数据库上的典型解法——使用数据库自带的自增主键功能——在当数据需要被同时插入到多个数据库时就不适用了。文章的下面就来讲讲我们是如何解决这个问题的</p>
<a id="more"></a>

<p>开始前，我们先列出系统所需要的所有重要的功能。</p>
<blockquote>
<ol>
<li>产生的数据ID需是可以按时间排序的。（比如对一列图片数据的ID进行排序，可以不需要提取太多图片本身的信息）</li>
<li>理想的ID是64位的。（这样索引更小，存储也更优，像Redis）</li>
<li>系统要尽量少的引用“可变动因素”——在很少工程师的情况下还可以扩张Instagram的很大一部分原因就是，我们相信简单易懂的方案。</li>
</ol>
</blockquote>
<h2 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h2><h3 id="由Web应用层生成ID"><a href="#由Web应用层生成ID" class="headerlink" title="由Web应用层生成ID"></a>由Web应用层生成ID</h3><p>这种方案将ID的生成完全交到应用层，而不是数据库。例如，MongoDB的ObjectId，就是12字节长并且在最前面加上时间戳进行编码。另一个流行的方案是使用UUIDs。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>每个应用线程独立生成ID，最小的降低ID生成的失败和竞争。</li>
<li>如果用时间戳作为ID的起始部分，那么ID可以按时间排序。</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>通常需要更多的存储空间（96位或者更多）来确保ID的合理唯一性。</li>
<li>一些UUID类型完全是随机的，无法排序。</li>
</ol>
</blockquote>
<h3 id="通过单独的服务产生ID"><a href="#通过单独的服务产生ID" class="headerlink" title="通过单独的服务产生ID"></a>通过单独的服务产生ID</h3><p>例如：Twitter的Snowflake，是一个Thrift服务，使用了Apache Zookeeper来协调各个结点并且产生64为的唯一ID。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>Snowflake的ID只有64位，是UUID的一半。</li>
<li>可以放时间戳到ID头，从而可以按时间排序。</li>
<li>分布式系统保证了系统结点不会挂掉。</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>增加了复杂性，而且引入了更多的“可变动因素”（如ZooKeeper, Snowflake服务器）到系统构架中。</p>
</blockquote>
<h3 id="数据库票据（DB-Ticket）服务器"><a href="#数据库票据（DB-Ticket）服务器" class="headerlink" title="数据库票据（DB Ticket）服务器"></a>数据库票据（DB Ticket）服务器</h3><p>利用数据库自带的自增特性来确保唯一性。Flicker采用这一方法，不过还用了两台ticket数据库（一个生成偶数，一个生成奇数）来避免单点失败。</p>
<p>优点：</p>
<blockquote>
<p>数据库好理解，带有易预测的可扩张功能。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>最终会出现数据写入的瓶颈（尽管Flicker称在高扩展下没有问题）。</li>
<li>需要管理多的两台服务器（或者EC2实例）。</li>
<li>如果单独使用数据库，会出现单点失效。如果使用多个数据库，则不能保证ID可以按时间排序。</li>
</ol>
</blockquote>
<p>在所有这些方案中，Twitter的snowflake是最接近的，但是生成ID所需的添加复杂性又和我们的目标冲突。我们的替换方案是采用概念上相近的方法，但是带到PostgreSQL内部实现。</p>
<h2 id="Instagram-的方案"><a href="#Instagram-的方案" class="headerlink" title="Instagram 的方案"></a>Instagram 的方案</h2><p>我们的分片系统是由上千个“逻辑”分片组成的，由代码映射到少量的物理分片。</p>
<p>通过这个方法，我们一开始用少数数据库实现，慢慢扩展到更多个数据库，只需要把部分逻辑分片从一台数据库转移到另一台数据库里，不需要重新把数据重新聚合。我们用到的PostgreSQL的schema的特性可以轻松的实现计划和管理。</p>
<p>Schema（不要和SQL单个表的schema搞混了）是PostgreSQL里的一个逻辑分组功能。每一个PostgreSQL数据库都有好几个schema，每一个schema都有一到多个表。表名在没个schema中都是唯一的，而不是每个数据库，默认情况下，PostgreSQL会把所有数据都放在一个叫“public”的schema中。</p>
<p>在我们的系统中每个“逻辑”分片都是一个PostgreSQL schema， 每个分片的表（比如照片的“点赞”功能）都存在每个schema中。</p>
<p>我们通过使用PL/PGSQL, PostgreSQL内部的编程语言，和PostgreSQL现有的自增功能来生成ID。</p>
<p>每个ID都由下面几个部分组成：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">41位的毫秒级时间（用于产生41年的ID）</span><br><span class="line">13位用来表示逻辑分片的ID</span><br><span class="line">10位的自增序列，模上1024， 意味着每个分片每毫秒可以产生1024个ID</span><br></pre></td></tr></table></figure>

<p>下面通过一个例子说明：比如说现在是2011年的九月九日，我们的纪元是从2011年的一月一号开始。从新纪元开始到此有1387263000毫秒，那么我们把这个数字左移41位来填满ID的头。</p>
<blockquote>
<p>id = 1387263000 &lt;&lt;(64 – 41)</p>
</blockquote>
<p>接下来， 我们拿来我们准备把这个数据插入的分片ID；如果我们用户ID是31341， 这个分片的ID是 31341%2000 → 1341。 我们接下来把下面13为填满：</p>
<blockquote>
<p>id |= 1341 &lt;&lt; (64-41-13)</p>
</blockquote>
<p>最后， 我们用所剩的自增序列（每个schema中每个表中这个序列都是唯一的）来填满的后面的位数。 假设这张表中已经有了5000个ID； 我们下一个数据就是5001，我们把它模上1024得到：</p>
<blockquote>
<p>id |= （5001%1024）</p>
</blockquote>
<p>我们就得到了我们的ID， 我们把这个id作为insert中的RETURNING返回给应用层。</p>
<p>下面是是实现以上过程的PL/PGSQL代码（这里用的schema是insta5）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> insta5.next_id(<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">bigint</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    our_epoch <span class="built_in">bigint</span> := <span class="number">1314220021721</span>;</span><br><span class="line">    seq_id bigint;</span><br><span class="line">    now_millis bigint;</span><br><span class="line">    shard_id int := 5;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">nextval</span>(<span class="string">&#x27;insta5.table_id_seq&#x27;</span>) %% <span class="number">1024</span> <span class="keyword">INTO</span> seq_id;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> clock_timestamp()) * <span class="number">1000</span>) <span class="keyword">INTO</span> now_millis;</span><br><span class="line">    result := (now_millis - our_epoch) &lt;&lt; 23;</span><br><span class="line">    result := result | (shard_id &lt;&lt; 10);</span><br><span class="line">    result := result | (seq_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br></pre></td></tr></table></figure>

<p>要生成表示执行下面的部分：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> insta5.our_table(</span><br><span class="line">    <span class="string">&quot;id&quot;</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> insta5.next_id(),</span><br><span class="line">    ... rest <span class="keyword">of</span> <span class="keyword">table</span> <span class="keyword">schema</span> ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>成了！我们得到了应用中唯一的主键（还有一个好处是，ID中包含了分片ID可以用来轻松映射）。我们已经把这个方法用在产品中，并且对结果感到非常满意。</p>
<p>本文来自：<a href="https://juejin.im/post/58de0676da2f60005fbec568">Instagram 的分片与 ID 设计</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学中的各种相似性度量及其实现</title>
    <url>/2021/06/10/similarity-measures-in-python/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="欧氏距离-Euclidean-Distance"><a href="#欧氏距离-Euclidean-Distance" class="headerlink" title="欧氏距离(Euclidean Distance)"></a>欧氏距离(Euclidean Distance)</h2><p>欧氏距离（也称欧几里得度量）指在 m 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 方法一</span></span><br><span class="line">    <span class="comment"># d = sqrt(sum(pow(a - b, 2) for a, b in zip(x, y)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法二</span></span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># d = np.linalg.norm(x - y, ord=2)</span></span><br><span class="line"></span><br><span class="line">    d = np.sqrt(np.<span class="built_in">sum</span>(np.square(x - y)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">euclidean_distance(x, y)  <span class="comment"># 11.180339887498949</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> euclidean</span><br><span class="line">euclidean(x, y)  <span class="comment"># 11.180339887498949</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="标准化欧氏距离-Standardized-Euclidean-Distance"><a href="#标准化欧氏距离-Standardized-Euclidean-Distance" class="headerlink" title="标准化欧氏距离(Standardized Euclidean Distance)"></a>标准化欧氏距离(Standardized Euclidean Distance)</h2><p>将各个分量都“标准化”到均值、方差相等所得出的距离。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> seuclidean</span><br><span class="line">seuclidean([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])  <span class="comment"># 4.4721359549995796</span></span><br><span class="line">seuclidean([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])  <span class="comment"># 3.3166247903553998</span></span><br><span class="line">seuclidean([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">10</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])  <span class="comment"># 3.1780497164141406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="马氏距离-Mahalanobis-Distance"><a href="#马氏距离-Mahalanobis-Distance" class="headerlink" title="马氏距离(Mahalanobis Distance)"></a>马氏距离(Mahalanobis Distance)</h2><p>马哈拉诺比斯距离是由印度统计学家马哈拉诺比斯提出的，表示数据的协方差距离。它是一种有效的计算两个未知样本集的相似度的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> mahalanobis</span><br><span class="line">iv = [[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>]]</span><br><span class="line">mahalanobis([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], iv)  <span class="comment"># 1.0</span></span><br><span class="line">mahalanobis([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], iv)  <span class="comment"># 1.0</span></span><br><span class="line">mahalanobis([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], iv)  <span class="comment"># 1.7320508075688772</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>编辑距离是针对二个字符串的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Levenshtein</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;I am very happy!&#x27;</span></span><br><span class="line"></span><br><span class="line">Levenshtein.distance(s1, s2)  <span class="comment"># 14</span></span><br><span class="line">Levenshtein.ratio(s1, s2)  <span class="comment"># 0.20689655172413793</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="曼哈顿距离-Manhattan-Distance"><a href="#曼哈顿距离-Manhattan-Distance" class="headerlink" title="曼哈顿距离(Manhattan Distance)"></a>曼哈顿距离(Manhattan Distance)</h2><p>在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manhattan_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 方法一</span></span><br><span class="line">    <span class="comment"># d = sum(abs(a - b) for a, b in zip(x, y))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法二</span></span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># d = np.linalg.norm(x - y, ord=1)</span></span><br><span class="line"></span><br><span class="line">    d = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(x - y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">manhattan_distance(x, y)  <span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cityblock</span><br><span class="line">cityblock(x, y)  <span class="comment"># 25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="切比雪夫距离-Chebyshev-Distance"><a href="#切比雪夫距离-Chebyshev-Distance" class="headerlink" title="切比雪夫距离(Chebyshev Distance)"></a>切比雪夫距离(Chebyshev Distance)</h2><p>数学上，切比雪夫距离或是L∞度量是向量空间中的一种度量，二个点之间的距离定义为其各座标数值差的最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chebyshev_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># d = np.linalg.norm(x - y, ord=np.inf)</span></span><br><span class="line"></span><br><span class="line">    d = np.<span class="built_in">abs</span>(x - y).<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">chebyshev_distance(x, y)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> chebyshev</span><br><span class="line">chebyshev(x, y)  <span class="comment"># 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="闵可夫斯基距离-Minkowski-Distance"><a href="#闵可夫斯基距离-Minkowski-Distance" class="headerlink" title="闵可夫斯基距离(Minkowski Distance)"></a>闵可夫斯基距离(Minkowski Distance)</h2><p>明氏距离又叫做明可夫斯基距离，是欧氏空间中的一种测度，被看做是欧氏距离和曼哈顿距离的一种推广。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_root</span>(<span class="params">value, n_root</span>):</span></span><br><span class="line">    root_value = <span class="number">1</span> / <span class="built_in">float</span>(n_root)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(Decimal(value)**Decimal(root_value), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minkowski_distance</span>(<span class="params">x, y, p_value</span>):</span></span><br><span class="line">    d = nth_root(<span class="built_in">sum</span>(<span class="built_in">pow</span>(<span class="built_in">abs</span>(a - b), p_value) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(x, y)), p_value)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">minkowski_distance(x, y, <span class="number">1</span>)  <span class="comment"># Decimal(&#x27;25.000&#x27;)</span></span><br><span class="line">minkowski_distance(x, y, <span class="number">2</span>)  <span class="comment"># Decimal(&#x27;11.180&#x27;)</span></span><br><span class="line">minkowski_distance(x, y, <span class="number">3</span>)  <span class="comment"># Decimal(&#x27;8.550&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minkowski_distance</span>(<span class="params">x, y, <span class="built_in">ord</span>=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># ord = 1 一范数</span></span><br><span class="line">    <span class="comment"># ord = 2 二范数</span></span><br><span class="line">    <span class="comment"># ord = np.inf 无穷范数</span></span><br><span class="line">    d = np.linalg.norm(x - y, <span class="built_in">ord</span>=<span class="built_in">ord</span>)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> minkowski</span><br><span class="line">minkowski(x, y, p=<span class="number">1</span>)  <span class="comment"># 25.0</span></span><br><span class="line">minkowski(x, y, p=<span class="number">2</span>)  <span class="comment"># 11.180339887498949</span></span><br><span class="line">minkowski(x, y, p=<span class="number">3</span>)  <span class="comment"># 8.549879733383484</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="汉明距离-Hamming-Distance"><a href="#汉明距离-Hamming-Distance" class="headerlink" title="汉明距离(Hamming Distance)"></a>汉明距离(Hamming Distance)</h2><p>在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法一</span></span><br><span class="line">    <span class="comment"># d = len(np.nonzero(x - y)[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法二</span></span><br><span class="line">    d = np.shape(np.nonzero(x - y)[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">hamming_distance(x, y)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> hamming</span><br><span class="line">hamming(x, y)  <span class="comment"># 1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="余弦相似度-Cosine-Similarity"><a href="#余弦相似度-Cosine-Similarity" class="headerlink" title="余弦相似度(Cosine Similarity)"></a>余弦相似度(Cosine Similarity)</h2><p>余弦相似性通过测量两个向量的夹角的余弦值来度量它们之间的相似性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cosine_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    d = np.dot(x, y) / (np.linalg.norm(x) * np.linalg.norm(y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">cosine_distance(x, y)  <span class="comment"># 0.9649505047327671</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line">x, y = np.array(x), np.array(y)</span><br><span class="line">cosine_similarity(x.reshape(<span class="number">1</span>, -<span class="number">1</span>), y.reshape(<span class="number">1</span>, -<span class="number">1</span>))  <span class="comment"># array([[0.9649505]])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="皮尔森相关系数-Pearson-Correlation-Coefficient"><a href="#皮尔森相关系数-Pearson-Correlation-Coefficient" class="headerlink" title="皮尔森相关系数(Pearson Correlation Coefficient)"></a>皮尔森相关系数(Pearson Correlation Coefficient)</h2><p>用于度量两个变量X和Y之间的相关程度，其值介于-1与1之间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">2.5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">coe, pv = pearsonr(x, y)  <span class="comment"># coe = -0.7426106572325057, pv = 0.1505558088534455</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="杰卡德相似系数-Jaccard-Similarity-Coefficient-及杰卡德距离-Jaccard-Distance"><a href="#杰卡德相似系数-Jaccard-Similarity-Coefficient-及杰卡德距离-Jaccard-Distance" class="headerlink" title="杰卡德相似系数(Jaccard Similarity Coefficient)及杰卡德距离(Jaccard Distance)"></a>杰卡德相似系数(Jaccard Similarity Coefficient)及杰卡德距离(Jaccard Distance)</h2><p>Jaccard 相似指数用来度量两个集合之间的相似性，它被定义为两个集合交集的元素个数除以并集的元素个数。</p>
<p>Jaccard 距离用来度量两个集合之间的差异性，它是 Jaccard 的相似系数的补集，被定义为 1 减去 Jaccard 相似系数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> jaccard</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">jaccard(x, y)  <span class="comment"># 0.75</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqlalchemy 基本用法</title>
    <url>/2019/05/12/sqlalchemy-usage/</url>
    <content><![CDATA[<p>Sqlalchemy 基本用法</p>
<a id="more"></a>

<!-- toc -->

<h2 id="通用导入"><a href="#通用导入" class="headerlink" title="通用导入"></a>通用导入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> scoped_session, sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, ForeignKey, Boolean</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///test.db&#x27;</span>, echo=<span class="literal">True</span>)</span><br><span class="line">Base = declarative_base()</span><br><span class="line">db_session = scoped_session(sessionmaker(bind=engine))</span><br><span class="line">Base.query = db_session.query_property()</span><br></pre></td></tr></table></figure>

<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    child_id = Column(Integer, ForeignKey(<span class="string">&#x27;child.id&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    parent = relationship(<span class="string">&#x27;Parent&#x27;</span>, backref=<span class="string">&#x27;child&#x27;</span>, uselist=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the one side</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    <span class="comment"># children = relationship(&quot;Child&quot;, back_populates=&quot;parent&quot;)</span></span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>, backref=<span class="string">&quot;parent&quot;</span>, lazy=<span class="string">&quot;dynamic&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the many side</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br><span class="line">    <span class="comment"># parent = relationship(&quot;Parent&quot;, back_populates=&quot;children&quot;)</span></span><br><span class="line">    <span class="comment"># parent = relationship(&quot;Parent&quot;, backref=&quot;children&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the many side</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    child_id = Column(Integer, ForeignKey(<span class="string">&#x27;child.id&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the one side</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    parents = relationship(<span class="string">&#x27;Parent&#x27;</span>, backref=<span class="string">&#x27;child&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;department&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    employees = relationship(</span><br><span class="line">        <span class="string">&#x27;Employee&#x27;</span>,</span><br><span class="line">        secondary=<span class="string">&#x27;department_employee_link&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;employee&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    hired_on = Column(</span><br><span class="line">        DateTime,</span><br><span class="line">        default=func.now())</span><br><span class="line">    departments = relationship(</span><br><span class="line">        <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">        secondary=<span class="string">&#x27;department_employee_link&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepartmentEmployeeLink</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;department_employee_link&#x27;</span></span><br><span class="line">    department_id = Column(Integer, ForeignKey(<span class="string">&#x27;department.id&#x27;</span>),</span><br><span class="line">                           primary_key=<span class="literal">True</span>)</span><br><span class="line">    department = relationship(<span class="string">&#x27;Department&#x27;</span>)</span><br><span class="line">    employee_id = Column(Integer, ForeignKey(<span class="string">&#x27;employee.id&#x27;</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">    employee = relationship(<span class="string">&#x27;Employee&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自身多对多"><a href="#自身多对多" class="headerlink" title="自身多对多"></a>自身多对多</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follow</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;me_follow_you&#x27;</span></span><br><span class="line"></span><br><span class="line">    me_id = Column(Integer, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">    me = relationship(<span class="string">&#x27;User&#x27;</span>, foreign_keys=[me_id])</span><br><span class="line">    you_id = Column(Integer, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">    you = relationship(<span class="string">&#x27;User&#x27;</span>, foreign_keys=[you_id])</span><br><span class="line">    created = Column(DateTime(timezone=<span class="literal">True</span>), default=datetime.utcnow)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stars=我关注的人 fans=我的粉丝</span></span><br><span class="line">    stars = relationship(<span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">                         secondary=<span class="string">&#x27;me_follow_you&#x27;</span>,</span><br><span class="line">                         primaryjoin=<span class="string">&#x27;User.id==Follow.me_id&#x27;</span>,</span><br><span class="line">                         secondaryjoin=<span class="string">&#x27;User.id==Follow.you_id&#x27;</span>,</span><br><span class="line">                         backref=backref(<span class="string">&#x27;fans&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>),</span><br><span class="line">                         lazy=<span class="string">&#x27;dynamic&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自身一对一"><a href="#自身一对一" class="headerlink" title="自身一对一"></a>自身一对一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;node.id&#x27;</span>))</span><br><span class="line">    data = Column(String(<span class="number">50</span>))</span><br><span class="line">    parent = relationship(<span class="string">&quot;Node&quot;</span>, remote_side=[<span class="built_in">id</span>])</span><br></pre></td></tr></table></figure>

<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_db</span>():</span></span><br><span class="line">    <span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">    engine = create_engine(<span class="string">&#x27;sqlite:///test.db&#x27;</span>, echo=<span class="literal">True</span>)</span><br><span class="line">    Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure>

<h2 id="backref-和-back-populates"><a href="#backref-和-back-populates" class="headerlink" title="backref 和 back_populates"></a>backref 和 back_populates</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Parent 下添加 `children = relationship(<span class="string">&quot;Child&quot;</span>, back_populates=<span class="string">&quot;parent&quot;</span>)`</span><br><span class="line"></span><br><span class="line">创建p1 = Parent()和c1 = Child()失败，原因是One <span class="keyword">or</span> more mappers failed to initialize，即back_populates必须在关系两端同时指定</span><br><span class="line"></span><br><span class="line">Parent下添加 `children = relationship(<span class="string">&quot;Child&quot;</span>, back_populates=<span class="string">&quot;parent&quot;</span>)`</span><br><span class="line">Child下添加 `parent = relationship(<span class="string">&quot;Parent&quot;</span>, back_populates=<span class="string">&quot;children&quot;</span>)`</span><br><span class="line"></span><br><span class="line">Parent Attribute:</span><br><span class="line">Parent.children Parent.<span class="built_in">id</span> Parent.metadata Parent.name Parent.query</span><br><span class="line"></span><br><span class="line">Child Attribute:</span><br><span class="line">Child.<span class="built_in">id</span> Child.metadata Child.name Child.parent Child.parent_id Child.query</span><br><span class="line"></span><br><span class="line">p1 = Parent()</span><br><span class="line">c1 = Child()</span><br><span class="line">c1.parent = p1 <span class="keyword">or</span> p1.children.append(c1)</span><br><span class="line"></span><br><span class="line">Parent下添加 `children = relationship(<span class="string">&quot;Child&quot;</span>, backref=<span class="string">&quot;parent&quot;</span>)`</span><br><span class="line"></span><br><span class="line">Parent Attribute:</span><br><span class="line">Parent.children Parent.<span class="built_in">id</span> Parent.metadata Parent.name Parent.query</span><br><span class="line"></span><br><span class="line">Child Attribute:</span><br><span class="line">Child.<span class="built_in">id</span> Child.metadata Child.name Child.parent_id Child.query</span><br><span class="line"></span><br><span class="line">p1 = Parent()</span><br><span class="line">c1 = Child()</span><br><span class="line">c1.parent = p1 <span class="keyword">or</span> p1.children.append(c1)</span><br><span class="line"></span><br><span class="line">可以看出使用backref时，实例化c1时会自动在c1对象上添加parent属性</span><br><span class="line"></span><br><span class="line">此后再检查:</span><br><span class="line"><span class="built_in">hasattr</span>(Child, <span class="string">&#x27;parent&#x27;</span>) // <span class="literal">True</span></span><br><span class="line"><span class="built_in">hasattr</span>(c1, <span class="string">&#x27;parent&#x27;</span>) // <span class="literal">True</span></span><br><span class="line"><span class="built_in">hasattr</span>(Parent, <span class="string">&#x27;children&#x27;</span>) // <span class="literal">True</span></span><br><span class="line"><span class="built_in">hasattr</span>(p1, <span class="string">&#x27;children&#x27;</span>) // <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">Child 下添加 `parent = relationship(<span class="string">&quot;Parent&quot;</span>, backref=<span class="string">&quot;children&quot;</span>)` 情况和 <span class="number">3</span> 相同</span><br><span class="line">Parent下添加 `children = relationship(<span class="string">&quot;Child&quot;</span>, backref=<span class="string">&quot;parent&quot;</span>)`</span><br><span class="line">Child下添加 `parent = relationship(<span class="string">&quot;Parent&quot;</span>, backref=<span class="string">&quot;children&quot;</span>)`</span><br><span class="line"></span><br><span class="line">创建p1 = Parent()和c1 = Child()失败，原因是One <span class="keyword">or</span> more mappers failed to initialize</span><br><span class="line">因此两者只能使用其中之一</span><br><span class="line"></span><br><span class="line">lazy 指定如何加载相关记录，默认值是<span class="string">&quot;select&quot;</span></span><br><span class="line">    select 首次访问时按需加载</span><br><span class="line">    immediate 源对象加载后就加载</span><br><span class="line">    joined 加载记录,但使用联结</span><br><span class="line">    subquery 立即加载,但使用子查询</span><br><span class="line">    noload 永不加载</span><br><span class="line">    dynamic 不加载记录,但提供加载记录的查询</span><br><span class="line"></span><br><span class="line">lazy = <span class="string">&quot;dynamic&quot;</span>只能用于collections，不立即查询出结果集，而是提供一系列结果集的方法，可以基于结果集再次进行更精确的查找</span><br></pre></td></tr></table></figure>

<h2 id="default-和-server-default"><a href="#default-和-server-default" class="headerlink" title="default 和 server_default"></a>default 和 server_default</h2><ol>
<li>default 是在 ORM 层设置默认值，server_default 是在表结构上设置默认值</li>
<li>onupdate 在 ORM 层生效，server_onupdate 在数据库生效，在 MySQL 上 ON UPDATE 是MySQL在背后创建了 trigger，而在 PostgreSQL 上你必须手动创建 trigger</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func, sql, text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;records</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    id = Column(Integer, primary_key=True)</span></span><br><span class="line"><span class="string">    name = Column(String(64), server_default=text(&#x27;</span>name<span class="string">&#x27;))</span></span><br><span class="line"><span class="string">    created = Column(DateTime(timezone=True), default=datetime.utcnow)</span></span><br><span class="line"><span class="string">    # created = Column(DateTime(timezone=True), server_default=func.now())</span></span><br><span class="line"><span class="string">    # created = Column(DateTime(timezone=True), server_default=func.current_timestamp())</span></span><br><span class="line"><span class="string">    updated = Column(DateTime(timezone=True), server_default=func.current_timestamp(), onupdate=func.current_timestamp())</span></span><br><span class="line"><span class="string">    deleted = Column(Boolean, default=False)</span></span><br><span class="line"><span class="string">    # deleted = Column(Boolean, server_default=sql.expression.false())</span></span><br></pre></td></tr></table></figure>

<h2 id="为flask-sqlalchemy扩展BaseQuery方法"><a href="#为flask-sqlalchemy扩展BaseQuery方法" class="headerlink" title="为flask_sqlalchemy扩展BaseQuery方法"></a>为flask_sqlalchemy扩展BaseQuery方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy, BaseQuery</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomQuery</span>(<span class="params">BaseQuery</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_all</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.with_entities(func.count()).scalar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(query_class=CustomQuery)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux 使用教程</title>
    <url>/2020/05/29/tmux-tutorial/</url>
    <content><![CDATA[<p>Tmux 是一个终端复用工具，和 screen 一样，screen 相对简单好使，tmux 更高级。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">yum install -y tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># MacOS</span></span><br><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<!-- toc -->

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建无名称会话</span></span><br><span class="line">tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建会话</span></span><br><span class="line">tmux new -s demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂起会话</span></span><br><span class="line">tmux detach</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认进入第一个会话</span></span><br><span class="line">tmux a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入名为demo的会话</span></span><br><span class="line">tmux a -t demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭demo会话</span></span><br><span class="line">tmux kill-session -t demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务器</span></span><br><span class="line">tmux kill-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看会话</span></span><br><span class="line">tmux list-session</span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换会话</span></span><br><span class="line">tmux switch -t 0  <span class="comment"># 使用会话编号</span></span><br><span class="line">tmux switch -t demo  <span class="comment"># 使用会话名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名会话</span></span><br><span class="line">tmux rename-session -t demo new-demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h2><table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>?</td>
<td>显示快捷键帮助文档</td>
</tr>
<tr>
<td>prefix</td>
<td>d</td>
<td>断开当前会话</td>
</tr>
<tr>
<td>prefix</td>
<td>D</td>
<td>选择要断开的会话</td>
</tr>
<tr>
<td>prefix</td>
<td>Ctrl+z</td>
<td>挂起当前会话</td>
</tr>
<tr>
<td>prefix</td>
<td>r</td>
<td>强制重载当前会话</td>
</tr>
<tr>
<td>prefix</td>
<td>s</td>
<td>显示会话列表用于选择并切换</td>
</tr>
<tr>
<td>prefix</td>
<td>:</td>
<td>进入命令行模式</td>
</tr>
<tr>
<td>prefix</td>
<td>[</td>
<td>进入复制模式，按q退出</td>
</tr>
<tr>
<td>prefix</td>
<td>]</td>
<td>粘贴复制模式中复制的文本</td>
</tr>
<tr>
<td>prefix</td>
<td>~</td>
<td>列出提示信息缓存</td>
</tr>
</tbody></table>
<h2 id="窗口指令"><a href="#窗口指令" class="headerlink" title="窗口指令"></a>窗口指令</h2><table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>c</td>
<td>新建窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>&amp;</td>
<td>关闭当前窗口（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td>prefix</td>
<td>0-9</td>
<td>切换到指定窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>p</td>
<td>切换到上一窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>n</td>
<td>切换到下一窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>w</td>
<td>打开窗口列表，用于且切换窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>,</td>
<td>重命名当前窗口</td>
</tr>
<tr>
<td>prefix</td>
<td>.</td>
<td>修改当前窗口编号（适用于窗口重新排序）</td>
</tr>
<tr>
<td>prefix</td>
<td>f</td>
<td>快速定位到窗口（输入关键字匹配窗口名称）</td>
</tr>
</tbody></table>
<h2 id="面板指令"><a href="#面板指令" class="headerlink" title="面板指令"></a>面板指令</h2><table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>“</td>
<td>当前面板上下一分为二，下侧新建面板</td>
</tr>
<tr>
<td>prefix</td>
<td>%</td>
<td>当前面板左右一分为二，右侧新建面板</td>
</tr>
<tr>
<td>prefix</td>
<td>x</td>
<td>关闭当前面板（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td>prefix</td>
<td>z</td>
<td>最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td>
</tr>
<tr>
<td>prefix</td>
<td>!</td>
<td>将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td>
</tr>
<tr>
<td>prefix</td>
<td>;</td>
<td>切换到最后一次使用的面板</td>
</tr>
<tr>
<td>prefix</td>
<td>q</td>
<td>显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td>
</tr>
<tr>
<td>prefix</td>
<td>{</td>
<td>向前置换当前面板</td>
</tr>
<tr>
<td>prefix</td>
<td>}</td>
<td>向后置换当前面板</td>
</tr>
<tr>
<td>prefix</td>
<td>Ctrl+o</td>
<td>顺时针旋转当前窗口中的所有面板</td>
</tr>
<tr>
<td>prefix</td>
<td>方向键</td>
<td>移动光标切换面板</td>
</tr>
<tr>
<td>prefix</td>
<td>o</td>
<td>选择下一面板</td>
</tr>
<tr>
<td>prefix</td>
<td>空格键</td>
<td>在自带的面板布局中循环切换</td>
</tr>
<tr>
<td>prefix</td>
<td>Alt+方向键</td>
<td>以5个单元格为单位调整当前面板边缘</td>
</tr>
<tr>
<td>prefix</td>
<td>Ctrl+方向键</td>
<td>以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td>
</tr>
<tr>
<td>prefix</td>
<td>t</td>
<td>显示时钟</td>
</tr>
</tbody></table>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>编辑 ~/.tmux.conf 添加如下内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># prefix configuration</span><br><span class="line">set -g prefix C-a</span><br><span class="line">unbind C-b</span><br><span class="line">bind C-a send-prefix</span><br><span class="line"></span><br><span class="line"># split window</span><br><span class="line">unbind &#x27;&quot;&#x27;</span><br><span class="line">bind - split-window -v -c &#x27;#&#123;pane_current_path&#125;&#x27;</span><br><span class="line">unbind %</span><br><span class="line">bind = split-window -h -c &#x27;#&#123;pane_current_path&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># mouse on</span><br><span class="line">set-option -g mouse on</span><br><span class="line"></span><br><span class="line"># pane navigation</span><br><span class="line">bind -r k select-pane -U</span><br><span class="line">bind -r j select-pane -D</span><br><span class="line">bind -r h select-pane -L</span><br><span class="line">bind -r l select-pane -R</span><br><span class="line"></span><br><span class="line"># pane resizing</span><br><span class="line">bind -r ^k resize-pane -U 2</span><br><span class="line">bind -r ^j resize-pane -D 2</span><br><span class="line">bind -r ^h resize-pane -L 2</span><br><span class="line">bind -r ^l resize-pane -R 2</span><br><span class="line"></span><br><span class="line"># reload configuration</span><br><span class="line">bind r source-file ~/.tmux.conf \; display &#x27;~/.tmux.conf sourced&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/01/15/treenode/</url>
    <content><![CDATA[<p><code>LeetCode</code> 二叉树题解汇总</p>
<a id="more"></a>

<!-- toc -->

<h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_same_tree</span>(<span class="params">p, q</span>):</span></span><br><span class="line">      <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">not</span> q</span><br><span class="line">      <span class="keyword">if</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">not</span> p</span><br><span class="line">      <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> is_same_tree(p.left, q.left) <span class="keyword">and</span> is_same_tree(p.right, q.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对称的树"><a href="#对称的树" class="headerlink" title="对称的树"></a>对称的树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetric</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> symmetric(root.left, root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symmetric</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> l2</span><br><span class="line">    <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> l1</span><br><span class="line">    <span class="keyword">return</span> l1.val == l2.val <span class="keyword">and</span> symmetric(l1.left, l2.right) <span class="keyword">and</span> symmetric(l1.right, l2.left)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>给定一个二叉树，返回其按层次遍历的节点值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">node, level, res</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level:</span><br><span class="line">        res.append([])</span><br><span class="line">    res[level - <span class="number">1</span>].append(node.val)</span><br><span class="line">    add(node.left, level + <span class="number">1</span>, res)</span><br><span class="line">    add(node.right, level + <span class="number">1</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    add(root, <span class="number">1</span>, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_depth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">map</span>(max_depth, (root.left, root.right))) <span class="keyword">if</span> root <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_depth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min_depth(root.right)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min_depth(root.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">map</span>(min_depth, (root.left, root.right)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更简洁的写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_depth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    depth_under_root = <span class="built_in">map</span>(min_depth, (root.left, root.right))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (<span class="built_in">min</span>(depth_under_root) <span class="keyword">or</span> <span class="built_in">max</span>(depth_under_root))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将有序数组转化为二叉树"><a href="#将有序数组转化为二叉树" class="headerlink" title="将有序数组转化为二叉树"></a>将有序数组转化为二叉树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sorted_array_to_balanced_tree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[mid])</span><br><span class="line">    root.left = sorted_array_to_balanced_tree(nums[:mid])</span><br><span class="line">    root.right = sorted_array_to_balanced_tree(nums[mid + <span class="number">1</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hight</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">map</span>(hight, (node.left, node.right)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_balanced</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(hight(root.left) - hight(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> is_balanced(root.left) <span class="keyword">and</span> is_balanced(root.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_path_sum</span>(<span class="params">root, sums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">or</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> has_path_sum(root.left, sums - root.val) <span class="keyword">or</span> has_path_sum(root.right, sums - root.val)</span><br><span class="line">    <span class="keyword">return</span> sums == root.val</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Python 的元类</title>
    <url>/2021/07/09/understand-python-metaclass/</url>
    <content><![CDATA[<p>元类是一个深奥的OOP概念，几乎隐藏在所有Python代码之后。无论您是否知道，都在使用它们。在大多数情况下，您无需意识到这一点。大多数Python程序员很少（即使有的话）也不必考虑元类。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_line = <span class="keyword">lambda</span> x: print(<span class="string">&#x27;*&#x27;</span> * x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python中类的概念借鉴于Smalltalk，在大多数语言中类就是一段用于生成一个对象的代码。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myobj = ObjectCreator()</span><br><span class="line">print(myobj)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是类在python中也是对象，每当你用class关键字申明一个类时，python就会执行它并创建一个对象。比如上面的代码，python在内存中创建了一个名为ObjectCreator的对象。</span></span><br><span class="line"><span class="comment"># 类对象本身也有创建对象（实例）的能力，这就是为什么它叫做类。</span></span><br><span class="line"><span class="comment"># 但是同时，类本身也是个对象，因此你可以把它赋给一个变量，拷贝，添加属性或者作为函数的参数。</span></span><br><span class="line">print(ObjectCreator) <span class="comment"># 你可以打印它，因为它是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">obj</span>):</span></span><br><span class="line">    print(obj)</span><br><span class="line">echo(ObjectCreator) <span class="comment"># 你可以把类作为参数传递</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line">ObjectCreator.new_attribute = <span class="string">&#x27;foo&#x27;</span> <span class="comment"># 你可以给它添加属性</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line">print(ObjectCreator.new_attribute)</span><br><span class="line">ObjectCreatorMirror = ObjectCreator <span class="comment"># 你可以把它赋给一个变量</span></span><br><span class="line">print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">print(ObjectCreatorMirror())</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为类也是一个对象，你可以像任何其他对象一样动态地创建它。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Foo <span class="comment"># 注意这里返回类，而不是实例</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Bar</span><br><span class="line"></span><br><span class="line">MyClass = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">print(MyClass) <span class="comment"># 函数返回的是一个类，而不是实例</span></span><br><span class="line">print(MyClass()) <span class="comment"># 你可以用这个类创建一个实例对象</span></span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但这还不够动态，因为你还得自己手动编写整个类的代码。既然类是对象，那么肯定有什么东西来生成它，每当你使用class关键字时，python就自动创建这个对象，但是python也给你自己动手的机会，还记得type这个古老的函数吗？它返回这个对象的类型。</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="number">1</span>))</span><br><span class="line">print(<span class="built_in">type</span>(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">print(<span class="built_in">type</span>(ObjectCreator))</span><br><span class="line">print(<span class="built_in">type</span>(ObjectCreator()))</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># type还有另一种完全不同的能力，它也能够动态地创建类，type接受一个类地描述作为参数然后返回一个类。</span></span><br><span class="line"><span class="comment"># 比如下面这个类可以这样手动创建</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class MyShinyClass(object):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type(name of the class,</span></span><br><span class="line"><span class="string">     tuple of the parent class (for inheritance, can be empty),</span></span><br><span class="line"><span class="string">     dictionary containing attributes names and values)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">MyShinyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyShinyClass&#x27;</span>, (), &#123;&#125;) <span class="comment"># 返回类对象</span></span><br><span class="line">print(MyShinyClass)</span><br><span class="line">print(MyShinyClass())</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来个例子</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Foo(object):</span></span><br><span class="line"><span class="string">    bar = True</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 可以写成</span></span><br><span class="line">Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"><span class="comment"># 然后我们像正常的类一样来使用它</span></span><br><span class="line">print(Foo)</span><br><span class="line">print(Foo.bar)</span><br><span class="line">f = Foo()</span><br><span class="line">print(f)</span><br><span class="line">print(f.bar)</span><br><span class="line"><span class="comment"># 我们还可以继承它</span></span><br><span class="line">FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;&#125;)</span><br><span class="line">print(FooChild)</span><br><span class="line">print(FooChild.bar) <span class="comment"># bar属性从Foo继承</span></span><br><span class="line"><span class="comment"># 在类中添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(self.bar)</span><br><span class="line"></span><br><span class="line">FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class="line">print(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line">print(<span class="built_in">hasattr</span>(FooChild, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line">my_foo = FooChild()</span><br><span class="line">my_foo.echo_bar()</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，type就是元类，用于创建所有类的元类，是python内建的元类，你也可以创建自己的元类</span></span><br><span class="line"><span class="comment"># 不信你看</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line">name = <span class="string">&#x27;fuyun&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line">print(age.__class__)</span><br><span class="line">print(age.__class__.__class__)</span><br><span class="line">print(name.__class__)</span><br><span class="line">print(name.__class__.__class__)</span><br><span class="line">print(foo.__class__)</span><br><span class="line">print(foo.__class__.__class__)</span><br><span class="line">print(Bar().__class__)</span><br><span class="line">print(Bar().__class__.__class__)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你创建一个类的时候，你可以添加__metaclass__属性，python将会在类定义中寻找__metaclass__，如果找到了就用它来创建类，如果没有就用type来创建类。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Foo(Bar):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 上面的代码python将会这样做，首先python会在Foo中找__metaclass__，找到就用它来创建类对象，如果没有就会从父类Bar中找__metaclass__，如果在任何父类中都找不到__metaclass__，就会在模块层次中找__metaclass__，都找不到那就用内置的type来创建类对象。</span></span><br><span class="line"><span class="comment"># 因此我们可以在__metaclass__中写一些用于创建类的代码，什么可以创建类？那就是type，或者任何使用到type或子类化type的东西。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元类的主要目的就是在创建类的时候能够自动改变类。</span></span><br><span class="line"><span class="comment"># 举个例子，编写一个元类，让类的属性都改成大写形式。</span></span><br><span class="line"><span class="comment"># 元类会自动将你通常传给&#x27;type&#x27;的参数作为自己的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回一个将属性列表变为大写字母的类对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选取所有不以&#x27;__&#x27;开头的属性，并把它们变成大写</span></span><br><span class="line">    uppercase_attr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">            uppercase_attr[name.upper()] = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用type创建类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=upper_attr</span>):</span></span><br><span class="line">    <span class="comment"># __metaclass__ = upper_attr 这是python2的写法</span></span><br><span class="line">    bar = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">print(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line">print(Foo().BAR)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># type实际上是一个类，就像str和int一样，所以，你可以从type继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line">    <span class="comment"># __new__是用来创建对象并返回它的方法</span></span><br><span class="line">    <span class="comment"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line">    <span class="comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class="line">    <span class="comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line">    <span class="comment"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line">    <span class="comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr</span>):</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是这不是真正的面向对象(OOP)。我们直接调用了type，而且我们没有改写父类的new方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr</span>):</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重用 type.__new__ 方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(upperattr_metaclass, future_class_name,</span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br><span class="line">        <span class="comment"># 这里有个额外的参数upperattr_metaclass，类似于self，类方法的第一个参数总是代表当前实例。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了便于理解上面的代码名字编的太长，实际产品中的代码应该是这样的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, dct</span>):</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, clsname, bases, uppercase_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还可以使用super方法使代码变得更清晰一点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, dct</span>):</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr) 这是python2的写法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, clsname, bases, uppercase_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元类要做的事就是拦截类的创建，修改一个类，返回修改之后的类。</span></span><br><span class="line"><span class="comment"># 当你需要动态修改类的时候，最好使用“monkey patching”或“装饰器”。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Python 的关键字 Yield</title>
    <url>/2018/03/14/understand-yield/</url>
    <content><![CDATA[<p>为了理解什么是yield,你必须理解什么是生成器。</p>
<p>在理解生成器之前，让我们先走近迭代。</p>
<p>当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>所有你可以使用for…in…语法的叫做一个迭代器，列表，字符串，文件等等，你经常使用它们是因为你可以如你所愿的读取其中的元素，但是你把所有的值都存储到了内存中，如果你有大量数据的话这个方式并不是你想要的。</p>
<p>生成器是可以迭代的，但是你只可以读取它一次，因为它并不把所有的值放在内存中，它是实时地生成数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mygenerator = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>你不可以再次迭代生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(mygenerator)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    print(<span class="string">&quot;停止迭代&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_generator</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i * i</span><br></pre></td></tr></table></figure>

<p>如果函数内部使用 return，则返回 0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mygenerator = create_generator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>斐波拉契数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>():</span></span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>

<p>获取斐波拉契数列前10个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">list</span>(itertools.islice(fib(), <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>杨辉三角</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangle</span>():</span></span><br><span class="line">    a = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a = [<span class="built_in">sum</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>] + a, a + [<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>

<p>输出前10行杨辉三角</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="built_in">list</span>(itertools.islice(triangle(), <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>控制迭代器的穷尽</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span>():</span></span><br><span class="line">    crisis = <span class="literal">False</span>  <span class="comment"># crisis是危机的意思</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">&quot;$100&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bank = Bank()  <span class="comment"># 创建一个银行</span></span><br><span class="line">corner_street_atm = bank.create_atm()  <span class="comment"># 创建一个ATM机</span></span><br><span class="line">print([<span class="built_in">next</span>(corner_street_atm) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line">bank.crisis = <span class="literal">True</span>  <span class="comment"># 危机来了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="built_in">next</span>(corner_street_atm))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    print(<span class="string">&quot;corner_street_atm: no more money!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    wall_street_atm = bank.create_atm()</span><br><span class="line">    print(<span class="built_in">next</span>(wall_street_atm))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    print(<span class="string">&quot;wall_street_atm: no more money!&quot;</span>)</span><br><span class="line"></span><br><span class="line">bank.crisis = <span class="literal">False</span>  <span class="comment"># 问题是，即使改变crisis的值，ATM依然是空的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="built_in">next</span>(corner_street_atm))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    print(<span class="string">&quot;crisis is %s, and still no more money!&quot;</span> % bank.crisis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一个ATM机，现在有钱了</span></span><br><span class="line">brand_new_atm = bank.create_atm()</span><br><span class="line">print([<span class="built_in">next</span>(brand_new_atm) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br></pre></td></tr></table></figure>

<p><code>itertools</code> 模块包含了许多特殊的迭代方法</p>
<p>比赛中4匹马可能到达终点的先后顺序的可能情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">races = itertools.permutations(horses)</span><br><span class="line">print(races)</span><br><span class="line">pprint.pprint(<span class="built_in">list</span>(races))</span><br></pre></td></tr></table></figure>

<p>一个实现了 <code>__iter__</code> 方法的对象是可迭代的，一个实现了 <code>__next__</code> 方法的对象是迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fibs = Fibs()</span><br><span class="line">print([<span class="built_in">next</span>(fibs) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM 时间序列预测</title>
    <url>/2020/12/03/lstm-models-for-time-series-forecasting/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="调节内容"><a href="#调节内容" class="headerlink" title="调节内容"></a>调节内容</h2><p>1.输出维度 units<br>2.时间步长 timesteps<br>3.激活函数 activation<br>4.增加特征：增长率<br>5.增加特征：日期属性<br>6.预测增长率<br>7.单层 stateful LSTM<br>8.双层 stateful LSTM<br>9.批数据大小 batch_size<br>10.训练循环次数 epochs<br>11.原序列对数<br>12.原序列差分<br>13.归一化值域 feature_range<br>14.Bidirectional LSTM<br>15.CNN LSTM<br>16.ConvLSTM</p>
<a id="more"></a>

<h2 id="原始数据集"><a href="#原始数据集" class="headerlink" title="原始数据集"></a>原始数据集</h2><p><img src="/images/trans.png" class="lazyload" data-srcset="/images/trans.png" srcset="data:image/png;base64,666" alt="trans"></p>
<h2 id="原始序列"><a href="#原始序列" class="headerlink" title="原始序列"></a>原始序列</h2><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps,features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, epochs=epochs, batch_size=batch_size, validation_data=(x_valid, y_valid), callbacks=callbacks, verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="验证损失"><a href="#验证损失" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00031516602518997155</span><br><span class="line">elapsed time: 2.2270960807800293 (s)</span><br><span class="line">Train Score: 2350.04 RMSE</span><br><span class="line">Valid Score: 1975.81 RMSE</span><br><span class="line">Test Score: 1143.96 RMSE</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss1.png" class="lazyload" data-srcset="/images/loss1.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred1.png" class="lazyload" data-srcset="/images/pred1.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="Stateful-LSTM"><a href="#Stateful-LSTM" class="headerlink" title="Stateful LSTM"></a>Stateful LSTM</h2><p><strong>使 RNN 具有状态意味着每批样品的状态将被重新用作下一批样品的初始状态。</strong></p>
<blockquote>
<p>stateful LSTM：能让模型学习到你输入的samples之间的时序特征，适合一些长序列的预测，哪个sample在前，那个sample在后对模型是有影响的。<br>stateless LSTM：输入samples后，默认就会shuffle，可以说是每个sample独立，之间无前后关系，适合输入一些没有关系的样本。</p>
</blockquote>
<h3 id="超参数-1"><a href="#超参数-1" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, stateful=<span class="literal">True</span>, batch_input_shape=(batch_size, timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    history = model.fit(x_train, y_train, batch_size=batch_size, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line">    model.reset_states()</span><br></pre></td></tr></table></figure>

<h3 id="验证损失-1"><a href="#验证损失-1" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.0003053233659405426</span><br><span class="line">elapsed time: 8.588087797164917 (s)</span><br><span class="line">Train Score: 2098.81 RMSE</span><br><span class="line">Valid Score: 1768.38 RMSE</span><br><span class="line">Test Score: 880.83 RMSE</span><br><span class="line"></span><br><span class="line"># stateful带来了一些改观，从理论上讲stateful会有些好处，因为我们的数据是具有自相关性的时序数据。</span><br><span class="line"># 但是stateful限制训练、验证和预测必须接受以batch为单位的数据，给后面预测带来很大变动和限制，故不使用stateful。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss2.png" class="lazyload" data-srcset="/images/loss2.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred2.png" class="lazyload" data-srcset="/images/pred2.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="序列对数"><a href="#序列对数" class="headerlink" title="序列对数"></a>序列对数</h2><h3 id="超参数-2"><a href="#超参数-2" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-2"><a href="#模型定义-2" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-2"><a href="#验证损失-2" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.0003706229881521907</span><br><span class="line">elapsed time: 2.328054904937744 (s)</span><br><span class="line">Train Score: 2451.66 RMSE</span><br><span class="line">Valid Score: 1843.60 RMSE</span><br><span class="line">Test Score: 901.27 RMSE</span><br><span class="line"></span><br><span class="line"># 取对数在验证集和测试集上有所改观，在训练集上误差稍微增大</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss3.png" class="lazyload" data-srcset="/images/loss3.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred3.png" class="lazyload" data-srcset="/images/pred3.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="序列差分"><a href="#序列差分" class="headerlink" title="序列差分"></a>序列差分</h2><h3 id="超参数-3"><a href="#超参数-3" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-3"><a href="#模型定义-3" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br></pre></td></tr></table></figure>

<h3 id="一阶差分"><a href="#一阶差分" class="headerlink" title="一阶差分"></a>一阶差分</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 9.300382513113658e-05</span><br><span class="line">elapsed time: 1.9793977737426758 (s)</span><br><span class="line">Train Score: 1868.55 RMSE</span><br><span class="line">Valid Score: 1608.05 RMSE</span><br><span class="line">Test Score: 884.86 RMSE</span><br><span class="line"></span><br><span class="line"># 一阶差分误差改善效果明显，相较于取对数更优。</span><br><span class="line"># 经过验证发现将归一化值域调整为 feature_range = (-1, 1) 之后</span><br><span class="line"># 验证集损失 val_loss 会增大，但是 Train, Valid, Test 的 RMSE 却减少 100-200左右</span><br><span class="line"># 经过差分之后的数据有正有负，似乎 (-1, 1) 是合理的，但是本文将保持 (0, 1) 不变</span><br><span class="line"># 研究其他变化带来的变化，最后选出最优的特征和超参数，归一化值域可随时更改</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss4.png" class="lazyload" data-srcset="/images/loss4.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred4.png" class="lazyload" data-srcset="/images/pred4.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="二阶差分"><a href="#二阶差分" class="headerlink" title="二阶差分"></a>二阶差分</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00017968161298761821</span><br><span class="line">elapsed time: 2.5699269771575928 (s)</span><br><span class="line">Train Score: 2607.74 RMSE</span><br><span class="line">Valid Score: 2270.10 RMSE</span><br><span class="line">Test Score: 1025.25 RMSE</span><br><span class="line"></span><br><span class="line"># 二阶差分反而更差了，故只取一阶差分</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss5.png" class="lazyload" data-srcset="/images/loss5.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred5.png" class="lazyload" data-srcset="/images/pred5.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="序列对数差分"><a href="#序列对数差分" class="headerlink" title="序列对数差分"></a>序列对数差分</h2><h3 id="超参数-4"><a href="#超参数-4" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-4"><a href="#模型定义-4" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-3"><a href="#验证损失-3" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 8.005627370742416e-05</span><br><span class="line">elapsed time: 2.5233328342437744 (s)</span><br><span class="line">Train Score: 1883.97 RMSE</span><br><span class="line">Valid Score: 1621.68 RMSE</span><br><span class="line">Test Score: 879.93 RMSE</span><br><span class="line"></span><br><span class="line"># 可以发现对数差分的效果几乎和一阶差分的效果是一样的，取对数的效果微乎其微。</span><br><span class="line"># 差分之后的序列更接近平稳序列，可能更有利于LSTM建模预测。</span><br><span class="line"># 取对数只是缩小值域，再说还有归一化操作，似乎不是必要的。</span><br><span class="line"># 比如像LightGBM算法并没有归一化操作，所以取对数有比较好的调参效果。</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss6.png" class="lazyload" data-srcset="/images/loss6.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred6.png" class="lazyload" data-srcset="/images/pred6.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="增加日期属性"><a href="#增加日期属性" class="headerlink" title="增加日期属性"></a>增加日期属性</h2><p><img src="/images/gzdate.png" class="lazyload" data-srcset="/images/gzdate.png" srcset="data:image/png;base64,666" alt="gzdate"></p>
<h3 id="超参数-5"><a href="#超参数-5" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 4              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-5"><a href="#模型定义-5" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-4"><a href="#验证损失-4" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.002384760812697476</span><br><span class="line">elapsed time: 1.893902063369751 (s)</span><br><span class="line">Train Score: 2104.13 RMSE</span><br><span class="line">Valid Score: 5434.98 RMSE</span><br><span class="line">Test Score: 5839.40 RMSE</span><br><span class="line"></span><br><span class="line"># 模型在训练集、验证集和测试集表现越来越差</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss7.png" class="lazyload" data-srcset="/images/loss7.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred7.png" class="lazyload" data-srcset="/images/pred7.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="增加增长率"><a href="#增加增长率" class="headerlink" title="增加增长率"></a>增加增长率</h2><p><img src="/images/gzrate.png" class="lazyload" data-srcset="/images/gzrate.png" srcset="data:image/png;base64,666" alt="gzrate"></p>
<h3 id="超参数-6"><a href="#超参数-6" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 2              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-6"><a href="#模型定义-6" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-5"><a href="#验证损失-5" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00023447876570476951</span><br><span class="line">elapsed time: 2.060291051864624 (s)</span><br><span class="line">Train Score: 2084.47 RMSE</span><br><span class="line">Valid Score: 1704.23 RMSE</span><br><span class="line">Test Score: 1039.05 RMSE</span><br><span class="line"></span><br><span class="line"># 增长率也可以改善预测结果，原理和一阶差分相似，差分是做减法，增长率是做除法。</span><br><span class="line"># 误差减小了，但是增长率产生了负数的情况。</span><br><span class="line"># 之前的实验是增长率结合stateful LSTM，得到的结果是：增长率可以和一阶差分类似改善拟合结果，并无发现有负数的情况。</span><br><span class="line"># 做完实验考虑预测部分的时候发现stateful必须接受batch为单位的数据，使得预测变得麻烦，改动工作较大。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss8.png" class="lazyload" data-srcset="/images/loss8.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred8.png" class="lazyload" data-srcset="/images/pred8.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="预测增长率"><a href="#预测增长率" class="headerlink" title="预测增长率"></a>预测增长率</h3><p>变换目标值为增长率，预测增长率，和前一天的交易量进行计算，得到当前的交易预测值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.007923171162502511</span><br><span class="line">elapsed time: 1.5544190406799316 (s)</span><br><span class="line">Train Score: 1575.60 RMSE</span><br><span class="line">Valid Score: 1307.57 RMSE</span><br><span class="line">Test Score: 761.17 RMSE</span><br><span class="line"></span><br><span class="line"># 结合图可以看出，相比增加增长率这个特征，直接预测增长率收到了比较好的效果。</span><br><span class="line"># 而且没有出现负数的情况，拟合误差减少很多，可以采用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss9.png" class="lazyload" data-srcset="/images/loss9.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred9.png" class="lazyload" data-srcset="/images/pred9.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="双层LSTM"><a href="#双层LSTM" class="headerlink" title="双层LSTM"></a>双层LSTM</h2><h3 id="超参数-7"><a href="#超参数-7" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="单层LSTM有Dropout"><a href="#单层LSTM有Dropout" class="headerlink" title="单层LSTM有Dropout"></a>单层LSTM有Dropout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00024637159007593934</span><br><span class="line">elapsed time: 2.1154732704162598 (s)</span><br><span class="line">Train Score: 2107.65 RMSE</span><br><span class="line">Valid Score: 1746.91 RMSE</span><br><span class="line">Test Score: 906.77 RMSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss10.png" class="lazyload" data-srcset="/images/loss10.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred10.png" class="lazyload" data-srcset="/images/pred10.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="双层LSTM有Dropout"><a href="#双层LSTM有Dropout" class="headerlink" title="双层LSTM有Dropout"></a>双层LSTM有Dropout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features), return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00030157841621581707</span><br><span class="line">elapsed time: 3.7397210597991943 (s)</span><br><span class="line">Train Score: 2266.96 RMSE</span><br><span class="line">Valid Score: 1932.75 RMSE</span><br><span class="line">Test Score: 1101.70 RMSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss11.png" class="lazyload" data-srcset="/images/loss11.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred11.png" class="lazyload" data-srcset="/images/pred11.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="双层LSTM无Dropout"><a href="#双层LSTM无Dropout" class="headerlink" title="双层LSTM无Dropout"></a>双层LSTM无Dropout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features), return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00028111153606354833</span><br><span class="line">elapsed time: 3.16672682762146 (s)</span><br><span class="line">Train Score: 2269.73 RMSE</span><br><span class="line">Valid Score: 1866.01 RMSE</span><br><span class="line">Test Score: 1003.38 RMSE</span><br><span class="line"></span><br><span class="line"># 单层LSTM加上Dropout正则化层，相较于单层LSTM似乎有所改善，但对于Dropout的作用还不太明白。</span><br><span class="line"># 双层LSTM加上Dropout正则化层，相较于双层LSTM又是略差些，但是相差不大。</span><br><span class="line"># 对于这些结果，可能需要多次实验取均值来确定哪些因素对拟合更优。</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss12.png" class="lazyload" data-srcset="/images/loss12.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred12.png" class="lazyload" data-srcset="/images/pred12.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="差分结合增长率"><a href="#差分结合增长率" class="headerlink" title="差分结合增长率"></a>差分结合增长率</h2><p>在一阶差分的基础上增加增长率这个特征</p>
<p><img src="/images/gzdiff.png" class="lazyload" data-srcset="/images/gzdiff.png" srcset="data:image/png;base64,666" alt="gzdiff"></p>
<h3 id="超参数-8"><a href="#超参数-8" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 2              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-7"><a href="#模型定义-7" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br></pre></td></tr></table></figure>

<h3 id="验证损失-6"><a href="#验证损失-6" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 8.446127437506554e-05</span><br><span class="line">elapsed time: 2.3685760498046875 (s)</span><br><span class="line">Train Score: 1787.02 RMSE</span><br><span class="line">Valid Score: 1532.42 RMSE</span><br><span class="line">Test Score: 901.20 RMSE</span><br><span class="line"></span><br><span class="line"># 从误差结果可以看出，这个和一阶差分的结果相差无几</span><br><span class="line"># 但是从拟合图上看，拟合值出现了负数的情况，这是增长率带来的结果</span><br><span class="line"># 所以可以通过预测增长率，再结合一阶差分看看</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss13.png" class="lazyload" data-srcset="/images/loss13.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred13.png" class="lazyload" data-srcset="/images/pred13.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="预测增长率-1"><a href="#预测增长率-1" class="headerlink" title="预测增长率"></a>预测增长率</h3><p>预测增长率，再结合一阶差分，这个和上面的不同之处在于使用增长率作为目标值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.007926768652017368</span><br><span class="line">elapsed time: 1.7802140712738037 (s)</span><br><span class="line">Train Score: 1600.33 RMSE</span><br><span class="line">Valid Score: 1325.91 RMSE</span><br><span class="line">Test Score: 769.42 RMSE</span><br><span class="line"></span><br><span class="line"># 这个结果和单纯预测增长率的结果又是相差无几，差不差分都无所谓了。</span><br><span class="line"># 总结：一阶差分和预测增长率是二选一的结果，二者都能达到较好的优化，预测增长率更优一些。</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss14.png" class="lazyload" data-srcset="/images/loss14.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred14.png" class="lazyload" data-srcset="/images/pred14.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="Bidirectional-LSTM"><a href="#Bidirectional-LSTM" class="headerlink" title="Bidirectional LSTM"></a>Bidirectional LSTM</h2><blockquote>
<p>On some sequence prediction problems, it can be beneficial to allow the LSTM model to learn the input sequence both forward and backwards and concatenate both interpretations.<br>This is called a <a href="https://machinelearningmastery.com/develop-bidirectional-lstm-sequence-classification-python-keras/"><strong>Bidirectional LSTM</strong></a>.<br>We can implement a Bidirectional LSTM for univariate time series forecasting by wrapping the first hidden layer in a wrapper layer called Bidirectional.</p>
</blockquote>
<h3 id="超参数-9"><a href="#超参数-9" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-8"><a href="#模型定义-8" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Bidirectional(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>), input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-7"><a href="#验证损失-7" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.0002106719806980023</span><br><span class="line">elapsed time: 2.6818039417266846 (s)</span><br><span class="line">Train Score: 1946.72 RMSE</span><br><span class="line">Valid Score: 1615.40 RMSE</span><br><span class="line">Test Score: 823.85 RMSE</span><br><span class="line"></span><br><span class="line"># Bidirectional LSTM 具有明显改善效果，这个可以结合一阶差分或者预测增长率使用。</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss15.png" class="lazyload" data-srcset="/images/loss15.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred15.png" class="lazyload" data-srcset="/images/pred15.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="CNN-LSTM"><a href="#CNN-LSTM" class="headerlink" title="CNN LSTM"></a>CNN LSTM</h2><blockquote>
<p>A convolutional neural network, or CNN for short, is a type of neural network developed for working with two-dimensional image data.<br>The CNN can be very effective at automatically extracting and learning features from one-dimensional sequence data such as univariate time series data.<br>A CNN model can be used in a hybrid model with an LSTM backend where the CNN is used to interpret subsequences of input that together are provided as a sequence to an LSTM model to interpret. <a href="https://machinelearningmastery.com/cnn-long-short-term-memory-networks/">This hybrid model is called a CNN-LSTM</a>.</p>
</blockquote>
<h3 id="超参数-10"><a href="#超参数-10" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 4             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-9"><a href="#模型定义-9" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Conv1D(filters=units, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;tanh&#x27;</span>), input_shape=(<span class="literal">None</span>, timesteps//<span class="number">2</span>, features)))</span><br><span class="line">model.add(TimeDistributed(MaxPooling1D(pool_size=<span class="number">2</span>)))</span><br><span class="line">model.add(TimeDistributed(Flatten()))</span><br><span class="line">model.add(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-8"><a href="#验证损失-8" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00021777707989074557</span><br><span class="line">elapsed time: 2.1609442234039307 (s)</span><br><span class="line">Train Score: 2035.46 RMSE</span><br><span class="line">Valid Score: 1642.41 RMSE</span><br><span class="line">Test Score: 851.72 RMSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss16.png" class="lazyload" data-srcset="/images/loss16.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred16.png" class="lazyload" data-srcset="/images/pred16.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="ConvLSTM"><a href="#ConvLSTM" class="headerlink" title="ConvLSTM"></a>ConvLSTM</h2><blockquote>
<p>A type of LSTM related to the CNN-LSTM is the ConvLSTM, where the convolutional reading of input is built directly into each LSTM unit.<br>The ConvLSTM was developed for reading two-dimensional spatial-temporal data, but can be adapted for use with univariate time series forecasting.</p>
</blockquote>
<h3 id="超参数-11"><a href="#超参数-11" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 4             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-10"><a href="#模型定义-10" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(ConvLSTM2D(filters=units, kernel_size=(<span class="number">1</span>,<span class="number">2</span>), activation=<span class="string">&#x27;tanh&#x27;</span>, input_shape=(timesteps//<span class="number">2</span>, <span class="number">1</span>, timesteps//<span class="number">2</span>, features)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-9"><a href="#验证损失-9" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00022352560738618104</span><br><span class="line">elapsed time: 3.2140681743621826 (s)</span><br><span class="line">Train Score: 2092.71 RMSE</span><br><span class="line">Valid Score: 1663.95 RMSE</span><br><span class="line">Test Score: 844.92 RMSE</span><br><span class="line"></span><br><span class="line"># 三种模型相较于原始的单层 stateless LSTM 模型都具有改善效果</span><br><span class="line"># Bidirectional LSTM 略好一点</span><br></pre></td></tr></table></figure>

<p><img src="/images/loss17.png" class="lazyload" data-srcset="/images/loss17.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred17.png" class="lazyload" data-srcset="/images/pred17.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>Stateless LSTM or Bidirectional LSTM or CNN LSTM or ConvLSTM</p>
<p>一阶差分 or 预测增长率</p>
<p>本次实验使用颜色标记的方案</p>
<h3 id="超参数-12"><a href="#超参数-12" class="headerlink" title="超参数"></a>超参数</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 定义超参数</span><br><span class="line">batch_size = 128          # 批数据大小</span><br><span class="line">epochs = 50               # 实验训练次数</span><br><span class="line">units = 64                # 状态的输出维度</span><br><span class="line">features = 1              # 最终输出维度</span><br><span class="line">timesteps = 3             # 时间步长</span><br><span class="line">feature_range = (0, 1)    # 归一化值域</span><br><span class="line">ratio = 0.8               # 数据集分割比例</span><br></pre></td></tr></table></figure>

<h3 id="模型定义-11"><a href="#模型定义-11" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Bidirectional(LSTM(units=units, activation=<span class="string">&#x27;tanh&#x27;</span>), input_shape=(timesteps, features)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.summary()</span><br><span class="line">callbacks = [</span><br><span class="line">    keras.callbacks.EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">2</span>),</span><br><span class="line">    keras.callbacks.ModelCheckpoint(filepath=<span class="string">&#x27;model.h5&#x27;</span>, monitor=<span class="string">&#x27;val_loss&#x27;</span>, save_best_only=<span class="literal">True</span>),</span><br><span class="line">    keras.callbacks.ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, factor=<span class="number">0.01</span>, patience=<span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=<span class="number">1</span>, validation_data=(x_valid, y_valid), shuffle=<span class="literal">False</span>, callbacks=callbacks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证损失-10"><a href="#验证损失-10" class="headerlink" title="验证损失"></a>验证损失</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.00794555525360681</span><br><span class="line">elapsed time: 2.404299020767212 (s)</span><br><span class="line">Train Score: 1576.97 RMSE</span><br><span class="line">Valid Score: 1307.11 RMSE</span><br><span class="line">Test Score: 758.50 RMSE</span><br><span class="line"></span><br><span class="line"># 可以看出这个方案和预测增长率的方案的结果是一样的，改变为Bidirectional LSTM 结构有略微的好处</span><br><span class="line"># 这种双向循环神经网络的隐藏层保存了两个值，A 参与正向计算， A&#x27; 参与反向计算，最终的输出值 y 取决于 A 和 A&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="看看细节"><a href="#看看细节" class="headerlink" title="看看细节"></a>看看细节</h3><p><img src="/images/detail1.png" class="lazyload" data-srcset="/images/detail1.png" srcset="data:image/png;base64,666" alt="detail1"></p>
<p><img src="/images/detail2.png" class="lazyload" data-srcset="/images/detail2.png" srcset="data:image/png;base64,666" alt="detail2"></p>
<p><img src="/images/detail3.png" class="lazyload" data-srcset="/images/detail3.png" srcset="data:image/png;base64,666" alt="detail3"></p>
<h3 id="成功率"><a href="#成功率" class="headerlink" title="成功率"></a>成功率</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 6.0617386995090114e-09</span><br><span class="line">elapsed time: 3.4173359870910645 (s)</span><br><span class="line">Train Score: 0.05 RMSE</span><br><span class="line">Valid Score: 0.01 RMSE</span><br><span class="line">Test Score: 0.13 RMSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss18.png" class="lazyload" data-srcset="/images/loss18.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred18_1.png" class="lazyload" data-srcset="/images/pred18_1.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p><img src="/images/pred18_2.png" class="lazyload" data-srcset="/images/pred18_2.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">validate cost: 0.009244604190229511</span><br><span class="line">elapsed time: 3.7244749069213867 (s)</span><br><span class="line">Train Score: 56.79 RMSE</span><br><span class="line">Valid Score: 14.35 RMSE</span><br><span class="line">Test Score: 77.87 RMSE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/loss19.png" class="lazyload" data-srcset="/images/loss19.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred19_1.png" class="lazyload" data-srcset="/images/pred19_1.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p><img src="/images/pred19_2.png" class="lazyload" data-srcset="/images/pred19_2.png" srcset="data:image/png;base64,666" alt="pred"></p>
<h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><h3 id="Why-is-my-forecasted-time-series-one-step-behind-the-actual-time-series"><a href="#Why-is-my-forecasted-time-series-one-step-behind-the-actual-time-series" class="headerlink" title="Why is my forecasted time series one step behind the actual time series?"></a><a href="https://machinelearningmastery.com/faq/single-faq/why-is-my-forecasted-time-series-right-behind-the-actual-time-series/"><strong>Why is my forecasted time series one step behind the actual time series?</strong></a></h3><p>Github上有人给出的一种解释是：<a href="https://github.com/currylym/time-series-prediction-learning-record"><strong>这是由于序列存在自相关性</strong></a></p>
<blockquote>
<p>做过时间序列的朋友可能常常会有这样的感受，用了某种算法做出来的测试集的平均绝对误差率或者r2系数都很好，但是把测试集的真实值及预测值画出来对比一下，就会发现t时刻的预测值往往是t-1时刻的真实值，也就是模型倾向于把上一时刻的真实值作为下一时刻的预测值，导致两条曲线存在滞后性，也就是真实值曲线滞后于预测值曲线，就像下图右边所显示的那样。之所以会这样，是因为序列存在自相关性，如一阶自相关指的是当前时刻的值与其自身前一时刻值之间的相关性。因此，如果一个序列存在一阶自相关，模型学到的就是一阶相关性。而消除自相关性的办法就是进行差分运算，也就是我们可以将当前时刻与前一时刻的差值作为我们的回归目标</p>
</blockquote>
<p>简单的说就是特征值X包含了目标值Y，试试改为一阶差分结果作为Y，上面已经试过增长率作为Y了，结果就是误差还好，但是有负数的情况出现。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>存在预测滞后的现象是因为时间序列本身存在自相关性，因为损失函数是mse，模型倾向于把上一个时刻的值当作下一个时刻的预测值，导致图形画出来看似很好，mse也很小。解决办法是消除时间序列的自相关性，可以进行差分或者分解，分解方法有EMD分解和小波分解法，上面试过差分似乎还是存在预测值滞后的问题，试过使用EMD分解一周的响应时间，性能不好，效率不高，耗时很久，效果还挺好，分解出了27个IMF分量。另外我需要证明LSTM在预测非平稳时间序列，也就是不存在自相关性的时间序列上，不存在预测值滞后的问题，我想最简单的就是构造一个一正一负的时间序列，如果LSTM模型总是拿上一个时刻的值当作下一个时刻的预测值，那么这个模型预测可以说总是错的，如果结果还好，不存在滞后问题，那么就可以使用EMD分解法来逐个预测，最后综合各个的预测结果，还有一个问题是EMD分解性能的问题，可能需要再找一个效率更高的包，可能存在也可能不存在。如果顺利的话，最后预测也是个问题，既然分解了，那么预测的时候怎么预测？</p>
<p><a href="https://www.jianshu.com/p/5e82c162f3f4">基于EMD分解与LSTM的空气质量预测</a></p>
<p>我构造了一正一负的时间序列</p>
<p>正：100～150</p>
<p>负：-150～-100</p>
<p><img src="/images/gzyanz.png" class="lazyload" data-srcset="/images/gzyanz.png" srcset="data:image/png;base64,666" alt="gzyanz"></p>
<p>拟合结果</p>
<p><img src="/images/loss20.png" class="lazyload" data-srcset="/images/loss20.png" srcset="data:image/png;base64,666" alt="loss"></p>
<p><img src="/images/pred20_1.png" class="lazyload" data-srcset="/images/pred20_1.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p>再拉清楚点看看</p>
<p><img src="/images/pred20_2.png" class="lazyload" data-srcset="/images/pred20_2.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p><img src="/images/pred20_3.png" class="lazyload" data-srcset="/images/pred20_3.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p><img src="/images/pred20_4.png" class="lazyload" data-srcset="/images/pred20_4.png" srcset="data:image/png;base64,666" alt="pred"></p>
<p>完全重合，没有错位，没有滞后。是不是说明在平稳的非自相关性的时间序列上就不会有预测值滞后的问题，而并非特征构造的问题，因为LSTM本身就是利用过去的值来预测未来的值，要不然有个timesteps参数作何说明。</p>
]]></content>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LSTM 深度学习模型的日志异常检测</title>
    <url>/2021/06/08/log-anomaly-detection/</url>
    <content><![CDATA[<!-- toc -->

<h2 id="日志模式识别"><a href="#日志模式识别" class="headerlink" title="日志模式识别"></a>日志模式识别</h2><h3 id="日志样例"><a href="#日志样例" class="headerlink" title="日志样例"></a>日志样例</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2021-03-11 09:23:17,195 [OCKey:HlTOgWeM-LYFkTMn2wsXcEd] DEBUG com.dawninfotek.base.security.WebAppSafeGuard - BaseWebAppSafeGuard.class::key = beneAcctNo4 value = 1</span><br><span class="line">2021-03-11 09:23:17,849 [OCKey:zQXeCzqsWdY9_GliHIoAIpI] DEBUG com.dawninfotek.base.action.BaseDispatchAction - com.dawninfotek.easybanking.web.pr.olbfinance.polbfinancemyfinancenew.POLBFinanceMyFinanceAction::Base BaseDispatchAction - link6::37003747</span><br><span class="line">2021-03-11 09:23:18,635 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG com.dawninfotek.base.dac.ConnectionFactory - java.lang.Class::Getting a connection from dataSource</span><br><span class="line">2021-03-11 09:23:18,635 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG com.dawninfotek.base.dac.ConnectionFactory - java.lang.Class::got connection com.ibm.ws.rsadapter.jdbc.WSJdbcConnection@3bfa1e18 from dataSource: auto Commit = false</span><br><span class="line">2021-03-11 09:23:18,635 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG java.sql.Connection - &#123;conn-12085845&#125; Connection</span><br><span class="line">2021-03-11 09:23:18,635 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG java.sql.Connection - &#123;conn-12085845&#125; Preparing Statement:          select count(T.CUSTNO) from PERCRMPRODUCTDUEDATE t where t.CUSTNO=? and t.READFLAG = &#x27;0&#x27;</span><br><span class="line">2021-03-11 09:23:18,635 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG java.sql.PreparedStatement - &#123;pstm-12085846&#125; Executing Statement:          select count(T.CUSTNO) from PERCRMPRODUCTDUEDATE t where t.CUSTNO=? and t.READFLAG = &#x27;0&#x27;</span><br><span class="line">2021-03-11 09:23:18,636 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG java.sql.PreparedStatement - &#123;pstm-12085846&#125; Parameters: [42300205]</span><br><span class="line">2021-03-11 09:23:18,636 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG java.sql.PreparedStatement - &#123;pstm-12085846&#125; Types: [java.lang.String]</span><br><span class="line">2021-03-11 09:23:18,636 [OCKey:cSrKSPklI9-juH5TB1VdT6N] DEBUG com.dawninfotek.easybanking.base.process.EasyBankingProcessManager - com.dawninfotek.easybanking.base.process.EasyBankingProcessManager::Start to commit transaction for DAC:EasyBankingSample</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="日志模式"><a href="#日志模式" class="headerlink" title="日志模式"></a>日志模式</h3><p>使用 Drain3 算法对日志进行模式提取，共提取得到 190 条日志模式，只展示部分结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">62086</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;MODULE&gt; key &lt;*&gt; value&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;modul key valu&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">22856</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;CLASS&gt; key &lt;KEY&gt; value &lt;VALUE&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;class key key valu valu&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">2942</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;MODULE&gt; Base BaseDispatchAction &lt;*&gt; &lt;*&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;modul base basedispatchact&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">53</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">147</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;MODULE&gt; Base BaseDispatchAction &lt;*&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;modul base basedispatchact&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">4</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">4</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">16820</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;MODULE&gt; Getting a connection from dataSource&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;modul connect datasourc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">5</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">5</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">16820</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;MODULE&gt; got connection com.ibm.ws.rsadapter.jdbc.WSJdbcConnection &lt;*&gt; from dataSource auto Commit false&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;modul connect ibm rsadapt jdbc wsjdbcconnect datasourc auto commit fals&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">6</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">6</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">23956</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;CONN&gt; Connection&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;conn connect&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">7</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">7</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">22323</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;CONN&gt; Preparing Statement &lt;SQL&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;conn prepar statement sql&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">8</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">8</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">22323</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;PSTM&gt; Executing Statement &lt;SQL&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;pstm execut statement sql&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;group_id&quot;</span>: <span class="number">9</span>, <span class="attr">&quot;cluster_id&quot;</span>: <span class="number">9</span>, <span class="attr">&quot;cluster_size&quot;</span>: <span class="number">22322</span>, <span class="attr">&quot;is_abnormal&quot;</span>: <span class="literal">false</span>, <span class="attr">&quot;template_mined&quot;</span>: <span class="string">&quot;&lt;PSTM&gt; Parameters &lt;PARAMS&gt;&quot;</span>, <span class="attr">&quot;template_tokenize&quot;</span>: <span class="string">&quot;pstm paramet param&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>字段解释</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">group_id: 模式分组 ID，使用 Levenshtein 计算相似度，阈值为 0.8，大于等于阈值的模式会被分配到相同 group_id 之下。</span><br><span class="line">cluster_id：模式 ID。</span><br><span class="line">cluster_size: 模式匹配到的日志数量。</span><br><span class="line">is_abnormal: 根据通用的异常关键字，预判模式的异常。</span><br><span class="line">template_mined: 学习到的日志模式字符串。</span><br><span class="line">template_tokenize: 日志模式字符串经过一系列处理得到的字符串，后续日志模式向量计算基于该字符串。</span><br></pre></td></tr></table></figure>

<p>预置的通用异常关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">abnormal_chars = [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;fail&#x27;</span>, <span class="string">&#x27;failed&#x27;</span>, <span class="string">&#x27;exception&#x27;</span>, <span class="string">&#x27;invalid&#x27;</span>, <span class="string">&#x27;missing&#x27;</span>, <span class="string">&#x27;duplicate&#x27;</span>, <span class="string">&#x27;unable&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>日志模式字符串处理过程</p>
<h4 id="提取中英文单词"><a href="#提取中英文单词" class="headerlink" title="提取中英文单词"></a>提取中英文单词</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_lower_alphabet</span>(<span class="params">char</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小写字母&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\u0061&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;\u007A&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_upper_alphabet</span>(<span class="params">char</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;大写字母&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\u0041&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;\u005A&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_alphabet</span>(<span class="params">char</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;英文字母&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> is_lower_alphabet(char) <span class="keyword">or</span> is_upper_alphabet(char)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_chinese</span>(<span class="params">char</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;中文&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\u4e00&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;\u9fff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">segment</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;中英文分词&quot;&quot;&quot;</span></span><br><span class="line">    chars = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_alphabet(char) <span class="keyword">and</span> <span class="keyword">not</span> is_chinese(char)::</span><br><span class="line">            <span class="keyword">if</span> chars:</span><br><span class="line">                word = <span class="string">&#x27;&#x27;</span>.join(chars)</span><br><span class="line">                <span class="keyword">yield</span> word</span><br><span class="line">                chars = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chars.append(char)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> chars:</span><br><span class="line">        word = <span class="string">&#x27;&#x27;</span>.join(chars)</span><br><span class="line">        <span class="keyword">yield</span> word</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h4><p>如果提取得到的单词是中文，进一步将中文进行分词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hanlp</span><br><span class="line">HanLP = hanlp.load(hanlp.pretrained.mtl.CLOSE_TOK_POS_NER_SRL_DEP_SDP_CON_ELECTRA_SMALL_ZH)</span><br><span class="line"></span><br><span class="line">tokens = HanLP(<span class="string">&#x27;读取限流控制参数值&#x27;</span>, tasks=<span class="string">&#x27;tok/fine&#x27;</span>)[<span class="string">&#x27;tok/fine&#x27;</span>]  <span class="comment"># [&#x27;读取&#x27;, &#x27;限流&#x27;, &#x27;控制&#x27;, &#x27;参数值&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="统一转化为小写"><a href="#统一转化为小写" class="headerlink" title="统一转化为小写"></a>统一转化为小写</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="built_in">str</span>.lower(word)</span><br></pre></td></tr></table></figure>

<h4 id="词干提取"><a href="#词干提取" class="headerlink" title="词干提取"></a>词干提取</h4><p>词干提取（Stemming）是抽取词的词干或词根形式（不一定能够表达完整语义）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem.snowball <span class="keyword">import</span> SnowballStemmer</span><br><span class="line">stemmer= SnowballStemmer(<span class="string">&#x27;english&#x27;</span>)</span><br><span class="line"></span><br><span class="line">word = stemmer.stem(<span class="string">&#x27;Connection&#x27;</span>)  <span class="comment"># connect</span></span><br></pre></td></tr></table></figure>

<h4 id="词形还原"><a href="#词形还原" class="headerlink" title="词形还原"></a>词形还原</h4><p>词形还原（Lemmatization），是把一个任何形式的语言词汇还原为一般形式（能表达完整语义）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> WordNetLemmatizer</span><br><span class="line">lemmatizer = WordNetLemmatizer()</span><br><span class="line"></span><br><span class="line">word = lemmatizer.lemmatize(<span class="string">&#x27;rooms&#x27;</span>)  <span class="comment"># room</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="去停用词"><a href="#去停用词" class="headerlink" title="去停用词"></a>去停用词</h4><p>去除分词结果中的中英文停用词，这些词没有意义或者出现的频率很低，比如中文的 “的”、“是”、“啊”，英文的 “the”, “an”, “their”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 英文停用词: https://github.com/stopwords-iso/stopwords-en</span></span><br><span class="line"><span class="comment"># 中文停用词: https://github.com/goto456/stopwords</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_stopwords</span>():</span></span><br><span class="line">    english_path = Path(__file__).parent / <span class="string">&#x27;stopwords&#x27;</span> / <span class="string">&#x27;english&#x27;</span></span><br><span class="line">    chinese_path = Path(__file__).parent / <span class="string">&#x27;stopwords&#x27;</span> / <span class="string">&#x27;chinese&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> english_path.<span class="built_in">open</span>(<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> en, chinese_path.<span class="built_in">open</span>(<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> zh:</span><br><span class="line">        stopwords = &#123;line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> en&#125; | &#123;line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> zh&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stopwords</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模式向量计算"><a href="#模式向量计算" class="headerlink" title="模式向量计算"></a>模式向量计算</h2><h3 id="TF-IDF-计算"><a href="#TF-IDF-计算" class="headerlink" title="TF-IDF 计算"></a>TF-IDF 计算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取日志模版</span></span><br><span class="line">template = pd.read_csv(<span class="string">&#x27;easybanking.csv&#x27;</span>)</span><br><span class="line">template.fillna(<span class="string">&#x27;&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TF-IDF 计算</span></span><br><span class="line">corpus = template[<span class="string">&#x27;template_tokenize&#x27;</span>].to_list()</span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">X = vectorizer.fit_transform(corpus)</span><br><span class="line"></span><br><span class="line">xarr = X.toarray()</span><br><span class="line">words = vectorizer.get_feature_names()  <span class="comment"># 这里得到的词汇结果可能会被去掉一些频率很低的词</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="词向量计算"><a href="#词向量计算" class="headerlink" title="词向量计算"></a>词向量计算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"><span class="keyword">import</span> fasttext.util</span><br><span class="line"></span><br><span class="line">fasttext.FastText.eprint = <span class="keyword">lambda</span> x: <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练模型</span></span><br><span class="line">ften = fasttext.load_model(<span class="string">&#x27;cc.en.300.bin&#x27;</span>)</span><br><span class="line">ftzh = fasttext.load_model(<span class="string">&#x27;cc.zh.300.bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 词向量默认维度是300，可以降维。</span></span><br><span class="line">ften.get_dimension()  <span class="comment"># 300</span></span><br><span class="line">fasttext.util.reduce_model(ften, <span class="number">100</span>)</span><br><span class="line">ften.get_dimension()  <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordVectorDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 防止有些词汇不存在</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">map</span>(is_chinese, key)):</span><br><span class="line">            <span class="keyword">return</span> ftzh.get_word_vector(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ften.get_word_vector(key)</span><br><span class="line"></span><br><span class="line">word_vectors = WordVectorDict()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模式向量"><a href="#模式向量" class="headerlink" title="模式向量"></a>模式向量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式向量计算</span></span><br><span class="line">template_vectors = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> row, arr <span class="keyword">in</span> <span class="built_in">zip</span>(template.to_dict(orient=<span class="string">&#x27;records&#x27;</span>), xarr):</span><br><span class="line">    lookup = defaultdict(<span class="built_in">int</span>, <span class="built_in">zip</span>(words, arr))  <span class="comment"># 防止有些词汇不存在</span></span><br><span class="line">    tokens = row[<span class="string">&#x27;template_tokenize&#x27;</span>].split()</span><br><span class="line">    tv = np.zeros(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        w = lookup[token]  <span class="comment"># TF-IDF</span></span><br><span class="line">        v = word_vectors[token]  <span class="comment"># 词向量</span></span><br><span class="line">        wv = w * v</span><br><span class="line">        tv += wv</span><br><span class="line">    tv = tv <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">else</span> tv / <span class="built_in">len</span>(tokens)</span><br><span class="line">    template_vectors[row[<span class="string">&#x27;cluster_id&#x27;</span>]] = tv</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模式相似度"><a href="#模式相似度" class="headerlink" title="模式相似度"></a>模式相似度</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line">cs = cosine_similarity(template_vector_1.reshape(<span class="number">1</span>,-<span class="number">1</span>), template_vector_2.reshape(<span class="number">1</span>,-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><ol>
<li>TP：True Positive，预测为正，实际为正。</li>
<li>TN：True Negative，预测为负，实际为负。</li>
<li>FP：False Positive，预测为正，实际为负。</li>
<li>FN：False Negative，预测为负，实际为正。</li>
<li>准确率（Accuracy）：ACC = (TP+TN) / (TP+TN+FP+FN)</li>
<li>错误率（Error Rate）：ER = (FP+FN) / (TP+TN+FP+FN)</li>
<li>灵敏度（sensitive）：sensitive = TP/P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力。。</li>
<li>特效度（specificity）：specificity = TN/N，表示的是所有负例中被分对的比例，衡量了分类器对负例的识别能力。</li>
<li>精确率、精度（Precision）：Precesion = TP / (TP+FP)。</li>
<li>召回率（Recall）：Recall = TP / (TP+FN)。</li>
<li>综合评价指标（F-Measure）：F1 = (2 * P * R) / (P + R)。</li>
<li>计算速度：分类器训练和预测需要的时间。</li>
<li>鲁棒性：处理缺失值和异常值的能力。</li>
<li>可扩展性：处理大数据集的能力。</li>
<li>可解释性：分类器的预测标准的可理解性，像决策树产生的规则就是很容易理解的，而神经网络的一堆参数就不好理解，我们只好把它看成一个黑盒子。</li>
<li>ROC曲线：ROC（Receiver Operating Characteristic）曲线是以假正率（FP_rate）和真正率（TP_rate）为轴的曲线。</li>
<li>PR曲线：PR（Precision-Recall）曲线。</li>
</ol>
<h2 id="基于模式概率分布的异常检测"><a href="#基于模式概率分布的异常检测" class="headerlink" title="基于模式概率分布的异常检测"></a>基于模式概率分布的异常检测</h2><p>在没有得到日志模版向量表示之前，使用模版的索引对所有日志模版进行 One-Hot 编码，所以对于每一行日志都有一个其对应的模版编码，也可以叫模版概率分布。</p>
<p>对原始日志处理成模版的概率分布之后，我们可以训练一个多分类模型，预测下一个日志的模版概率分布，如果真实日志的模版不在预测的 topK 中，则认为日志是异常的。</p>
<h3 id="构造数据集"><a href="#构造数据集" class="headerlink" title="构造数据集"></a>构造数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> label_binarize</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_window_dataset</span>(<span class="params">log_parsed_path, template_path, window_size, split_ratio=<span class="number">0.8</span></span>):</span></span><br><span class="line"></span><br><span class="line">    log_parsed = pd.read_csv(log_parsed_path)</span><br><span class="line">    templates = pd.read_csv(template_path)[<span class="string">&#x27;cluster_id&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">dataset, look_back, look_interval=<span class="number">0</span>, look_forward=<span class="number">1</span></span>):</span></span><br><span class="line">        x, y = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset)-look_back-look_interval-look_forward):</span><br><span class="line">            back = dataset[i:i+look_back,]</span><br><span class="line">            forward = dataset[i+look_back+look_interval:i+look_back+look_interval+look_forward,]</span><br><span class="line">            back_x = label_binarize(back, classes=templates)</span><br><span class="line">            forward_y = label_binarize(forward, classes=templates)[<span class="number">0</span>]</span><br><span class="line">            x.append(back_x)</span><br><span class="line">            y.append(forward_y)</span><br><span class="line">        <span class="keyword">return</span> np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    dataset = log_parsed[[<span class="string">&#x27;cluster_id&#x27;</span>]].values</span><br><span class="line">    x, y = fn(dataset, window_size)</span><br><span class="line"></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=split_ratio, shuffle=<span class="literal">False</span>, stratify=<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> (x_train, y_train), (x_test, y_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers, models, optimizers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>(<span class="params">input_shape, num_classes</span>):</span></span><br><span class="line">    inputs = layers.Input(shape=input_shape)</span><br><span class="line"></span><br><span class="line">    x = layers.Bidirectional(layers.LSTM(<span class="number">64</span>, return_sequences=<span class="literal">True</span>))(inputs)</span><br><span class="line">    x = layers.Bidirectional(layers.LSTM(<span class="number">64</span>))(x)</span><br><span class="line"></span><br><span class="line">    outputs = layers.Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    model = models.Model(inputs=inputs, outputs=outputs)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=optimizers.Adam(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">n_candidates = <span class="number">10</span></span><br><span class="line">window_size = <span class="number">10</span></span><br><span class="line">log_parsed_path = <span class="string">&#x27;easybanking_parsed_1w.csv&#x27;</span></span><br><span class="line">template_path = <span class="string">&#x27;easybanking_template.csv&#x27;</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = create_window_dataset(log_parsed_path, template_path, window_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">num_classes = y_train.shape[<span class="number">1</span>]</span><br><span class="line">input_shape = (x_train.shape[<span class="number">1</span>], x_train.shape[<span class="number">2</span>])</span><br><span class="line">model = build_model(input_shape, num_classes)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">call_backs = [</span><br><span class="line">    callbacks.ModelCheckpoint(<span class="string">&quot;best_model.h5&quot;</span>, save_best_only=<span class="literal">True</span>, monitor=<span class="string">&quot;val_loss&quot;</span>),</span><br><span class="line">    callbacks.ReduceLROnPlateau(monitor=<span class="string">&quot;val_loss&quot;</span>, factor=<span class="number">0.5</span>, patience=<span class="number">20</span>, min_lr=<span class="number">0.0001</span>),</span><br><span class="line">    callbacks.EarlyStopping(monitor=<span class="string">&quot;val_loss&quot;</span>, patience=<span class="number">50</span>, verbose=<span class="number">1</span>),</span><br><span class="line">]</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">20</span>, callbacks=call_backs, validation_split=<span class="number">0.2</span>, shuffle=<span class="literal">True</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">best_model = models.load_model(<span class="string">&quot;best_model.h5&quot;</span>)</span><br><span class="line">y_pred = best_model.predict(x_test)</span><br><span class="line">y_true = np.argmax(y_test, axis=<span class="number">1</span>)</span><br><span class="line">y_pred = np.argmax(y_pred, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 我们只知道日志模式预测的正确与否，但是不知道真实这条日志是否为异常，所以无法计算 TP、TN、FP 和 FN。</span></span><br><span class="line"><span class="comment"># 简单起见计算全局准确率和召回率，这里只取 topK K = 1。真正需要提高准确率等需要在模型参数和日志数据及其处理等方面调节。</span></span><br><span class="line">precision, recall, f1, _ = precision_recall_fscore_support(y_true, y_pred, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line"><span class="comment"># (0.7737737737737738, 0.7737737737737738, 0.7737737737737739, None)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>该方案对日志模板进行编码时只使用模板索引，这可能导致丢失有价值的信息，因为模板索引不能揭示日志的语义关系。</li>
<li>真实系统不断升级和更新，日志的模式可能会相应地漂移，该方案难以应付不断变化的、有噪声的日志数据。</li>
</ol>
<h2 id="基于有监督二分类的异常检测"><a href="#基于有监督二分类的异常检测" class="headerlink" title="基于有监督二分类的异常检测"></a>基于有监督二分类的异常检测</h2><p>我们得到了日志模版的向量表示，如果我们的数据集被人工标注了异常，我们很容易训练一个二分类模型，直接输出异常与否。</p>
<p>由于应用日志没有异常标注，所以此方案做不了，为了实验可以使用公开的 HDFS 日志，这份日志有异常标注。</p>
<p>这种输入是模式向量，输出是正常异常的概率，是一种粗粒度的异常检测方法，就是假设该模式是异常的，则所属该模式的日志均为异常。</p>
<p>这种方法感觉类似垃圾邮件分类，垃圾短信分类。</p>
<p>针对 HDFS 日志的异常检测，其实特征的构造是另一种做法，HDFS 的每一条日志都有一个 BlockID，根据 BlockID 可以提取出一个日志序列，而 BlockID 决定了这个日志序列的异常与否，换句话说，针对 HDFS 日志，单条日志没有正常异常的概念，只有根据 BlockID 提取的日志序列才有正常异常之分。就比如 “open file xxx” 和 “close file xxx”，单条来说都是正常的，但是结合到一起来看缺一不可，如果某个日志序列缺少了 open 或者 close 则认为文件打开异常了。所以 HDFS 日志的特征输入就是单个 BlockID 所属的日志序列，输出就是正常异常。</p>
<p>然而这种做法不具有普适性，换一个数据源日志则没法套用，只能说是该方法针对 HDFS 日志的异常检测具有比较好的效果。</p>
<h3 id="构造数据集-1"><a href="#构造数据集-1" class="headerlink" title="构造数据集"></a>构造数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_label_dataset</span>(<span class="params">log_parsed_path, template_path, split_ratio=<span class="number">0.8</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> fasttext</span><br><span class="line">    fasttext.FastText.eprint = <span class="keyword">lambda</span> x: <span class="literal">None</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">    ften = fasttext.load_model(<span class="string">&#x27;cc.en.300.bin&#x27;</span>)</span><br><span class="line">    ftzh = fasttext.load_model(<span class="string">&#x27;cc.zh.300.bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordVectorDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">map</span>(is_chinese, key)):</span><br><span class="line">                <span class="keyword">return</span> ftzh.get_word_vector(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ften.get_word_vector(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取日志模版</span></span><br><span class="line">    template = pd.read_csv(template_path)</span><br><span class="line">    template.fillna(<span class="string">&#x27;&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TF-IDF 计算</span></span><br><span class="line">    corpus = template[<span class="string">&#x27;template_tokenize&#x27;</span>].to_list()</span><br><span class="line">    vectorizer = TfidfVectorizer()</span><br><span class="line">    X = vectorizer.fit_transform(corpus)</span><br><span class="line">    xarr = X.toarray()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 词向量计算</span></span><br><span class="line">    words = vectorizer.get_feature_names()</span><br><span class="line">    word_vectors = WordVectorDict()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模版向量计算</span></span><br><span class="line">    template_vectors = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row, arr <span class="keyword">in</span> <span class="built_in">zip</span>(template.to_dict(orient=<span class="string">&#x27;records&#x27;</span>), xarr):</span><br><span class="line">        lookup = defaultdict(<span class="built_in">int</span>, <span class="built_in">zip</span>(words, arr))</span><br><span class="line">        tokens = row[<span class="string">&#x27;template_tokenize&#x27;</span>].split()</span><br><span class="line">        tv = np.zeros(<span class="number">300</span>)</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            w = lookup[token]  <span class="comment"># TF-IDF</span></span><br><span class="line">            v = word_vectors[token]  <span class="comment"># 词向量</span></span><br><span class="line">            wv = w * v</span><br><span class="line">            tv += wv</span><br><span class="line">        tv = tv <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">else</span> tv / <span class="built_in">len</span>(tokens)</span><br><span class="line">        template_vectors[row[<span class="string">&#x27;cluster_id&#x27;</span>]] = tv</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取日志解析结果</span></span><br><span class="line">    log_vectors = []</span><br><span class="line">    log_parsed = pd.read_csv(log_parsed_path)</span><br><span class="line">    <span class="keyword">for</span> cluster_id <span class="keyword">in</span> log_parsed[<span class="string">&#x27;cluster_id&#x27;</span>].to_list():</span><br><span class="line">        tv = template_vectors[cluster_id]</span><br><span class="line">        log_vectors.append(tv)</span><br><span class="line"></span><br><span class="line">    log_labels = log_parsed[<span class="string">&#x27;label&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">    x = np.array(log_vectors)</span><br><span class="line">    x = np.reshape(x, (x.shape[<span class="number">0</span>], <span class="number">1</span>, x.shape[<span class="number">1</span>]))</span><br><span class="line">    y = np.array(log_labels)</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=split_ratio, shuffle=<span class="literal">False</span>, stratify=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x_train, y_train), (x_test, y_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers, models, optimizers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>(<span class="params">input_shape, num_classes</span>):</span></span><br><span class="line">    inputs = layers.Input(shape=input_shape)</span><br><span class="line"></span><br><span class="line">    x = layers.Bidirectional(layers.LSTM(<span class="number">64</span>, return_sequences=<span class="literal">True</span>))(inputs)</span><br><span class="line">    x = layers.Bidirectional(layers.LSTM(<span class="number">64</span>))(x)</span><br><span class="line"></span><br><span class="line">    outputs = layers.Dense(num_classes, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    model = models.Model(inputs=inputs, outputs=outputs)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer=optimizers.Adam(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型训练-1"><a href="#模型训练-1" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">log_parsed_path = <span class="string">&#x27;HDFS_parsed_10w.csv&#x27;</span></span><br><span class="line">template_path = <span class="string">&#x27;HDFS_template.csv&#x27;</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) =  create_label_dataset(log_parsed_path, template_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">num_classes = <span class="number">1</span></span><br><span class="line">input_shape = (x_train.shape[<span class="number">1</span>], x_train.shape[<span class="number">2</span>])</span><br><span class="line">model = build_model(input_shape, num_classes)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">call_backs = [</span><br><span class="line">    callbacks.ModelCheckpoint(<span class="string">&quot;best_model.h5&quot;</span>, save_best_only=<span class="literal">True</span>, monitor=<span class="string">&quot;val_loss&quot;</span>),</span><br><span class="line">    callbacks.ReduceLROnPlateau(monitor=<span class="string">&quot;val_loss&quot;</span>, factor=<span class="number">0.5</span>, patience=<span class="number">20</span>, min_lr=<span class="number">0.0001</span>),</span><br><span class="line">    callbacks.EarlyStopping(monitor=<span class="string">&quot;val_loss&quot;</span>, patience=<span class="number">50</span>, verbose=<span class="number">1</span>),</span><br><span class="line">]</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">20</span>, callbacks=call_backs, validation_split=<span class="number">0.2</span>, shuffle=<span class="literal">True</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">best_model = models.load_model(<span class="string">&quot;best_model.h5&quot;</span>)</span><br><span class="line">y_pred = best_model.predict(x_test)</span><br><span class="line">y_pred = y_pred[:,<span class="number">0</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">precision, recall, f1, _ = precision_recall_fscore_support(y_true, y_pred, average=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"><span class="comment"># (0.9553976053045843, 1.0, 0.9771901149032715, None)</span></span><br><span class="line"><span class="comment"># 这里虽然有监督的二分类模型取得了 95% 以上的准确度，但是数据集不合理，数据集应该包含 50% 的正常日志和 50% 的异常日志再加以乱序，这样训练出来的结果是比较合理的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">metric = <span class="string">&quot;accuracy&quot;</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(history.history[metric])</span><br><span class="line">plt.plot(history.history[<span class="string">&quot;val_&quot;</span> + metric])</span><br><span class="line">plt.title(<span class="string">&quot;model &quot;</span> + metric)</span><br><span class="line">plt.ylabel(metric, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;epoch&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>], loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="HDFS.png" class="lazyload" data-srcset="HDFS.png" srcset="data:image/png;base64,666" alt="HDFS model accuracy"></p>
<h2 id="基于预测模式向量的异常检测"><a href="#基于预测模式向量的异常检测" class="headerlink" title="基于预测模式向量的异常检测"></a>基于预测模式向量的异常检测</h2><p>由于没有异常标注数据，所以需要换一种思路进行异常检测，借鉴对时间序列的预测，我们可以认为日志是一种时间序列，此方案中我们训练的模型不是分类模型，而是回归模型，预测下一个日志的模版向量表示，与真实日志的模版向量进行相似度计算，计算出的相似度低于某个阈值则认为该日志是异常的，相似度采用余弦相似度。</p>
<h3 id="构造数据集-2"><a href="#构造数据集-2" class="headerlink" title="构造数据集"></a>构造数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_vector_dataset</span>(<span class="params">log_parsed_path, template_path, window_size, split_ratio=<span class="number">0.8</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> fasttext</span><br><span class="line">    fasttext.FastText.eprint = <span class="keyword">lambda</span> x: <span class="literal">None</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">    ften = fasttext.load_model(<span class="string">&#x27;cc.en.300.bin&#x27;</span>)</span><br><span class="line">    ftzh = fasttext.load_model(<span class="string">&#x27;cc.zh.300.bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordVectorDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">map</span>(is_chinese, key)):</span><br><span class="line">                <span class="keyword">return</span> ftzh.get_word_vector(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ften.get_word_vector(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取日志模版</span></span><br><span class="line">    template = pd.read_csv(template_path)</span><br><span class="line">    template.fillna(<span class="string">&#x27;&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TF-IDF 计算</span></span><br><span class="line">    corpus = template[<span class="string">&#x27;template_tokenize&#x27;</span>].to_list()</span><br><span class="line">    vectorizer = TfidfVectorizer()</span><br><span class="line">    X = vectorizer.fit_transform(corpus)</span><br><span class="line">    xarr = X.toarray()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 词向量计算</span></span><br><span class="line">    words = vectorizer.get_feature_names()</span><br><span class="line">    word_vectors = WordVectorDict()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模版向量计算</span></span><br><span class="line">    template_vectors = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row, arr <span class="keyword">in</span> <span class="built_in">zip</span>(template.to_dict(orient=<span class="string">&#x27;records&#x27;</span>), xarr):</span><br><span class="line">        lookup = defaultdict(<span class="built_in">int</span>, <span class="built_in">zip</span>(words, arr))</span><br><span class="line">        tokens = row[<span class="string">&#x27;template_tokenize&#x27;</span>].split()</span><br><span class="line">        tv = np.zeros(<span class="number">300</span>)</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            w = lookup[token]  <span class="comment"># TF-IDF</span></span><br><span class="line">            v = word_vectors[token]  <span class="comment"># 词向量</span></span><br><span class="line">            wv = w * v</span><br><span class="line">            tv += wv</span><br><span class="line">        tv = tv <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">else</span> tv / <span class="built_in">len</span>(tokens)</span><br><span class="line">        template_vectors[row[<span class="string">&#x27;cluster_id&#x27;</span>]] = tv</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取日志解析结果</span></span><br><span class="line">    log_vectors = []</span><br><span class="line">    log_parsed = pd.read_csv(log_parsed_path)</span><br><span class="line">    <span class="keyword">for</span> cluster_id <span class="keyword">in</span> log_parsed[<span class="string">&#x27;cluster_id&#x27;</span>].to_list():</span><br><span class="line">        tv = template_vectors[cluster_id]</span><br><span class="line">        log_vectors.append(tv)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">dataset, look_back, look_interval=<span class="number">0</span>, look_forward=<span class="number">1</span></span>):</span></span><br><span class="line">        x, y = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset)-look_back-look_interval-look_forward):</span><br><span class="line">            back = dataset[i:i+look_back,]</span><br><span class="line">            forward = dataset[i+look_back+look_interval:i+look_back+look_interval+look_forward,]</span><br><span class="line">            x.append(back)</span><br><span class="line">            y.append(forward)</span><br><span class="line">        <span class="keyword">return</span> np.array(x), np.array(y)</span><br><span class="line"></span><br><span class="line">    x, y = fn(np.array(log_vectors), window_size)</span><br><span class="line">    y = y[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=split_ratio, shuffle=<span class="literal">False</span>, stratify=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x_train, y_train), (x_test, y_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型定义-2"><a href="#模型定义-2" class="headerlink" title="模型定义"></a>模型定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers, models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>(<span class="params">n_steps_in, n_features, n_steps_out</span>):</span></span><br><span class="line">    model = models.Sequential()</span><br><span class="line">    model.add(layers.Bidirectional(layers.LSTM(units=<span class="number">64</span>, activation=<span class="string">&#x27;tanh&#x27;</span>), input_shape=(n_steps_in, n_features)))</span><br><span class="line">    model.add(layers.Dense(n_steps_out))</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型训练-2"><a href="#模型训练-2" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">window_size = <span class="number">10</span></span><br><span class="line">log_parsed_path = <span class="string">&#x27;easybanking_parsed_1w.csv&#x27;</span></span><br><span class="line">template_path = <span class="string">&#x27;easybanking_template.csv&#x27;</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = create_vector_dataset(log_parsed_path, template_path, window_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">n_steps_in, n_features, n_steps_out = (x_train.shape[<span class="number">1</span>], x_train.shape[<span class="number">2</span>], y_train.shape[<span class="number">1</span>])</span><br><span class="line">model = build_model(n_steps_in, n_features, n_features)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">call_backs = [</span><br><span class="line">    callbacks.ModelCheckpoint(<span class="string">&quot;best_model.h5&quot;</span>, save_best_only=<span class="literal">True</span>, monitor=<span class="string">&quot;val_loss&quot;</span>),</span><br><span class="line">    callbacks.ReduceLROnPlateau(monitor=<span class="string">&quot;val_loss&quot;</span>, factor=<span class="number">0.5</span>, patience=<span class="number">20</span>, min_lr=<span class="number">0.0001</span>),</span><br><span class="line">    callbacks.EarlyStopping(monitor=<span class="string">&quot;val_loss&quot;</span>, patience=<span class="number">50</span>, verbose=<span class="number">1</span>),</span><br><span class="line">]</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">20</span>, callbacks=call_backs, validation_split=<span class="number">0.2</span>, shuffle=<span class="literal">True</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">metric = <span class="string">&quot;accuracy&quot;</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(history.history[metric])</span><br><span class="line">plt.plot(history.history[<span class="string">&quot;val_&quot;</span> + metric])</span><br><span class="line">plt.title(<span class="string">&quot;model &quot;</span> + metric)</span><br><span class="line">plt.ylabel(metric, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;epoch&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>], loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>

<p><img src="/images/easybanking.png" class="lazyload" data-srcset="/images/easybanking.png" srcset="data:image/png;base64,666" alt="easybanking model accuracy"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
        <tag>Drain3</tag>
        <tag>FastText</tag>
        <tag>HanLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask v0.1 源码阅读</title>
    <url>/2018/09/27/understand-flask-v01/</url>
    <content><![CDATA[<p><a href="https://github.com/pallets/flask/tree/0.1">flask v0.1</a> 是第一个发布的版本，单文件版，v0.4 是 flask 的最后一个单文件版本，文章中 flask 的源码有修改，因为依赖包有更新。</p>
<a id="more"></a>

<!-- toc -->

<h2 id="导包部分"><a href="#导包部分" class="headerlink" title="导包部分"></a>导包部分</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2.5 版本加入 with 语句，低于 2.5 需要引入，高于则忽略。</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有用到</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line"><span class="comment"># jinja2 模板引擎</span></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Environment, PackageLoader, FileSystemLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask 的 Request 和 Response 继承自 werkzeug 的 Request 和 Response</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request <span class="keyword">as</span> RequestBase, Response <span class="keyword">as</span> ResponseBase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后几行 _request_ctx_stack, current_app, request, session, g 用到。</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于测试请求上下文，在 Flask 类的方法 test_request_context 中调用，已失效。</span></span><br><span class="line"><span class="comment"># 最新版 test_request_context 方法调用 flask.testing 的 make_test_environ_builder，最终调用 werkzeug.test 的 EnvironBuilder。</span></span><br><span class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> create_environ</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> cached_property</span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> SharedDataMiddleware</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误处理</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> HTTPException, InternalServerError</span><br><span class="line"></span><br><span class="line"><span class="comment"># flask 自带的 session 用到</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.contrib.securecookie <span class="keyword">import</span> SecureCookie</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有用到，作为对外接口</span></span><br><span class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> abort, redirect</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Markup, escape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于获取应用程序根目录</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> pkg_resources</span><br><span class="line">    pkg_resources.resource_stream</span><br><span class="line"><span class="keyword">except</span> (ImportError, AttributeError):</span><br><span class="line">    pkg_resources = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Request-和-Response"><a href="#Request-和-Response" class="headerlink" title="Request 和 Response"></a><code>Request</code> 和 <code>Response</code></h2><p><code>flask</code> 的 <code>Request</code> 和 <code>Response</code> 继承自 <code>werkzeug</code> 的 <code>Request</code> 和 <code>Response</code>。</p>
<p>如果你想要自定义 <code>Request</code> 和 <code>Response</code>，你可以继承这两个类，然后指定 <code>Flask</code> 的 <code>request_class</code> 和 <code>response_class</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">RequestBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;请求类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, environ</span>):</span></span><br><span class="line">        RequestBase.__init__(self, environ)  <span class="comment"># WSGI 环境</span></span><br><span class="line">        self.endpoint = <span class="literal">None</span>  <span class="comment"># 视图函数的键名</span></span><br><span class="line">        self.view_args = <span class="literal">None</span>  <span class="comment"># 视图函数的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span>(<span class="params">ResponseBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    default_mimetype = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestGlobals</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestContext</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;请求上下文&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app, environ</span>):</span></span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.url_map.bind_to_environ(environ)</span><br><span class="line">        self.request = app.request_class(environ)</span><br><span class="line">        self.session = app.open_session(self.request)  <span class="comment"># 带上下文的 session</span></span><br><span class="line">        self.g = _RequestGlobals()  <span class="comment"># 带上下文的 g</span></span><br><span class="line">        self.flashes = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        _request_ctx_stack.push(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, tb</span>):</span></span><br><span class="line">        <span class="keyword">if</span> tb <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> self.app.debug:</span><br><span class="line">            _request_ctx_stack.pop()</span><br></pre></td></tr></table></figure>

<h2 id="几个有用的函数"><a href="#几个有用的函数" class="headerlink" title="几个有用的函数"></a>几个有用的函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_for</span>(<span class="params">endpoint, **values</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;函数跳转</span></span><br><span class="line"><span class="string">    endpoint: Flask 类有个 view_functions 字典，存储的就是 endpoint 和 视图函数的映射关系，默认 endpoint 是视图函数的名字</span></span><br><span class="line"><span class="string">    values: 路由传过来的参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _request_ctx_stack.top.url_adapter.build(endpoint, values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flash</span>(<span class="params">message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    消息闪现，存储在 session 中，是个列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    session[<span class="string">&#x27;_flashes&#x27;</span>] = (session.get(<span class="string">&#x27;_flashes&#x27;</span>, [])) + [message]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flashed_messages</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    把 session 中存储的消息全部 pop 出来并返回</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    flashes = _request_ctx_stack.top.flashes</span><br><span class="line">    <span class="keyword">if</span> flashes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _request_ctx_stack.top.flashes = flashes = \</span><br><span class="line">            session.pop(<span class="string">&#x27;_flashes&#x27;</span>, [])</span><br><span class="line">    <span class="keyword">return</span> flashes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template</span>(<span class="params">template_name, **context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从文件渲染模板</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    current_app.update_template_context(context)</span><br><span class="line">    <span class="keyword">return</span> current_app.jinja_env.get_template(template_name).render(context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template_string</span>(<span class="params">source, **context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从字符串渲染模板</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    current_app.update_template_context(context)</span><br><span class="line">    <span class="keyword">return</span> current_app.jinja_env.from_string(source).render(context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_default_template_ctx_processor</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模板处理，使得在所有模板中可以使用 request, session 和 g 三个全局变量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    reqctx = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(</span><br><span class="line">        request=reqctx.request,</span><br><span class="line">        session=reqctx.session,</span><br><span class="line">        g=reqctx.g</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_package_path</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据名字获取模块的路径&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> os.path.abspath(os.path.dirname(sys.modules[name].__file__))</span><br><span class="line">    <span class="keyword">except</span> (KeyError, AttributeError):</span><br><span class="line">        <span class="keyword">return</span> os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Flask-类"><a href="#Flask-类" class="headerlink" title="Flask 类"></a><code>Flask</code> 类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Flask 类实现了一个 WSGI 应用，只要将包或者模块的名字传递给它</span></span><br><span class="line"><span class="string">    一旦创建的时候，它将首先注册视图函数、路由映射、模板配置等等几个重要的对象</span></span><br><span class="line"><span class="string">    传入包的名字是用于解决应用内部资源的引用，具体请查看 open_resource 函数</span></span><br><span class="line"><span class="string">    一般情况下，你只需要这样创建：</span></span><br><span class="line"><span class="string">        from flask import Flask</span></span><br><span class="line"><span class="string">        app = Flask(__name__)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求类</span></span><br><span class="line">    request_class = Request</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应类</span></span><br><span class="line">    response_class = Response</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态文件路径，设置为 None 可以禁用</span></span><br><span class="line">    static_path = <span class="string">&#x27;/static&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密钥，用于 cookies 签名验证</span></span><br><span class="line">    secret_key = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基于 cookie 的 session 的名字</span></span><br><span class="line">    session_cookie_name = <span class="string">&#x27;session&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认会直接传给 jinja2 的 options 参数值</span></span><br><span class="line">    jinja_options = <span class="built_in">dict</span>(</span><br><span class="line">        autoescape=<span class="literal">True</span>,</span><br><span class="line">        extensions=[<span class="string">&#x27;jinja2.ext.autoescape&#x27;</span>, <span class="string">&#x27;jinja2.ext.with_&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, package_name</span>):</span></span><br><span class="line">        <span class="comment"># 调试模式开关，设置 True 以打开调试模式</span></span><br><span class="line">        <span class="comment"># 在调试模式下，应用程序出错会有特殊的错误页面以供调试</span></span><br><span class="line">        <span class="comment"># 并且服务会监控文件的变化，文件发生变化会重载服务</span></span><br><span class="line">        self.debug = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 包或者模块的名字，一旦设置好了就不要改动</span></span><br><span class="line">        self.package_name = package_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用程序顶级目录</span></span><br><span class="line">        self.root_path = _get_package_path(self.package_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 包含所有注册好的视图函数字典，键是函数的名字，也用于生成 URL</span></span><br><span class="line">        <span class="comment"># 值就是函数本身，可以用 route 装饰器注册一个函数</span></span><br><span class="line">        self.view_functions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有注册好的错误处理函数，键是错误代码，值是处理函数</span></span><br><span class="line">        <span class="comment"># 可以用 errorhandler 注册一个错误处理函数</span></span><br><span class="line">        self.error_handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理函数，每次请求之前会执行，用 before_request 装饰器注册</span></span><br><span class="line">        self.before_request_funcs = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后处理函数，每次请求完成以后执行，函数会截获响应并且改变它</span></span><br><span class="line">        <span class="comment"># 用 after_request 装饰器注册</span></span><br><span class="line">        self.after_request_funcs = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模板上下文处理器，默认有一个处理函数 _default_template_ctx_processor</span></span><br><span class="line">        <span class="comment"># 默认的函数功能是向模板上下文添加三个对象 request, session, g</span></span><br><span class="line">        <span class="comment"># 每个函数执行不需要参数，返回值为字典，用于填充模板上下文</span></span><br><span class="line">        self.template_context_processors = [_default_template_ctx_processor]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 路由映射，在 werkzeug.routing.Map</span></span><br><span class="line">        self.url_map = Map()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 架起一个静态资源服务，一般用于开发环境，生产环境用 nginx</span></span><br><span class="line">        <span class="keyword">if</span> self.static_path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.url_map.add(Rule(self.static_path + <span class="string">&#x27;/&lt;filename&gt;&#x27;</span>,</span><br><span class="line">                                  build_only=<span class="literal">True</span>, endpoint=<span class="string">&#x27;static&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> pkg_resources <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                target = (self.package_name, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target = os.path.join(self.root_path, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123;</span><br><span class="line">                self.static_path: target</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># jinja2 模板配置，包括模板目录和默认开启的功能</span></span><br><span class="line">        self.jinja_env = Environment(loader=self.create_jinja_loader(),</span><br><span class="line">                                     **self.jinja_options)</span><br><span class="line">        <span class="comment"># 这是两个模板能用到的函数</span></span><br><span class="line">        <span class="comment"># url_for 用于根据 endpoint 获取 URL</span></span><br><span class="line">        <span class="comment"># get_flashed_messages 用于获取消息闪现</span></span><br><span class="line">        self.jinja_env.<span class="built_in">globals</span>.update(</span><br><span class="line">            url_for=url_for,</span><br><span class="line">            get_flashed_messages=get_flashed_messages</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_jinja_loader</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加载模板目录，默认目录为 templates</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pkg_resources <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> FileSystemLoader(os.path.join(self.root_path, <span class="string">&#x27;templates&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> PackageLoader(self.package_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_template_context</span>(<span class="params">self, context</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为模板上下文注入几个常用的变量，比如 request, session, g</span></span><br><span class="line"><span class="string">        context 为填充模板上下文的字典</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        reqctx = _request_ctx_stack.top</span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.template_context_processors:</span><br><span class="line">            context.update(func())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">5000</span>, **options</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        运行开发服务器</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> werkzeug <span class="keyword">import</span> run_simple</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;debug&#x27;</span> <span class="keyword">in</span> options:</span><br><span class="line">            self.debug = options.pop(<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">        options.setdefault(<span class="string">&#x27;use_reloader&#x27;</span>, self.debug)</span><br><span class="line">        options.setdefault(<span class="string">&#x27;use_debugger&#x27;</span>, self.debug)</span><br><span class="line">        <span class="keyword">return</span> run_simple(host, port, self, **options)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_client</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为应用程序创建一个测试客户端</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> werkzeug <span class="keyword">import</span> Client</span><br><span class="line">        <span class="keyword">return</span> Client(self, self.response_class, use_cookies=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_resource</span>(<span class="params">self, resource</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        动态加载模块</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pkg_resources <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">open</span>(os.path.join(self.root_path, resource), <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pkg_resources.resource_stream(self.package_name, resource)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_session</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        创建一个 session，secret_key 必须设置</span></span><br><span class="line"><span class="string">        基于 werkzeug.contrib.securecookie.SecureCookie</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        key = self.secret_key</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> SecureCookie.load_cookie(request, self.session_cookie_name,</span><br><span class="line">                                            secret_key=key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_session</span>(<span class="params">self, session, response</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        保存 session</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> session <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            session.save_cookie(response, self.session_cookie_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span>(<span class="params">self, rule, endpoint, **options</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        创建 URL 和视图函数的映射规则，等同于 route 装饰器</span></span><br><span class="line"><span class="string">        只是 add_url_rule 并没有为视图函数注册一个 endpoint</span></span><br><span class="line"><span class="string">        这一步也就是向 view_functions 字典添加 endpoint: view_func 键值对</span></span><br><span class="line"><span class="string">        以下：</span></span><br><span class="line"><span class="string">            @app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="string">            def index():</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">        等同于：</span></span><br><span class="line"><span class="string">            def index():</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">            app.add_url_rule(&#x27;index&#x27;, &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">            app.view_functions[&#x27;index&#x27;] = index</span></span><br><span class="line"><span class="string">        options: 参数选项详见 werkzeug.routing.Rule</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        options[<span class="string">&#x27;endpoint&#x27;</span>] = endpoint</span><br><span class="line">        options.setdefault(<span class="string">&#x27;methods&#x27;</span>, (<span class="string">&#x27;GET&#x27;</span>,))</span><br><span class="line">        self.url_map.add(Rule(rule, **options))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route</span>(<span class="params">self, rule, **options</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为给定的 URL 注册一个视图函数</span></span><br><span class="line"><span class="string">        用法：</span></span><br><span class="line"><span class="string">            @app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="string">            def index():</span></span><br><span class="line"><span class="string">                return &#x27;Hello World&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        变量部分可以用尖括号(``/user/&lt;username&gt;``)指定，默认接受任何不带斜杆的字符串</span></span><br><span class="line"><span class="string">        变量也可以指定一个转换器，以指定类型的参数：</span></span><br><span class="line"><span class="string">        =========== ===========================================</span></span><br><span class="line"><span class="string">        int         整数</span></span><br><span class="line"><span class="string">        float       浮点数</span></span><br><span class="line"><span class="string">        path        路径</span></span><br><span class="line"><span class="string">        =========== ===========================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        值得注意的是 Flask 如何处理结尾的斜杆，核心思路是保证每个 URL 唯一：</span></span><br><span class="line"><span class="string">            1、如果配置了一个带结尾斜杆的 URL，用户请求不带结尾斜杆的这个 URL，则跳转到带结尾斜杆的页面。</span></span><br><span class="line"><span class="string">            2、如果配置了一个不带结尾斜杆的 URL，用户请求带结尾斜杆的这个 URL，则触发404错误。</span></span><br><span class="line"><span class="string">        这和 web 服务器处理静态资源 static 的逻辑是一样的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        rule: URL 字符串</span></span><br><span class="line"><span class="string">        methods: 允许的请求方法，是个列表，默认只接受 GET 请求和隐式的 HEAD</span></span><br><span class="line"><span class="string">        subdomain: 指定子域名</span></span><br><span class="line"><span class="string">        strict_slashes: 上述对结尾斜杆处理的开关</span></span><br><span class="line"><span class="string">        options: 参数选项详见 `werkzeug.routing.Rule`</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">f</span>):</span></span><br><span class="line">            self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">            self.view_functions[f.__name__] = f</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">errorhandler</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        注册一个错误码处理函数</span></span><br><span class="line"><span class="string">        用法：</span></span><br><span class="line"><span class="string">            @app.errorhandler(404)</span></span><br><span class="line"><span class="string">            def page_not_found():</span></span><br><span class="line"><span class="string">                return &#x27;This page does not exist&#x27;, 404</span></span><br><span class="line"><span class="string">        等同于：</span></span><br><span class="line"><span class="string">            def page_not_found():</span></span><br><span class="line"><span class="string">                return &#x27;This page does not exist&#x27;, 404</span></span><br><span class="line"><span class="string">            app.error_handlers[404] = page_not_found</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            code: 错误码</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">f</span>):</span></span><br><span class="line">            self.error_handlers[code] = f</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_request</span>(<span class="params">self, f</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注册一个预处理函数&quot;&quot;&quot;</span></span><br><span class="line">        self.before_request_funcs.append(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_request</span>(<span class="params">self, f</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注册一个后处理函数&quot;&quot;&quot;</span></span><br><span class="line">        self.after_request_funcs.append(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">context_processor</span>(<span class="params">self, f</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注册一个模板上下文处理函数&quot;&quot;&quot;</span></span><br><span class="line">        self.template_context_processors.append(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据当前请求的路由去和url_map匹配，拿到 enpoint 和 view_args</span></span><br><span class="line"><span class="string">        endpoint: 端点，是 view_functions 中对应视图函数的key</span></span><br><span class="line"><span class="string">        view_args: 视图函数的参数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rv = _request_ctx_stack.top.url_adapter.match()</span><br><span class="line">        request.endpoint, request.view_args = rv</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        首先调用上面的 match_request 方法拿到 endpoint 和 view_args</span></span><br><span class="line"><span class="string">        根据 endpoint 可以从 view_functions 找到对应的视图函数</span></span><br><span class="line"><span class="string">        再传入视图函数的参数 view_args，并返回结果，这个结果只是函数的返回值</span></span><br><span class="line"><span class="string">        并没有包装成响应类 response_class，可以调用 make_response 方法生成响应</span></span><br><span class="line"><span class="string">        如果函数执行失败，则根据错误码调用对应的错误处理函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            endpoint, values = self.match_request()</span><br><span class="line">            <span class="keyword">return</span> self.view_functions[endpoint](**values)</span><br><span class="line">        <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">            handler = self.error_handlers.get(e.code)</span><br><span class="line">            <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            <span class="keyword">return</span> handler(e)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            handler = self.error_handlers.get(<span class="number">500</span>)</span><br><span class="line">            <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">return</span> handler(e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_response</span>(<span class="params">self, rv</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将视图函数的返回值包装成一个真实的响应类 response_class</span></span><br><span class="line"><span class="string">        函数的返回值支持以下几种类型：</span></span><br><span class="line"><span class="string">        ======================= ===========================================</span></span><br><span class="line"><span class="string">        response_class:         响应类本身，原样返回</span></span><br><span class="line"><span class="string">        str:                    字符串，创建相应类并返回</span></span><br><span class="line"><span class="string">        unicode:                unicode 编码，utf-8编码后创建相应类并返回</span></span><br><span class="line"><span class="string">        tuple:                  元组，解包元组传入参数创建响应类并返回</span></span><br><span class="line"><span class="string">        a WSGI function:        WSGI 函数</span></span><br><span class="line"><span class="string">        ======================= ===========================================</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        rv: 视图函数的返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, self.response_class):</span><br><span class="line">            <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">        <span class="comment"># basestring 是 str 和 unicode 的超类，只支持 python2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, basestring):</span><br><span class="line">            <span class="keyword">return</span> self.response_class(rv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, <span class="built_in">tuple</span>):</span><br><span class="line">            <span class="keyword">return</span> self.response_class(*rv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.response_class.force_type(rv, request.environ)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在分发请求之前执行所有的预处理函数，如果预处理函数有返回值不为 None</span></span><br><span class="line"><span class="string">        则返回结果并中断其余的预处理</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">            rv = func()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        依次传入响应并执行所有的后处理函数，返回新的响应</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        session = _request_ctx_stack.top.session</span><br><span class="line">        <span class="keyword">if</span> session <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 保存 `session`</span></span><br><span class="line">            self.save_session(session, response)</span><br><span class="line">        <span class="keyword">for</span> handler <span class="keyword">in</span> self.after_request_funcs:</span><br><span class="line">            response = handler(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        WSGI 应用，可以用中间件包装：</span></span><br><span class="line"><span class="string">            app.wsgi_app = MyMiddleware(app.wsgi_app)</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        environ: WSGI 环境，是一个字典，包含了所有请求的信息</span></span><br><span class="line"><span class="string">        start_response: 回调函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">            rv = self.preprocess_request()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                rv = self.dispatch_request()</span><br><span class="line">            response = self.make_response(rv)</span><br><span class="line">            response = self.process_response(response)</span><br><span class="line">            <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_context</span>(<span class="params">self, environ</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        通过给定的 WSGI 环境创建一个请求上下文，并把它绑定到当前上下文中</span></span><br><span class="line"><span class="string">        必须通过 with 语句使用，因为 request 对象只在请求上下文</span></span><br><span class="line"><span class="string">        也就是 with 语句块中起作用</span></span><br><span class="line"><span class="string">        用法如下：</span></span><br><span class="line"><span class="string">            with app.request_context(environ):</span></span><br><span class="line"><span class="string">                do_something_with(request)</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        environ: WSGI 环境</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _RequestContext(self, environ)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_request_context</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        测试请求上下文，参数详见 werkzeug.create_environ</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.request_context(create_environ(*args, **kwargs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;调用 wsgi_app 方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.app)</span><br><span class="line">request = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.request)</span><br><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.session)</span><br><span class="line">g = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.g)</span><br></pre></td></tr></table></figure>

<h2 id="werkzeug-的-Local，LocalStack-和-LocalProxy"><a href="#werkzeug-的-Local，LocalStack-和-LocalProxy" class="headerlink" title="werkzeug 的 Local，LocalStack 和 LocalProxy"></a><code>werkzeug</code> 的 <code>Local</code>，<code>LocalStack</code> 和 <code>LocalProxy</code></h2><p><code>Flask</code> 中有两个上下文（<code>Context</code>）：</p>
<ol>
<li>应用上下文（<code>App Context</code>）</li>
<li>请求上下文（<code>Request Context</code>）</li>
</ol>
<p>上下文就是函数运行时所需要的外部变量，当我们运行一个简单的求和函数 <code>sum</code> 是不需要外部变量的，而像 <code>Flask</code> 中的视图函数运行需要知道当前的请求的路由、表单和请求方法等等一些信息。</p>
<p><code>Django</code> 和 <code>Tornado</code> 把视图函数所需要的外部信息封装成一个对象 <code>Request</code>，并把这个对象当作参数传给视图函数，无论视图函数有没有用到，所以编写 <code>Django</code> 的视图函数会到处都见到一个 <code>request</code> 参数。</p>
<p>而 <code>Flask</code> 则使用了类似 <code>Thread Local</code> 的对象，它可以隔离多线程/协程之间的状态，使得多线程/协程像操作一个全局变量一样操作各自的状态而互不影响，原理就是使用当前的线程ID作为命名空间，保存多份字典，每个线程只获取各自线程ID对应的字典。</p>
<p><code>Flask</code> 并没有使用 <code>Python</code> 标准库的 <code>Thread Local</code>，而是用了 <code>werkzeug</code> 实现的 <code>Local</code>。</p>
<p><code>Local</code> 和 <code>threading.local</code> 相似，但是 <code>Local</code> 在 <code>Greenlet</code> 可用的情况下优先使用 <code>getcurrent</code> 获取当前线程ID，用以支持 <code>Gevent</code> 调度。</p>
<p><code>Local</code> 还有一个 <code>__release_local__</code> 方法，用以释放当前线程存储的状态信息。</p>
<p><code>LocalStack</code> 是基于 <code>Local</code> 实现的栈结构，可以入栈（<code>push</code>）、出栈（<code>pop</code>）和获取栈顶对象（<code>top</code>）。</p>
<p><code>LocalProxy</code> 是作为 <code>Local</code> 的一个代理模式，它接受一个 <code>callable</code> 对象，注意参数不是 <code>Local</code> 实例，这个 <code>callable</code> 对象返回的结果才是 <code>Local</code> 实例，所有对于 <code>LocalProxy</code> 对象的操作都会转发到对应的 <code>Local</code>。 上</p>
<p>当 <code>app = Flask(__name__)</code> 实例化一个 <strong>Flask App</strong> 时，<code>App Context</code> 并没有立即被入栈，<code>LocalStack</code> 栈顶元素是空的，返回 <code>None</code> 值，<code>current_app</code>，<code>request</code>，<code>session</code> 和 <code>g</code> 也是 <code>unbound</code> 状态，此时使用这些对象会引发 <code>RuntimeError</code>，解决方法是手动将 <code>app.app_context()</code> 入栈。</p>
<p>当 <code>Flask</code> 应用被 <code>werkzeug</code> 自带的开发服务器或者 <code>gunicorn</code> 用于生产的这类 WSGI 服务器架起的时候，每一个请求进来之前会自动将请求上下文（<code>Request Context</code>）入栈。</p>
<p>应用上下文（<code>App Context</code>）在 flask v0.1 版本的源码中没有，后面版本引入，应用上下文也会自动入栈，后面待看。</p>
<p><code>threading.local</code> 使用：<br><img src="/images/threading-local.png" class="lazyload" data-srcset="/images/threading-local.png" srcset="data:image/png;base64,666" alt="threading.local"></p>
<p><code>Flask</code> 的 <code>App Context</code> 使用：<br><img src="/images/flask-app-context.png" class="lazyload" data-srcset="/images/flask-app-context.png" srcset="data:image/png;base64,666" alt="App Context"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 优先使用 Greenlet 的线程ID</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 固定属性</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;__storage__&#x27;</span>, <span class="string">&#x27;__ident_func__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 数据存储，是一个字典</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__storage__&#x27;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取当前线程ID的方法</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__ident_func__&#x27;</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;以生成器的方式返回字典的所有元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, proxy</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建一个 LocalProxy&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;清空当前线程/协程所保存的数据&quot;&quot;&quot;</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;属性访问&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;属性设置&quot;&quot;&quot;</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;属性删除&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Local 的栈结构实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Local 实例</span></span><br><span class="line">        self._local = Local()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 释放当前线程的数据</span></span><br><span class="line">        self._local.__release_local__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get__ident_func__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 返回获取当前线程ID的函数</span></span><br><span class="line">        <span class="keyword">return</span> self._local.__ident_func__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set__ident_func__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="comment"># 设置获取当前线程ID的函数</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self._local, <span class="string">&#x27;__ident_func__&#x27;</span>, value)</span><br><span class="line">    __ident_func__ = <span class="built_in">property</span>(_get__ident_func__, _set__ident_func__)</span><br><span class="line">    <span class="keyword">del</span> _get__ident_func__, _set__ident_func__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回一个 LocalProxy 对象，该对象始终指向 LocalStack 实例的栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_lookup</span>():</span></span><br><span class="line">            rv = self.top</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;object unbound&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> rv</span><br><span class="line">        <span class="keyword">return</span> LocalProxy(_lookup)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;入栈&quot;&quot;&quot;</span></span><br><span class="line">        rv = <span class="built_in">getattr</span>(self._local, <span class="string">&#x27;stack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._local.stack = rv = []</span><br><span class="line">        rv.append(obj)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span></span><br><span class="line">        stack = <span class="built_in">getattr</span>(self._local, <span class="string">&#x27;stack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(stack) == <span class="number">1</span>:</span><br><span class="line">            release_local(self._local)</span><br><span class="line">            <span class="keyword">return</span> stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._local.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@implements_bool</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Local 的代理模式实现，所有对 LocalProxy 对象的操作，包括属性访问、方法调用和二元操作</span></span><br><span class="line"><span class="string">    都会转发到那个 callable 参数返回的 Local 对象上</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;__local&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__wrapped__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, local, name=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 把 callable 参数绑定到 __local 属性上</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;_LocalProxy__local&#x27;</span>, local)</span><br><span class="line">        <span class="comment"># 代理名字</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__name__&#x27;</span>, name)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">callable</span>(local) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(local, <span class="string">&#x27;__release_local__&#x27;</span>):</span><br><span class="line">            <span class="comment"># 注意这里的参数 local 仅仅是一个 callable 对象</span></span><br><span class="line">            <span class="comment"># 该对象执行返回的结果才是 Local 实例</span></span><br><span class="line">            <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__wrapped__&#x27;</span>, local)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_object</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取当前 Local 实例&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self.__local, <span class="string">&#x27;__release_local__&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> self.__local()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.__local, self.__name__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;no object bound to %s&#x27;</span> % self.__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dict__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._get_current_object().__dict__</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;__dict__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            obj = self._get_current_object()</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;%s unbound&gt;&#x27;</span> % self.__class__.__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bool</span>(self._get_current_object())</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> unicode(self._get_current_object())  <span class="comment"># noqa</span></span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">repr</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dir</span>(self._get_current_object())</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;__members__&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dir</span>(self._get_current_object())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._get_current_object(), name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self._get_current_object()[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self._get_current_object()[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面的源码省略，LocalProxy 重写了所有的魔法方法</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Python 的装饰器</title>
    <url>/2021/07/09/understand-python-decorator/</url>
    <content><![CDATA[<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_line = <span class="keyword">lambda</span> x: print(<span class="string">&#x27;*&#x27;</span> * x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在python中函数也是对象，举个例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">word=<span class="string">&#x27;yes&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> word.capitalize() + <span class="string">&#x27;!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(shout())</span><br><span class="line"><span class="comment"># 你还可以把函数赋给一个变量</span></span><br><span class="line">scream = shout</span><br><span class="line">print(scream())</span><br><span class="line"><span class="comment"># 你可以删除旧的函数名，而scream依然可以用</span></span><br><span class="line"><span class="keyword">del</span> shout</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(shout())</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">print(scream())</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python的另一个有趣的特性就是你可以在一个函数里定义另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义另一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whisper</span>(<span class="params">word=<span class="string">&#x27;yes&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> word.lower() + <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 现在调用它</span></span><br><span class="line">    print(whisper())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次调用talk时都会定义一次whisper，然后talk会调用whisper</span></span><br><span class="line">talk()</span><br><span class="line"><span class="comment"># 但是在talk之外whisper是不存在的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(whisper())</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># 总结：函数是对象，可以赋给一个变量，可以在函数里面定义，因此函数可以返回另一个函数</span></span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_talk</span>(<span class="params">kind=<span class="string">&#x27;shout&#x27;</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先定义两个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">word=<span class="string">&#x27;yes&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> word.capitalize() + <span class="string">&#x27;!&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whisper</span>(<span class="params">word=<span class="string">&#x27;yes&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> word.lower() + <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据传入的参数返回不同的函数对象</span></span><br><span class="line">    <span class="keyword">if</span> kind == <span class="string">&#x27;shout&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> shout</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> whisper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把函数值赋给变量</span></span><br><span class="line">talk = get_talk()</span><br><span class="line"><span class="comment"># 可以看出函数值是一个函数对象</span></span><br><span class="line">print(talk)</span><br><span class="line"><span class="comment"># 再看看函数对象返回的对象</span></span><br><span class="line">print(talk())</span><br><span class="line"><span class="comment"># 你还可以这么用</span></span><br><span class="line">print(get_talk(<span class="string">&#x27;whisper&#x27;</span>)())</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既然可以return一个函数，那么把函数作为参数传递好了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something_before</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&quot;I do something before then I call the function you gave me&quot;</span>)</span><br><span class="line">    print(func())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_something_before(scream)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 装饰器就是在函数执行之前或之后执行另一些代码而不用修改函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器就是把其他函数作为参数的函数，然后返回一个函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_shiny_new_decorator</span>(<span class="params">a_function_to_decorate</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在函数里面，装饰器在运行中定义函数: 包装器</span></span><br><span class="line">    <span class="comment"># 这个函数将被包装在原始函数的外面，所以可以在原始函数之前和之后执行其他代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">the_wrapper_around_the_original_function</span>():</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把要在原始函数被调用前执行的代码放在这里</span></span><br><span class="line">        print(<span class="string">&quot;Before the function runs&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用原始函数</span></span><br><span class="line">        a_function_to_decorate()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把要在原始函数调用后执行的代码放在这里</span></span><br><span class="line">        print(<span class="string">&quot;After the function runs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在这里a_function_to_decorate函数还没有被执行</span></span><br><span class="line">    <span class="comment"># 在这里返回刚刚包装过的函数</span></span><br><span class="line">    <span class="comment"># 在包装函数里包含要在原始函数前后执行的代码</span></span><br><span class="line">    <span class="keyword">return</span> the_wrapper_around_the_original_function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在假想一下你创建了一个永远也不想去修改的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_stand_alone_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am a stand alone function, don&#x27;t you dare modify me!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先尝试运行一下这个永不修改的函数</span></span><br><span class="line">a_stand_alone_function()</span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 现在你可以装饰器来增加它的功能，把它作为参数传递给装饰器，装饰器会返回一个被包装过的函数，</span></span><br><span class="line">a_stand_alone_function_decorated = my_shiny_new_decorator(</span><br><span class="line">    a_stand_alone_function)</span><br><span class="line">a_stand_alone_function_decorated()</span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 现在你想要每次都是用a_stand_alone_function_decorated来代替a_stand_alone_function</span></span><br><span class="line">a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)</span><br><span class="line">a_stand_alone_function()</span><br><span class="line"><span class="comment"># 函数名字改变了，变成了装饰器返回的那个函数的名字</span></span><br><span class="line">print(a_stand_alone_function.__name__)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来看看装饰器的语法</span></span><br><span class="line"><span class="meta">@my_shiny_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_stand_alone_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Leave me alone!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @my_shiny_new_decorator就是another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)的缩写</span></span><br><span class="line">another_stand_alone_function()</span><br><span class="line"><span class="comment"># 但是这个函数的名字也改变了</span></span><br><span class="line">print(another_stand_alone_function.__name__)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然你也可以自己写一个装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bread</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&quot;&lt;/&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;\&gt;&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">&quot;&lt;\______/&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ingredients</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&quot;#tomatoes#&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">&quot;~salad~&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich</span>(<span class="params">food=<span class="string">&quot;--ham--&quot;</span></span>):</span></span><br><span class="line">    print(food)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在来做两个不同的三明治</span></span><br><span class="line">one_sandwich = bread(ingredients(sandwich))</span><br><span class="line">one_sandwich()</span><br><span class="line">print()</span><br><span class="line">two_sandwich = ingredients(bread(sandwich))</span><br><span class="line">two_sandwich()</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用装饰器语法糖做三明治</span></span><br><span class="line"><span class="meta">@bread</span></span><br><span class="line"><span class="meta">@ingredients</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich_a</span>(<span class="params">food=<span class="string">&quot;--ham--&quot;</span></span>):</span></span><br><span class="line">    print(food)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变一下顺序看看如何</span></span><br><span class="line"><span class="meta">@ingredients</span></span><br><span class="line"><span class="meta">@bread</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich_b</span>(<span class="params">food=<span class="string">&quot;--ham--&quot;</span></span>):</span></span><br><span class="line">    print(food)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sandwich_a()</span><br><span class="line">print()</span><br><span class="line">sandwich_b()</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 粗体装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="comment"># 装饰器将返回新的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        <span class="comment"># 在之前或者之后插入新的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;b&gt;&quot;</span> + fn() + <span class="string">&quot;&lt;/b&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 斜体装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="comment"># 装饰器将返回新的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        <span class="comment"># 在之前或者之后插入新的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span> + fn() + <span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(say())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这相当于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say = makebold(makeitalic(say))</span><br><span class="line">print(say())</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在装饰器函数里传入参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator_passing_arguments</span>(<span class="params">function_to_decorate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_wrapper_accepting_arguments</span>(<span class="params">arg1, arg2</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I got args! Look:&quot;</span>, arg1, arg2)</span><br><span class="line">        function_to_decorate(arg1, arg2)</span><br><span class="line">    <span class="keyword">return</span> a_wrapper_accepting_arguments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你调用装饰器返回的函数时，也就调用了包装器，把参数传入包装器里，包装器再把参数传递给被装饰的函数</span></span><br><span class="line"><span class="meta">@a_decorator_passing_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_full_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;My name is&quot;</span>, first_name, last_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_full_name(<span class="string">&quot;fuyun&quot;</span>, <span class="string">&quot;Liu&quot;</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用装饰器装饰类方法也是一样的，唯一的区别就是类方法的第一个参数是self，代表实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method_friendly_decorator</span>(<span class="params">method_to_decorate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">self, lie</span>):</span></span><br><span class="line">        lie = lie - <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> method_to_decorate(self, lie)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lucy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.age = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @method_friendly_decorator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_your_age</span>(<span class="params">self, lie</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am %s, what did you think?&quot;</span> % (self.age + lie))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = Lucy()</span><br><span class="line">l.say_your_age(-<span class="number">3</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想造一个更通用的可以同时满足方法和函数的装饰器，用*args，**kwargs就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator_passing_arbitrary_arguments</span>(<span class="params">function_to_decorate</span>):</span></span><br><span class="line">    <span class="comment"># 包装器接受所有参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_wrapper_accepting_arbitrary_arguments</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Do I have args?:&quot;</span>)</span><br><span class="line">        print(args)</span><br><span class="line">        print(kwargs)</span><br><span class="line">        <span class="comment"># args是个列表，kwargs是个字典</span></span><br><span class="line">        <span class="comment"># 这里可以把args和kwargs解包并对其处理</span></span><br><span class="line">        function_to_decorate(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> a_wrapper_accepting_arbitrary_arguments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_no_argument</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Python is cool, no argument here.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_with_no_argument()</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_arguments</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_with_arguments(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_named_arguments</span>(<span class="params">a, b, c, platypus=<span class="string">&quot;Why not ?&quot;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;Do %s, %s and %s like platypus? %s&quot;</span> % (a, b, c, platypus))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_with_named_arguments(<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;Linus&quot;</span>, <span class="string">&quot;Steve&quot;</span>, platypus=<span class="string">&quot;Indeed!&quot;</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mary</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.age = <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @a_decorator_passing_arbitrary_arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_your_age</span>(<span class="params">self, lie=-<span class="number">3</span></span>):</span>  <span class="comment"># 可以加入一个默认值</span></span><br><span class="line">        print(<span class="string">&quot;I am %s, what did you think?&quot;</span> % (self.age + lie))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = Mary()</span><br><span class="line">m.say_your_age(lie=-<span class="number">5</span>)  <span class="comment"># 这里又覆盖了默认值，可以变换着看一下</span></span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 像上面的把参数传给被装饰器返回的函数，实际上就是被定义在装饰器内部的包装器接收了。</span></span><br><span class="line"><span class="comment"># 那如何给装饰器传参数呢？再来回顾一下装饰器的用法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&quot;I am an ordinary function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&quot;I am function returned by the decorator&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;zzzzzzzz&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰函数的过程其实调用了装饰器函数，下面这句有打印信息。</span></span><br><span class="line">decorated_function = my_decorator(lazy_function)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样也是，输出&quot;I am an ordinary function&quot;</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;zzzzzzzz&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再用一层函数包装装饰器，我们就可以传参数给装饰器了，类似闭包，动态返回装饰器。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_maker</span>():</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;I make decorators! I am executed only once: &quot;</span> +</span><br><span class="line">          <span class="string">&quot;when you make me create a decorator.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;I am a decorator! I am executed only when you decorate a function.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">            print(<span class="string">&quot;I am the wrapper around the decorated function. &quot;</span></span><br><span class="line">                  <span class="string">&quot;I am called when you call the decorated function. &quot;</span></span><br><span class="line">                  <span class="string">&quot;As the wrapper, I return the RESULT of the decorated function.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;As the decorator, I return the wrapped function.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;As a decorator maker, I return a decorator&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用函数创建一个装饰器</span></span><br><span class="line">new_decorator = decorator_maker()</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am the decorated function.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用刚刚创建的装饰器装饰函数</span></span><br><span class="line">decorated_function = new_decorator(decorated_function)</span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 执行被装饰过的函数</span></span><br><span class="line">decorated_function()</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 用一行代码概括上面的</span></span><br><span class="line">decorator_maker()(decorated_function)()</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用@语法糖简化</span></span><br><span class="line"><span class="meta">@decorator_maker()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am the decorated function.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一下</span></span><br><span class="line">decorated_function()</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在来写一个带参数的装饰器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_maker_with_arguments</span>(<span class="params">decorator_arg1, decorator_arg2</span>):</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;I make decorators! And I accept arguments:&quot;</span>, decorator_arg1, decorator_arg2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="comment"># 这里传参的能力借鉴了闭包</span></span><br><span class="line">        <span class="comment"># 参考 http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python</span></span><br><span class="line">        print(<span class="string">&quot;I am the decorator. Somehow you passed me arguments:&quot;</span>, decorator_arg1, decorator_arg2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不要忘了装饰器参数和函数参数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">            print(<span class="string">&quot;I am the wrapper around the decorated function.\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;I can access all the variables\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;\t- from the decorator: &#123;0&#125; &#123;1&#125;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;\t- from the function call: &#123;2&#125; &#123;3&#125;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;Then I can pass them to the decorated function&quot;</span></span><br><span class="line">                  .<span class="built_in">format</span>(decorator_arg1, decorator_arg2,</span><br><span class="line">                          function_arg1, function_arg2))</span><br><span class="line">            <span class="keyword">return</span> func(function_arg1, function_arg2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_maker_with_arguments(<span class="params"><span class="string">&quot;Leonard&quot;</span>, <span class="string">&quot;Sheldon&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function_with_arguments</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;I am the decorated function and only knows about my arguments: &#123;0&#125;&quot;</span></span><br><span class="line">          <span class="string">&quot; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(function_arg1, function_arg2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">decorated_function_with_arguments(<span class="string">&quot;Rajesh&quot;</span>, <span class="string">&quot;Howard&quot;</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数还可以设置成变量</span></span><br><span class="line">c1 = <span class="string">&quot;Penny&quot;</span></span><br><span class="line">c2 = <span class="string">&quot;Leslie&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_maker_with_arguments(<span class="params"><span class="string">&quot;Leonard&quot;</span>, c1</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function_with_arguments</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;I am the decorated function and only knows about my arguments:&quot;</span></span><br><span class="line">          <span class="string">&quot; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(function_arg1, function_arg2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">decorated_function_with_arguments(c2, <span class="string">&quot;Howard&quot;</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后神奇的一招，如何装饰一个装饰器，动态地返回一个可以带任意参数的装饰器。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_with_args</span>(<span class="params">decorator_to_enhance</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个函数接收一个装饰器作为参数，返回一个被装饰的装饰器</span></span><br><span class="line"><span class="string">    这没什么高深，只不过是为了给装饰器传参而已</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator_maker</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 我们动态地建立一个只接收一个函数的装饰器</span></span><br><span class="line">        <span class="comment"># 但是他能接收来自maker的参数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator_wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后我们返回原始的装饰器，毕竟它只是普通的函数</span></span><br><span class="line">            <span class="comment"># 唯一的陷阱：装饰器必须有这个特殊的，否则将不会奏效</span></span><br><span class="line">            <span class="keyword">return</span> decorator_to_enhance(func, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorator_wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator_maker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把装饰器语法糖加到装饰器上面，注意这个装饰器是用来装饰函数的</span></span><br><span class="line"><span class="meta">@decorator_with_args</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_decorator</span>(<span class="params">func, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Decorated with&quot;</span>, args, kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(function_arg1, function_arg2)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在用被装饰过的装饰器装饰你的函数</span></span><br><span class="line"><span class="meta">@decorated_decorator(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Hello&quot;</span>, function_arg1, function_arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰器装饰过的函数</span></span><br><span class="line">decorated_function(<span class="string">&quot;world,&quot;</span>, <span class="string">&quot;Awesome!&quot;</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是不是被绕晕了，来看看终极调用过程</span></span><br><span class="line"><span class="comment"># 首先这是一个普通的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_decorator</span>(<span class="params">func, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Normal decorator decorated with&quot;</span>, args, kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(function_arg1, function_arg2)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_function</span>(<span class="params">function_arg1, function_arg2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Hello&quot;</span>, function_arg1, function_arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极变态调用过程如下</span></span><br><span class="line">decorator_with_args(normal_decorator)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)(normal_function)(<span class="string">&#x27;world,&#x27;</span>, <span class="string">&#x27;Awesome!&#x27;</span>)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在来关注一个小问题，被装饰器装饰的函数的名字__name__改变了。</span></span><br><span class="line"><span class="comment"># 幸好我们有functools.wraps()函数，它可以复制函数的名字，模块和文档给它的包装器。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(foo.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@bar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(foo.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面用functools.wraps()来修复</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        print(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@bar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(foo.__name__)</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何使用装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A decorator that prints the time a function takes</span></span><br><span class="line"><span class="string">    to execute.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        t = time.clock()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        print(func.__name__, time.clock() - t)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A decorator that logs the activity of the script.</span></span><br><span class="line"><span class="string">    (it actually just prints it, but it could be logging!)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        print(func.__name__, args, kwargs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A decorator that counts and prints the number of times a function has been executed</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        wrapper.count = wrapper.count + <span class="number">1</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">&quot;&#123;0&#125; has been used: &#123;1&#125;x&quot;</span>.<span class="built_in">format</span>(func.__name__, wrapper.count))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@counter</span></span><br><span class="line"><span class="meta">@benchmark</span></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_string</span>(<span class="params">string</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">reversed</span>(string))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(reverse_string(<span class="string">&quot;Able was I ere I saw Elba&quot;</span>))</span><br><span class="line">print(reverse_string(<span class="string">&quot;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&quot;</span>))</span><br><span class="line">print_line(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用重写装饰器而可以用他们来做任何事</span></span><br><span class="line"><span class="meta">@counter</span></span><br><span class="line"><span class="meta">@benchmark</span></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html_text</span>():</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> pprint</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(<span class="string">&quot;http://httpbin.org/html&quot;</span>)</span><br><span class="line">        pprint.pprint(r.text)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I got nothing!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_html_text()</span><br><span class="line">get_html_text()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>外国小说鉴赏辞典</title>
    <url>/2018/11/03/foreign-novel-appreciation-dictionary/</url>
    <content><![CDATA[<p>外国小说鉴赏辞典，从图书馆拍来的目录，纯手码，很累！</p>
<a id="more"></a>

<!-- toc -->

<h2 id="古代至19世纪中期卷"><a href="#古代至19世纪中期卷" class="headerlink" title="古代至19世纪中期卷"></a>古代至19世纪中期卷</h2><table>
<thead>
<tr>
<th>书名</th>
<th>国籍</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>阿玛莉亚</td>
<td>阿根廷</td>
<td>马莫尔</td>
</tr>
<tr>
<td>魂归故里</td>
<td>波兰</td>
<td>克拉舍夫斯基</td>
</tr>
<tr>
<td>春香传</td>
<td>朝鲜</td>
<td>佚名</td>
</tr>
<tr>
<td>痴儿西木传</td>
<td>德国</td>
<td>格里美尔斯豪森</td>
</tr>
<tr>
<td><strong>少年维特的烦恼</strong></td>
<td>德国</td>
<td>歌德</td>
</tr>
<tr>
<td><strong>威廉·麦斯特的学习时代</strong></td>
<td>德国</td>
<td>歌德</td>
</tr>
<tr>
<td><strong>亲和力</strong></td>
<td>德国</td>
<td>歌德</td>
</tr>
<tr>
<td><strong>金罐</strong></td>
<td>德国</td>
<td>霍夫曼</td>
</tr>
<tr>
<td><strong>侏儒查赫斯</strong></td>
<td>德国</td>
<td>霍夫曼</td>
</tr>
<tr>
<td><strong>雄猫穆尔的生活观</strong></td>
<td>德国</td>
<td>霍夫曼</td>
</tr>
<tr>
<td>温亭娜</td>
<td>德国</td>
<td>富凯</td>
</tr>
<tr>
<td>彼得·史勒密尔的奇怪故事</td>
<td>德国</td>
<td>沙米索</td>
</tr>
<tr>
<td>茵梦湖</td>
<td>德国</td>
<td>施托姆</td>
</tr>
<tr>
<td><strong>驿站长</strong></td>
<td>俄国</td>
<td>普希金</td>
</tr>
<tr>
<td><strong>黑桃皇后</strong></td>
<td>俄国</td>
<td>普希金</td>
</tr>
<tr>
<td><strong>上尉的女儿</strong></td>
<td>俄国</td>
<td>普希金</td>
</tr>
<tr>
<td>狂人日记</td>
<td>俄国</td>
<td>果戈里</td>
</tr>
<tr>
<td>塔拉斯·布利巴</td>
<td>俄国</td>
<td>果戈里</td>
</tr>
<tr>
<td><strong>外套</strong></td>
<td>俄国</td>
<td>果戈里</td>
</tr>
<tr>
<td><strong>死魂灵</strong></td>
<td>俄国</td>
<td>果戈里</td>
</tr>
<tr>
<td>谁之罪</td>
<td>俄国</td>
<td>赫尔岑</td>
</tr>
<tr>
<td>偷东西的喜鹊</td>
<td>俄国</td>
<td>赫尔岑</td>
</tr>
<tr>
<td>平凡的故事</td>
<td>俄国</td>
<td>冈察洛夫</td>
</tr>
<tr>
<td>当代英雄</td>
<td>俄国</td>
<td>莱蒙托夫</td>
</tr>
<tr>
<td>木木</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td><strong>白夜</strong></td>
<td>俄国</td>
<td>陀思妥耶夫斯基</td>
</tr>
<tr>
<td><strong>巨人传</strong></td>
<td>法国</td>
<td>拉伯雷</td>
</tr>
<tr>
<td>吉尔·布拉斯</td>
<td>法国</td>
<td>勒萨日</td>
</tr>
<tr>
<td>波斯人信札</td>
<td>法国</td>
<td>孟德斯鸠</td>
</tr>
<tr>
<td>查第格</td>
<td>法国</td>
<td>伏尔泰</td>
</tr>
<tr>
<td>老实人</td>
<td>法国</td>
<td>伏尔泰</td>
</tr>
<tr>
<td>玛农·列斯戈</td>
<td>法国</td>
<td>普莱服神甫</td>
</tr>
<tr>
<td><strong>新爱洛伊丝</strong></td>
<td>法国</td>
<td>卢梭</td>
</tr>
<tr>
<td>爱弥儿</td>
<td>法国</td>
<td>卢梭</td>
</tr>
<tr>
<td>拉摩的侄子</td>
<td>法国</td>
<td>狄德罗</td>
</tr>
<tr>
<td>定命论者雅克和他的主人</td>
<td>法国</td>
<td>狄德罗</td>
</tr>
<tr>
<td>阿达拉</td>
<td>法国</td>
<td>夏多布里昂</td>
</tr>
<tr>
<td><strong>阿尔芒丝</strong></td>
<td>法国</td>
<td>司汤达</td>
</tr>
<tr>
<td><strong>红与黑</strong></td>
<td>法国</td>
<td>司汤达</td>
</tr>
<tr>
<td><strong>巴马修道院</strong></td>
<td>法国</td>
<td>司汤达</td>
</tr>
<tr>
<td><strong>驴皮记</strong></td>
<td>法国</td>
<td>巴尔扎克</td>
</tr>
<tr>
<td><strong>欧也妮·葛朗台</strong></td>
<td>法国</td>
<td>巴尔扎克</td>
</tr>
<tr>
<td><strong>高老头</strong></td>
<td>法国</td>
<td>巴尔扎克</td>
</tr>
<tr>
<td><strong>幻灭</strong></td>
<td>法国</td>
<td>巴尔扎克</td>
</tr>
<tr>
<td><strong>邦斯舅舅</strong></td>
<td>法国</td>
<td>巴尔扎克</td>
</tr>
<tr>
<td><strong>三个火枪手</strong></td>
<td>法国</td>
<td>大仲马</td>
</tr>
<tr>
<td><strong>基督山恩仇记</strong></td>
<td>法国</td>
<td>大仲马</td>
</tr>
<tr>
<td><strong>巴黎圣母院</strong></td>
<td>法国</td>
<td>雨果</td>
</tr>
<tr>
<td>高龙巴</td>
<td>法国</td>
<td>梅里美</td>
</tr>
<tr>
<td>嘉尔曼</td>
<td>法国</td>
<td>梅里美</td>
</tr>
<tr>
<td>巴黎的秘密</td>
<td>法国</td>
<td>欧仁·苏</td>
</tr>
<tr>
<td><strong>安吉堡的磨工</strong></td>
<td>法国</td>
<td>乔治·桑</td>
</tr>
<tr>
<td>一个世纪的忏悔</td>
<td>法国</td>
<td>缪塞</td>
</tr>
<tr>
<td>外祖母</td>
<td>捷克</td>
<td>涅姆佐娃</td>
</tr>
<tr>
<td>癞皮鹦鹉</td>
<td>墨西哥</td>
<td>利萨尔迪</td>
</tr>
<tr>
<td>瑞普·凡·温克尔</td>
<td>美国</td>
<td>欧文</td>
</tr>
<tr>
<td>睡谷的传说</td>
<td>美国</td>
<td>欧文</td>
</tr>
<tr>
<td>最后的莫西干人</td>
<td>美国</td>
<td>库柏</td>
</tr>
<tr>
<td>杀鹿人</td>
<td>美国</td>
<td>库柏</td>
</tr>
<tr>
<td>拉帕其尼医生的女儿</td>
<td>美国</td>
<td>霍桑</td>
</tr>
<tr>
<td>红字</td>
<td>美国</td>
<td>霍桑</td>
</tr>
<tr>
<td>七个尖角顶的宅第</td>
<td>美国</td>
<td>霍桑</td>
</tr>
<tr>
<td><strong>黑猫</strong></td>
<td>美国</td>
<td>爱伦·坡</td>
</tr>
<tr>
<td><strong>厄舍府的倒塌</strong></td>
<td>美国</td>
<td>爱伦·坡</td>
</tr>
<tr>
<td><strong>毛格街血案</strong></td>
<td>美国</td>
<td>爱伦·坡</td>
</tr>
<tr>
<td><strong>汤姆叔叔的小屋</strong></td>
<td>美国</td>
<td>斯托夫人</td>
</tr>
<tr>
<td><strong>白鲸</strong></td>
<td>美国</td>
<td>麦尔维尔</td>
</tr>
<tr>
<td>竹取物语</td>
<td>日本</td>
<td>佚名</td>
</tr>
<tr>
<td>源氏物语</td>
<td>日本</td>
<td>紫式部</td>
</tr>
<tr>
<td>平家物语</td>
<td>日本</td>
<td>佚名</td>
</tr>
<tr>
<td>浮世澡堂</td>
<td>日本</td>
<td>式亭三马</td>
</tr>
<tr>
<td>绿衣亨利</td>
<td>瑞士</td>
<td>凯勒</td>
</tr>
<tr>
<td>小癞子</td>
<td>西班牙</td>
<td>佚名</td>
</tr>
<tr>
<td><strong>堂吉诃德</strong></td>
<td>西班牙</td>
<td>塞万提斯</td>
</tr>
<tr>
<td>金驴记</td>
<td>古罗马</td>
<td>阿普列乌斯</td>
</tr>
<tr>
<td><strong>十日谈</strong></td>
<td>意大利</td>
<td>卜伽丘</td>
</tr>
<tr>
<td>太阳城</td>
<td>意大利</td>
<td>康帕内拉</td>
</tr>
<tr>
<td>约婚夫妇</td>
<td>意大利</td>
<td>孟佐尼</td>
</tr>
<tr>
<td><strong>坎特伯雷故事集</strong></td>
<td>英国</td>
<td>乔叟</td>
</tr>
<tr>
<td>天路历程</td>
<td>英国</td>
<td>班扬</td>
</tr>
<tr>
<td><strong>鲁宾逊漂流记</strong></td>
<td>英国</td>
<td>笛福</td>
</tr>
<tr>
<td><strong>格列佛游记</strong></td>
<td>英国</td>
<td>斯威夫特</td>
</tr>
<tr>
<td>帕梅拉</td>
<td>英国</td>
<td>理查森</td>
</tr>
<tr>
<td>大伟人江奈生·魏尔德传</td>
<td>英国</td>
<td>菲尔丁</td>
</tr>
<tr>
<td>汤姆·琼斯</td>
<td>英国</td>
<td>菲尔丁</td>
</tr>
<tr>
<td>感伤的旅程</td>
<td>英国</td>
<td>斯特恩</td>
</tr>
<tr>
<td>蓝登传</td>
<td>英国</td>
<td>斯摩莱特</td>
</tr>
<tr>
<td>威克菲牧师传</td>
<td>英国</td>
<td>哥尔斯密</td>
</tr>
<tr>
<td>爱丁堡监狱</td>
<td>英国</td>
<td>司各特</td>
</tr>
<tr>
<td>艾凡赫</td>
<td>英国</td>
<td>司各特</td>
</tr>
<tr>
<td><strong>理智与情感</strong></td>
<td>英国</td>
<td>奥斯丁</td>
</tr>
<tr>
<td><strong>傲慢与偏见</strong></td>
<td>英国</td>
<td>奥斯丁</td>
</tr>
<tr>
<td><strong>爱玛</strong></td>
<td>英国</td>
<td>奥斯丁</td>
</tr>
<tr>
<td>玛丽·巴顿</td>
<td>英国</td>
<td>盖斯凯尔夫人</td>
</tr>
<tr>
<td><strong>名利场</strong></td>
<td>英国</td>
<td>萨克雷</td>
</tr>
<tr>
<td>钮可谟一家</td>
<td>英国</td>
<td>李敦</td>
</tr>
<tr>
<td><strong>庞贝城的末日</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>匹克维克外传</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>雾都孤儿</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>老古玩店</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>大卫·考坡菲</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>简·爱</strong></td>
<td>英国</td>
<td>夏洛蒂·勃朗特</td>
</tr>
<tr>
<td><strong>呼啸山庄</strong></td>
<td>英国</td>
<td>艾米莉·勃朗特</td>
</tr>
</tbody></table>
<hr>
<h2 id="19世纪下半期卷"><a href="#19世纪下半期卷" class="headerlink" title="19世纪下半期卷"></a>19世纪下半期卷</h2><table>
<thead>
<tr>
<th>书名</th>
<th>国籍</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>为了面包</td>
<td>波兰</td>
<td>显克微支</td>
</tr>
<tr>
<td>火与剑</td>
<td>波兰</td>
<td>显克微支</td>
</tr>
<tr>
<td>洪流</td>
<td>波兰</td>
<td>显克微支</td>
</tr>
<tr>
<td>十字军骑士</td>
<td>波兰</td>
<td>显克微支</td>
</tr>
<tr>
<td>傀儡</td>
<td>波兰</td>
<td>普鲁斯</td>
</tr>
<tr>
<td>福地</td>
<td>波兰</td>
<td>莱蒙特</td>
</tr>
<tr>
<td>三色紫罗兰</td>
<td>德国</td>
<td>史托姆</td>
</tr>
<tr>
<td>白马骑士</td>
<td>德国</td>
<td>史托姆</td>
</tr>
<tr>
<td>艾菲·布里斯特</td>
<td>德国</td>
<td>冯塔纳</td>
</tr>
<tr>
<td>奥勃洛摩夫</td>
<td>俄国</td>
<td>冈察洛夫</td>
</tr>
<tr>
<td>悬崖</td>
<td>俄国</td>
<td>冈察洛夫</td>
</tr>
<tr>
<td>罗亭</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td>贵族之家</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td>前夜</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td>初恋</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td>父与子</td>
<td>俄国</td>
<td>屠格涅夫</td>
</tr>
<tr>
<td><strong>罪与罚</strong></td>
<td>俄国</td>
<td>陀思妥耶夫斯基</td>
</tr>
<tr>
<td><strong>白痴</strong></td>
<td>俄国</td>
<td>陀思妥耶夫斯基</td>
</tr>
<tr>
<td><strong>群魔</strong></td>
<td>俄国</td>
<td>陀思妥耶夫斯基</td>
</tr>
<tr>
<td><strong>卡拉马佐夫兄弟</strong></td>
<td>俄国</td>
<td>陀思妥耶夫斯基</td>
</tr>
<tr>
<td>怎么办？</td>
<td>俄国</td>
<td>车尔尼雪夫斯基</td>
</tr>
<tr>
<td>琉森</td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td>哥萨克</td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td><strong>战争与和平</strong></td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td><strong>安娜·卡列尼娜</strong></td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td>伊万·伊利奇之死</td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td><strong>复活</strong></td>
<td>俄国</td>
<td>列夫·托尔斯泰</td>
</tr>
<tr>
<td>大堂神父</td>
<td>俄国</td>
<td>列斯科夫</td>
</tr>
<tr>
<td>左撇子</td>
<td>俄国</td>
<td>列斯科夫</td>
</tr>
<tr>
<td>盲音乐家</td>
<td>俄国</td>
<td>柯罗连科</td>
</tr>
<tr>
<td>棕榈</td>
<td>俄国</td>
<td>迦尔洵</td>
</tr>
<tr>
<td><strong>变色龙</strong></td>
<td>俄国</td>
<td>契诃夫</td>
</tr>
<tr>
<td><strong>苦恼</strong></td>
<td>俄国</td>
<td>契诃夫</td>
</tr>
<tr>
<td><strong>草原</strong></td>
<td>俄国</td>
<td>契诃夫</td>
</tr>
<tr>
<td><strong>第六病室</strong></td>
<td>俄国</td>
<td>契诃夫</td>
</tr>
<tr>
<td><strong>装在套子里的人</strong></td>
<td>俄国</td>
<td>契诃夫</td>
</tr>
<tr>
<td><strong>悲惨世界</strong></td>
<td>法国</td>
<td>雨果</td>
</tr>
<tr>
<td><strong>海上劳工</strong></td>
<td>法国</td>
<td>雨果</td>
</tr>
<tr>
<td><strong>笑面人</strong></td>
<td>法国</td>
<td>雨果</td>
</tr>
<tr>
<td><strong>九三年</strong></td>
<td>法国</td>
<td>雨果</td>
</tr>
<tr>
<td><strong>包法利夫人</strong></td>
<td>法国</td>
<td>福楼拜</td>
</tr>
<tr>
<td>萨朗波</td>
<td>法国</td>
<td>福楼拜</td>
</tr>
<tr>
<td>情感教育</td>
<td>法国</td>
<td>福楼拜</td>
</tr>
<tr>
<td><strong>格兰特船长的儿女</strong></td>
<td>法国</td>
<td>凡尔纳</td>
</tr>
<tr>
<td>起义者</td>
<td>法国</td>
<td>瓦莱斯</td>
</tr>
<tr>
<td>小酒店</td>
<td>法国</td>
<td>左拉</td>
</tr>
<tr>
<td>萌芽</td>
<td>法国</td>
<td>左拉</td>
</tr>
<tr>
<td>金钱</td>
<td>法国</td>
<td>左拉</td>
</tr>
<tr>
<td>小东西</td>
<td>法国</td>
<td>都德</td>
</tr>
<tr>
<td>最后一课</td>
<td>法国</td>
<td>都德</td>
</tr>
<tr>
<td>苔依丝</td>
<td>法国</td>
<td>法郎士</td>
</tr>
<tr>
<td><strong>羊脂球</strong></td>
<td>法国</td>
<td>莫泊桑</td>
</tr>
<tr>
<td><strong>一生</strong></td>
<td>法国</td>
<td>莫泊桑</td>
</tr>
<tr>
<td><strong>我的叔叔于勒</strong></td>
<td>法国</td>
<td>莫泊桑</td>
</tr>
<tr>
<td><strong>项链</strong></td>
<td>法国</td>
<td>莫泊桑</td>
</tr>
<tr>
<td><strong>漂亮朋友</strong></td>
<td>法国</td>
<td>莫泊桑</td>
</tr>
<tr>
<td>起义者</td>
<td>菲律宾</td>
<td>黎萨尔</td>
</tr>
<tr>
<td>玛丽亚</td>
<td>哥伦比亚</td>
<td>伊萨克斯</td>
</tr>
<tr>
<td>马格斯·哈弗拉尔</td>
<td>荷兰</td>
<td>穆尔塔图里</td>
</tr>
<tr>
<td>野姑娘芭拉</td>
<td>捷克</td>
<td>聂姆佐娃</td>
</tr>
<tr>
<td>庄园内外</td>
<td>捷克</td>
<td>聂姆佐娃</td>
</tr>
<tr>
<td>竞选州长</td>
<td>美国</td>
<td>马克·吐温</td>
</tr>
<tr>
<td><strong>汤姆·索亚历险记</strong></td>
<td>美国</td>
<td>马克·吐温</td>
</tr>
<tr>
<td><strong>王子与贫儿</strong></td>
<td>美国</td>
<td>马克·吐温</td>
</tr>
<tr>
<td>哈克贝里·芬历险记</td>
<td>美国</td>
<td>马克·吐温</td>
</tr>
<tr>
<td>塞拉斯·拉帕姆的发迹</td>
<td>美国</td>
<td>豪威尔斯</td>
</tr>
<tr>
<td>黛西·米勒</td>
<td>美国</td>
<td>詹姆斯</td>
</tr>
<tr>
<td>一位女士的画像</td>
<td>美国</td>
<td>詹姆斯</td>
</tr>
<tr>
<td>嘉莉妹妹</td>
<td>美国</td>
<td>德莱塞</td>
</tr>
<tr>
<td>饥饿</td>
<td>挪威</td>
<td>汉姆生</td>
</tr>
<tr>
<td>阿马罗神父的罪恶</td>
<td>葡萄牙</td>
<td>克罗兹</td>
</tr>
<tr>
<td>舞姬</td>
<td>日本</td>
<td>森鸥外</td>
</tr>
<tr>
<td>浮云</td>
<td>日本</td>
<td>二叶亭四迷</td>
</tr>
<tr>
<td>慈悲心肠</td>
<td>西班牙</td>
<td>佩雷斯·加尔多斯</td>
</tr>
<tr>
<td>庭长夫人</td>
<td>西班牙</td>
<td>克拉林</td>
</tr>
<tr>
<td>金人</td>
<td>匈牙利</td>
<td>约卡伊·莫尔</td>
</tr>
<tr>
<td>圣彼得的伞</td>
<td>匈牙利</td>
<td>米克沙特·卡尔曼</td>
</tr>
<tr>
<td>奇婚记</td>
<td>匈牙利</td>
<td>米克沙特·卡尔曼</td>
</tr>
<tr>
<td><strong>斯巴达克思</strong></td>
<td>意大利</td>
<td>乔万尼奥里</td>
</tr>
<tr>
<td>女乞丐</td>
<td>印度</td>
<td>泰戈尔</td>
</tr>
<tr>
<td>饥饿的石头</td>
<td>印度</td>
<td>泰戈尔</td>
</tr>
<tr>
<td>妻子和女儿</td>
<td>英国</td>
<td>盖斯凯尔夫人</td>
</tr>
<tr>
<td><strong>艰难时世</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>双城记</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>远大前程</strong></td>
<td>英国</td>
<td>狄更斯</td>
</tr>
<tr>
<td><strong>教师</strong></td>
<td>英国</td>
<td>夏洛蒂·勃朗特</td>
</tr>
<tr>
<td>亚当·贝德</td>
<td>英国</td>
<td>乔治·艾略特</td>
</tr>
<tr>
<td>佛洛斯河磨坊</td>
<td>英国</td>
<td>乔治·艾略特</td>
</tr>
<tr>
<td>织工马南转</td>
<td>英国</td>
<td>乔治·艾略特</td>
</tr>
<tr>
<td>米德尔马契</td>
<td>英国</td>
<td>乔治·艾略特</td>
</tr>
<tr>
<td><strong>远离尘嚣</strong></td>
<td>英国</td>
<td>哈代</td>
</tr>
<tr>
<td><strong>还乡</strong></td>
<td>英国</td>
<td>哈代</td>
</tr>
<tr>
<td><strong>卡斯特桥市长</strong></td>
<td>英国</td>
<td>哈代</td>
</tr>
<tr>
<td><strong>德伯家的苔丝</strong></td>
<td>英国</td>
<td>哈代</td>
</tr>
<tr>
<td><strong>无名的裘德</strong></td>
<td>英国</td>
<td>哈代</td>
</tr>
<tr>
<td>化身博士</td>
<td>英国</td>
<td>斯蒂文森</td>
</tr>
<tr>
<td>诱拐</td>
<td>英国</td>
<td>斯蒂文森</td>
</tr>
<tr>
<td>金银岛</td>
<td>英国</td>
<td>斯蒂文森</td>
</tr>
<tr>
<td><strong>道林·格雷的画像</strong></td>
<td>英国</td>
<td>王尔德</td>
</tr>
<tr>
<td>黑暗的心</td>
<td>英国</td>
<td>康拉德</td>
</tr>
<tr>
<td>吉姆爷</td>
<td>英国</td>
<td>康拉德</td>
</tr>
<tr>
<td>牛虻</td>
<td>英国</td>
<td>伏尼契</td>
</tr>
<tr>
<td>丛林故事</td>
<td>英国</td>
<td>吉卜林</td>
</tr>
<tr>
<td>时间机器</td>
<td>英国</td>
<td>威尔斯</td>
</tr>
<tr>
<td>马丁·里瓦斯</td>
<td>智利</td>
<td>布莱斯特·加纳</td>
</tr>
</tbody></table>
<hr>
<h2 id="20世纪前期卷"><a href="#20世纪前期卷" class="headerlink" title="20世纪前期卷"></a>20世纪前期卷</h2><table>
<thead>
<tr>
<th>书名</th>
<th>国籍</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>都柏林人</td>
<td>爱尔兰</td>
<td>乔伊斯</td>
</tr>
<tr>
<td>一个青年艺术家的画像</td>
<td>爱尔兰</td>
<td>乔伊斯</td>
</tr>
<tr>
<td>尤利西斯</td>
<td>爱尔兰</td>
<td>乔伊斯</td>
</tr>
<tr>
<td><strong>一个陌生女人的来信</strong></td>
<td>奥地利</td>
<td>茨威格</td>
</tr>
<tr>
<td><strong>变形记</strong></td>
<td>奥地利</td>
<td>卡夫卡</td>
</tr>
<tr>
<td><strong>饥饿艺术家</strong></td>
<td>奥地利</td>
<td>卡夫卡</td>
</tr>
<tr>
<td><strong>城堡</strong></td>
<td>奥地利</td>
<td>卡夫卡</td>
</tr>
<tr>
<td><strong>地洞</strong></td>
<td>奥地利</td>
<td>卡夫卡</td>
</tr>
<tr>
<td>农民</td>
<td>波兰</td>
<td>莱蒙特</td>
</tr>
<tr>
<td>征服者贝莱</td>
<td>丹麦</td>
<td>尼克索</td>
</tr>
<tr>
<td>垃圾教授</td>
<td>德国</td>
<td>亨利希·曼</td>
</tr>
<tr>
<td>臣仆</td>
<td>德国</td>
<td>亨利希·曼</td>
</tr>
<tr>
<td>布登勃洛克一家</td>
<td>德国</td>
<td>托马斯·曼</td>
</tr>
<tr>
<td>死于威尼斯</td>
<td>德国</td>
<td>托马斯·曼</td>
</tr>
<tr>
<td>魔山</td>
<td>德国</td>
<td>托马斯·曼</td>
</tr>
<tr>
<td>荒原狼</td>
<td>德国</td>
<td>黑塞</td>
</tr>
<tr>
<td>纳尔齐斯与歌尔德蒙</td>
<td>德国</td>
<td>黑塞</td>
</tr>
<tr>
<td>柏林，亚历山大广场</td>
<td>德国</td>
<td>德布林</td>
</tr>
<tr>
<td><strong>西线无战事</strong></td>
<td>德国</td>
<td>雷马克</td>
</tr>
<tr>
<td>《基督与反基督》三部曲</td>
<td>俄国</td>
<td>梅列日科夫斯基</td>
</tr>
<tr>
<td>决斗</td>
<td>俄国</td>
<td>库普林</td>
</tr>
<tr>
<td>石榴石手镯</td>
<td>俄国</td>
<td>库普林</td>
</tr>
<tr>
<td>乡村</td>
<td>俄国</td>
<td>布宁</td>
</tr>
<tr>
<td>阿尔谢尼耶夫的一生</td>
<td>俄国</td>
<td>布宁</td>
</tr>
<tr>
<td>红笑</td>
<td>俄国</td>
<td>安德烈耶夫</td>
</tr>
<tr>
<td>七个被绞死者的故事</td>
<td>俄国</td>
<td>安德烈耶夫</td>
</tr>
<tr>
<td>企鹅岛</td>
<td>法国</td>
<td>法郎士</td>
</tr>
<tr>
<td>诸神渴了</td>
<td>法国</td>
<td>法郎士</td>
</tr>
<tr>
<td><strong>约翰·克里斯朵夫</strong></td>
<td>法国</td>
<td>罗曼·罗兰</td>
</tr>
<tr>
<td>母与子</td>
<td>法国</td>
<td>罗曼·罗兰</td>
</tr>
<tr>
<td>伪币制造者</td>
<td>法国</td>
<td>纪德</td>
</tr>
<tr>
<td><strong>追寻逝去的时光</strong></td>
<td>法国</td>
<td>普鲁斯特</td>
</tr>
<tr>
<td>火线-一个步兵班的日记</td>
<td>法国</td>
<td>巴比塞</td>
</tr>
<tr>
<td>苔蕾丝·德斯盖鲁</td>
<td>法国</td>
<td>莫里亚克</td>
</tr>
<tr>
<td>旋涡</td>
<td>哥伦比亚</td>
<td>里维拉</td>
</tr>
<tr>
<td><strong>好兵帅克</strong></td>
<td>捷克</td>
<td>哈谢克</td>
</tr>
<tr>
<td>折断的翅膀</td>
<td>黎巴嫩</td>
<td>纪伯伦</td>
</tr>
<tr>
<td><strong>麦琪的礼物</strong></td>
<td>美国</td>
<td>欧·亨利</td>
</tr>
<tr>
<td><strong>最后一片叶子</strong></td>
<td>美国</td>
<td>欧·亨利</td>
</tr>
<tr>
<td>章鱼</td>
<td>美国</td>
<td>诺里斯</td>
</tr>
<tr>
<td>珍尼姑娘</td>
<td>美国</td>
<td>德莱塞</td>
</tr>
<tr>
<td>美国悲剧</td>
<td>美国</td>
<td>德莱塞</td>
</tr>
<tr>
<td>啊，拓荒者！</td>
<td>美国</td>
<td>凯瑟</td>
</tr>
<tr>
<td>荒野的呼唤</td>
<td>美国</td>
<td>杰克·伦敦</td>
</tr>
<tr>
<td>小城畸人</td>
<td>美国</td>
<td>杰克·伦敦</td>
</tr>
<tr>
<td><strong>了不起的盖茨比</strong></td>
<td>美国</td>
<td>菲茨杰拉德</td>
</tr>
<tr>
<td>喧哗与骚动</td>
<td>美国</td>
<td>福克纳</td>
</tr>
<tr>
<td>我弥留之际</td>
<td>美国</td>
<td>福克纳</td>
</tr>
<tr>
<td>太阳照常升起</td>
<td>美国</td>
<td>海明威</td>
</tr>
<tr>
<td>永别了，武器</td>
<td>美国</td>
<td>海明威</td>
</tr>
<tr>
<td>情侣</td>
<td>缅甸</td>
<td>詹姆斯拉觉</td>
</tr>
<tr>
<td>劳伦斯之女克里斯丁</td>
<td>挪威</td>
<td>温塞特</td>
</tr>
<tr>
<td><strong>我是猫</strong></td>
<td>日本</td>
<td>夏目漱石</td>
</tr>
<tr>
<td>棉被</td>
<td>日本</td>
<td>田山花袋</td>
</tr>
<tr>
<td>破戒</td>
<td>日本</td>
<td>岛崎藤村</td>
</tr>
<tr>
<td>新珠</td>
<td>日本</td>
<td>菊池宽</td>
</tr>
<tr>
<td>罗生门</td>
<td>日本</td>
<td>芥川龙之介</td>
</tr>
<tr>
<td>橘子</td>
<td>日本</td>
<td>芥川龙之介</td>
</tr>
<tr>
<td>竹林中</td>
<td>日本</td>
<td>芥川龙之介</td>
</tr>
<tr>
<td>太阳</td>
<td>日本</td>
<td>横光利一</td>
</tr>
<tr>
<td>没有太阳的街</td>
<td>日本</td>
<td>德永直</td>
</tr>
<tr>
<td>蟹工船</td>
<td>日本</td>
<td>小林多喜二</td>
</tr>
<tr>
<td>雅考伯·冯·贡腾</td>
<td>瑞士</td>
<td>罗伯特·瓦尔泽</td>
</tr>
<tr>
<td>母亲</td>
<td>苏联</td>
<td>高尔基</td>
</tr>
<tr>
<td>奥库罗夫镇</td>
<td>苏联</td>
<td>高尔基</td>
</tr>
<tr>
<td>阿尔塔莫诺夫家的事业</td>
<td>苏联</td>
<td>高尔基</td>
</tr>
<tr>
<td>彼得堡</td>
<td>苏联</td>
<td>别雷</td>
</tr>
<tr>
<td><strong>我们</strong></td>
<td>苏联</td>
<td>扎米亚京</td>
</tr>
<tr>
<td>孽卵</td>
<td>苏联</td>
<td>布尔加科夫</td>
</tr>
<tr>
<td>狗心</td>
<td>苏联</td>
<td>布尔加科夫</td>
</tr>
<tr>
<td>第四十一</td>
<td>苏联</td>
<td>拉夫列尼约夫</td>
</tr>
<tr>
<td>基坑</td>
<td>苏联</td>
<td>普拉东诺夫</td>
</tr>
<tr>
<td>伊斯坦布尔的姑娘</td>
<td>土耳其</td>
<td>君泰金</td>
</tr>
<tr>
<td>堂娜芭芭拉</td>
<td>委内瑞拉</td>
<td>加列戈斯</td>
</tr>
<tr>
<td>迷雾</td>
<td>西班牙</td>
<td>乌纳穆诺</td>
</tr>
<tr>
<td>碧血黄沙</td>
<td>西班牙</td>
<td>布拉斯科·伊巴涅斯</td>
</tr>
<tr>
<td>孤独者</td>
<td>意大利</td>
<td>皮兰德娄</td>
</tr>
<tr>
<td>坛子</td>
<td>意大利</td>
<td>皮兰德娄</td>
</tr>
<tr>
<td>已故的帕斯卡尔</td>
<td>意大利</td>
<td>皮兰德娄</td>
</tr>
<tr>
<td>沉船</td>
<td>印度</td>
<td>泰戈尔</td>
</tr>
<tr>
<td>戈拉</td>
<td>印度</td>
<td>泰戈尔</td>
</tr>
<tr>
<td>斯里甘特</td>
<td>印度</td>
<td>查特吉</td>
</tr>
<tr>
<td>仁爱道院</td>
<td>印度</td>
<td>普列姆昌德</td>
</tr>
<tr>
<td>半斤小麦</td>
<td>印度</td>
<td>普列姆昌德</td>
</tr>
<tr>
<td>有产业的人</td>
<td>英国</td>
<td>高尔斯华绥</td>
</tr>
<tr>
<td>穿破裤子的慈善家</td>
<td>英国</td>
<td>特莱赛尔</td>
</tr>
<tr>
<td><strong>人生的枷锁</strong></td>
<td>英国</td>
<td>毛姆</td>
</tr>
<tr>
<td>看得见风景房间</td>
<td>英国</td>
<td>福斯特</td>
</tr>
<tr>
<td>印度之行</td>
<td>英国</td>
<td>福斯特</td>
</tr>
<tr>
<td>密林中的村庄</td>
<td>英国</td>
<td>伦纳德·伍尔夫</td>
</tr>
<tr>
<td>达洛卫夫人</td>
<td>英国</td>
<td>弗吉尼亚·伍尔夫</td>
</tr>
<tr>
<td>到灯塔去</td>
<td>英国</td>
<td>弗吉尼亚·伍尔夫</td>
</tr>
<tr>
<td><strong>儿子与情人</strong></td>
<td>英国</td>
<td>劳伦斯</td>
</tr>
<tr>
<td><strong>虹</strong></td>
<td>英国</td>
<td>劳伦斯</td>
</tr>
<tr>
<td>查泰莱夫人的情人</td>
<td>英国</td>
<td>劳伦斯</td>
</tr>
</tbody></table>
<hr>
<h2 id="20世纪中期卷"><a href="#20世纪中期卷" class="headerlink" title="20世纪中期卷"></a>20世纪中期卷</h2><table>
<thead>
<tr>
<th>书名</th>
<th>国籍</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>小径分岔的花园</td>
<td>阿根廷</td>
<td>博尔赫斯</td>
</tr>
<tr>
<td>环形废墟</td>
<td>阿根廷</td>
<td>博尔赫斯</td>
</tr>
<tr>
<td>人树</td>
<td>澳大利亚</td>
<td>怀特</td>
</tr>
<tr>
<td>一杯茶</td>
<td>澳大利亚</td>
<td>怀特</td>
</tr>
<tr>
<td><strong>象棋的故事</strong></td>
<td>奥地利</td>
<td>茨威格</td>
</tr>
<tr>
<td>无边的土地</td>
<td>巴西</td>
<td>亚马多</td>
</tr>
<tr>
<td>绿蒂在魏玛</td>
<td>德国</td>
<td>托马斯·曼</td>
</tr>
<tr>
<td>玻璃球游戏</td>
<td>德国</td>
<td>黑塞</td>
</tr>
<tr>
<td>戈雅</td>
<td>德国</td>
<td>福伊希特万格</td>
</tr>
<tr>
<td><strong>凯旋门</strong></td>
<td>德国</td>
<td>雷马克</td>
</tr>
<tr>
<td>第七个十字架</td>
<td>德国</td>
<td>西格斯</td>
</tr>
<tr>
<td>迷惘</td>
<td>德国</td>
<td>卡内蒂</td>
</tr>
<tr>
<td>小丑之见</td>
<td>德国</td>
<td>伯尔</td>
</tr>
<tr>
<td>淡漠的人</td>
<td>德国</td>
<td>伦茨</td>
</tr>
<tr>
<td>铁皮鼓</td>
<td>德国</td>
<td>格拉斯</td>
</tr>
<tr>
<td>猫与鼠</td>
<td>德国</td>
<td>格拉斯</td>
</tr>
<tr>
<td>分裂的天空</td>
<td>德国</td>
<td>沃尔夫</td>
</tr>
<tr>
<td>俄罗斯森林</td>
<td>俄罗斯</td>
<td>列昂诺夫</td>
</tr>
<tr>
<td>伊万·杰尼索维奇的一天</td>
<td>俄罗斯</td>
<td>索尔仁尼琴</td>
</tr>
<tr>
<td>癌病房</td>
<td>俄罗斯</td>
<td>索尔仁尼琴</td>
</tr>
<tr>
<td>蒂博一家</td>
<td>法国</td>
<td>马丁·杜·加尔</td>
</tr>
<tr>
<td>蛇结</td>
<td>法国</td>
<td>莫里亚克</td>
</tr>
<tr>
<td>小王子</td>
<td>法国</td>
<td>圣埃克絮佩里</td>
</tr>
<tr>
<td>人的命运</td>
<td>法国</td>
<td>马尔罗</td>
</tr>
<tr>
<td>法兰西组曲</td>
<td>法国</td>
<td>内米洛夫斯基</td>
</tr>
<tr>
<td>恶心</td>
<td>法国</td>
<td>萨特</td>
</tr>
<tr>
<td>墙</td>
<td>法国</td>
<td>萨特</td>
</tr>
<tr>
<td><strong>局外人</strong></td>
<td>法国</td>
<td>加缪</td>
</tr>
<tr>
<td><strong>鼠疫</strong></td>
<td>法国</td>
<td>加缪</td>
</tr>
<tr>
<td>弗兰德公路</td>
<td>法国</td>
<td>西蒙</td>
</tr>
<tr>
<td>琴声如诉</td>
<td>法国</td>
<td>杜拉斯</td>
</tr>
<tr>
<td>橡皮</td>
<td>法国</td>
<td>罗伯-格里耶</td>
</tr>
<tr>
<td>窥视者</td>
<td>法国</td>
<td>罗伯-格里耶</td>
</tr>
<tr>
<td>变</td>
<td>法国</td>
<td>布托尔</td>
</tr>
<tr>
<td>你好，忧愁</td>
<td>法国</td>
<td>萨冈</td>
</tr>
<tr>
<td>伊萨贝尔在马孔多观雨时的独白</td>
<td>哥伦比亚</td>
<td>马尔克斯</td>
</tr>
<tr>
<td>百年孤独</td>
<td>哥伦比亚</td>
<td>马尔克斯</td>
</tr>
<tr>
<td>消失了的足迹</td>
<td>古巴</td>
<td>卡彭铁尔</td>
</tr>
<tr>
<td>查密莉雅</td>
<td>吉尔吉斯斯坦</td>
<td>艾特玛托夫</td>
</tr>
<tr>
<td>愚人船</td>
<td>美国</td>
<td>波特</td>
</tr>
<tr>
<td>北回归线</td>
<td>美国</td>
<td>米勒</td>
</tr>
<tr>
<td>夜色温柔</td>
<td>美国</td>
<td>菲茨杰拉德</td>
</tr>
<tr>
<td>八月之光</td>
<td>美国</td>
<td>福克纳</td>
</tr>
<tr>
<td>押沙龙，押沙龙！</td>
<td>美国</td>
<td>福克纳</td>
</tr>
<tr>
<td>熊</td>
<td>美国</td>
<td>福克纳</td>
</tr>
<tr>
<td>乞力马扎罗的雪</td>
<td>美国</td>
<td>海明威</td>
</tr>
<tr>
<td><strong>老人与海</strong></td>
<td>美国</td>
<td>海明威</td>
</tr>
<tr>
<td><strong>洛丽塔</strong></td>
<td>美国</td>
<td>博纳科夫</td>
</tr>
<tr>
<td>市场街的斯宾诺莎</td>
<td>美国</td>
<td>辛格</td>
</tr>
<tr>
<td>店员</td>
<td>美国</td>
<td>马拉默德</td>
</tr>
<tr>
<td>魔桶</td>
<td>美国</td>
<td>马拉默德</td>
</tr>
<tr>
<td>赫索格</td>
<td>美国</td>
<td>贝娄</td>
</tr>
<tr>
<td>伤心咖啡馆之歌</td>
<td>美国</td>
<td>麦卡勒斯</td>
</tr>
<tr>
<td>麦田里的守望者</td>
<td>美国</td>
<td>塞林格</td>
</tr>
<tr>
<td>在路上</td>
<td>美国</td>
<td>凯鲁亚克</td>
</tr>
<tr>
<td>五号屠场</td>
<td>美国</td>
<td>冯内古特</td>
</tr>
<tr>
<td><strong>第二十二条军规</strong></td>
<td>美国</td>
<td>海勒</td>
</tr>
<tr>
<td>裸者与死者</td>
<td>美国</td>
<td>梅勒</td>
</tr>
<tr>
<td>好人难寻</td>
<td>美国</td>
<td>奥康纳</td>
</tr>
<tr>
<td>他们</td>
<td>美国</td>
<td>奥茨</td>
</tr>
<tr>
<td>城市与狗</td>
<td>秘鲁</td>
<td>略萨</td>
</tr>
<tr>
<td>最明净的地区</td>
<td>墨西哥</td>
<td>富恩特斯</td>
</tr>
<tr>
<td>诺言</td>
<td>瑞士</td>
<td>迪伦马特</td>
</tr>
<tr>
<td>细雪</td>
<td>日本</td>
<td>谷崎润一郎</td>
</tr>
<tr>
<td>上海</td>
<td>日本</td>
<td>横光利一</td>
</tr>
<tr>
<td>来到农村的文工队</td>
<td>日本</td>
<td>德永直</td>
</tr>
<tr>
<td><strong>雪国</strong></td>
<td>日本</td>
<td>川端康成</td>
</tr>
<tr>
<td>睡美人</td>
<td>日本</td>
<td>川端康成</td>
</tr>
<tr>
<td>“帝国银行事件”之谜</td>
<td>日本</td>
<td>松本清账</td>
</tr>
<tr>
<td>西阵之蝶</td>
<td>日本</td>
<td>水上勉</td>
</tr>
<tr>
<td>骏河夫人</td>
<td>日本</td>
<td>司马辽太郎</td>
</tr>
<tr>
<td>潮骚</td>
<td>日本</td>
<td>三岛由纪夫</td>
</tr>
<tr>
<td>金阁寺</td>
<td>日本</td>
<td>三岛由纪夫</td>
</tr>
<tr>
<td>黑衣</td>
<td>日本</td>
<td>有吉佐和子</td>
</tr>
<tr>
<td>饲育</td>
<td>日本</td>
<td>大江健三郎</td>
</tr>
<tr>
<td>万延元年的足球</td>
<td>日本</td>
<td>大江健三郎</td>
</tr>
<tr>
<td>苦难的历程</td>
<td>苏联</td>
<td>阿列克赛·托尔斯泰</td>
</tr>
<tr>
<td><strong>日瓦戈医生</strong></td>
<td>苏联</td>
<td>帕斯捷尔纳克</td>
</tr>
<tr>
<td><strong>大师和玛格丽特</strong></td>
<td>苏联</td>
<td>布尔加科夫</td>
</tr>
<tr>
<td>静静的顿河</td>
<td>苏联</td>
<td>肖洛霍夫</td>
</tr>
<tr>
<td>一个人的遭遇</td>
<td>苏联</td>
<td>肖洛霍夫</td>
</tr>
<tr>
<td>基督的最后诱惑</td>
<td>希腊</td>
<td>卡赞扎基斯</td>
</tr>
<tr>
<td>房间与街道</td>
<td>意大利</td>
<td>摩拉维亚</td>
</tr>
<tr>
<td>分成两半的子爵</td>
<td>意大利</td>
<td>卡尔维诺</td>
</tr>
<tr>
<td><strong>刀锋</strong></td>
<td>英国</td>
<td>毛姆</td>
</tr>
<tr>
<td>海浪</td>
<td>英国</td>
<td>伍尔夫</td>
</tr>
<tr>
<td>美妙的新世界</td>
<td>英国</td>
<td>赫胥黎</td>
</tr>
<tr>
<td>城堡</td>
<td>英国</td>
<td>克罗宁</td>
</tr>
<tr>
<td><strong>一九八四</strong></td>
<td>英国</td>
<td>奥威尔</td>
</tr>
<tr>
<td>问题的核心</td>
<td>英国</td>
<td>格林</td>
</tr>
<tr>
<td>蝇王</td>
<td>英国</td>
<td>戈尔丁</td>
</tr>
<tr>
<td>发条橙</td>
<td>英国</td>
<td>伯吉斯</td>
</tr>
<tr>
<td>沙堡</td>
<td>英国</td>
<td>默多克</td>
</tr>
<tr>
<td>金色笔记</td>
<td>英国</td>
<td>莱辛</td>
</tr>
<tr>
<td>幸运的吉姆</td>
<td>英国</td>
<td>艾米斯</td>
</tr>
<tr>
<td>法国中尉的女人</td>
<td>英国</td>
<td>福尔斯</td>
</tr>
<tr>
<td>戈丹</td>
<td>印度</td>
<td>普列姆昌德</td>
</tr>
<tr>
<td>黑水洋彼岸</td>
<td>印度</td>
<td>安纳德</td>
</tr>
</tbody></table>
<hr>
<h2 id="20世纪后期卷"><a href="#20世纪后期卷" class="headerlink" title="20世纪后期卷"></a>20世纪后期卷</h2><table>
<thead>
<tr>
<th>书名</th>
<th>国籍</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>蜘蛛女之吻</td>
<td>阿根廷</td>
<td>普伊格</td>
</tr>
<tr>
<td>平民史诗</td>
<td>埃及</td>
<td>马哈福兹</td>
</tr>
<tr>
<td>风暴眼</td>
<td>澳大利亚</td>
<td>怀特</td>
</tr>
<tr>
<td>美好的美好的时光</td>
<td>奥地利</td>
<td>耶利内克</td>
</tr>
<tr>
<td>钢琴教师</td>
<td>奥地利</td>
<td>耶利内克</td>
</tr>
<tr>
<td>情欲</td>
<td>奥地利</td>
<td>耶利内克</td>
</tr>
<tr>
<td>浪女回归</td>
<td>巴西</td>
<td>亚马多</td>
</tr>
<tr>
<td>我坐在彼得拉河畔哭泣</td>
<td>巴西</td>
<td>科埃略</td>
</tr>
<tr>
<td>韦罗妮卡决定去死</td>
<td>巴西</td>
<td>科埃略</td>
</tr>
<tr>
<td>方尖碑</td>
<td>白俄罗斯</td>
<td>贝科夫</td>
</tr>
<tr>
<td>战争中没有女性</td>
<td>白俄罗斯</td>
<td>阿列克茜叶维契</td>
</tr>
<tr>
<td>惊马奔逃</td>
<td>德国</td>
<td>瓦尔泽</td>
</tr>
<tr>
<td>我的世纪</td>
<td>德国</td>
<td>格拉斯</td>
</tr>
<tr>
<td>献词</td>
<td>德国</td>
<td>施特劳斯</td>
</tr>
<tr>
<td>香水-一个谋杀犯的故事</td>
<td>德国</td>
<td>聚斯金德</td>
</tr>
<tr>
<td>白比姆黑耳朵</td>
<td>俄罗斯</td>
<td>特罗耶波尔斯基</td>
</tr>
<tr>
<td>一幅画</td>
<td>俄罗斯</td>
<td>格拉宁</td>
</tr>
<tr>
<td>永远十九岁</td>
<td>俄罗斯</td>
<td>巴拉克诺夫</td>
</tr>
<tr>
<td>百慕大三角</td>
<td>俄罗斯</td>
<td>邦达列夫</td>
</tr>
<tr>
<td>鱼王</td>
<td>俄罗斯</td>
<td>阿斯塔菲耶夫</td>
</tr>
<tr>
<td>被取消的演出</td>
<td>俄罗斯</td>
<td>奥库扎瓦</td>
</tr>
<tr>
<td>活下去，并且要记住</td>
<td>俄罗斯</td>
<td>拉斯普京</td>
</tr>
<tr>
<td>告别马焦拉</td>
<td>俄罗斯</td>
<td>拉斯普京</td>
</tr>
<tr>
<td>命运线</td>
<td>俄罗斯</td>
<td>哈里托诺夫</td>
</tr>
<tr>
<td>书市上的斯薇特兰娜</td>
<td>俄罗斯</td>
<td>马卡宁</td>
</tr>
<tr>
<td>美狄娅和她的孩子们</td>
<td>俄罗斯</td>
<td>乌利茨卡娅</td>
</tr>
<tr>
<td>夏伯阳与虚空</td>
<td>俄罗斯</td>
<td>佩列文</td>
</tr>
<tr>
<td>乡间的房子</td>
<td>俄罗斯</td>
<td>瓦尔拉莫夫</td>
</tr>
<tr>
<td>暗店街</td>
<td>法国</td>
<td>莫迪亚诺</td>
</tr>
<tr>
<td>我走了</td>
<td>法国</td>
<td>艾什诺兹</td>
</tr>
<tr>
<td>流浪的星星</td>
<td>法国</td>
<td>克莱齐奥</td>
</tr>
<tr>
<td><strong>霍乱时期的爱情</strong></td>
<td>哥伦比亚</td>
<td>马尔克斯</td>
</tr>
<tr>
<td>乙火</td>
<td>韩国</td>
<td>金东里</td>
</tr>
<tr>
<td>一日长于百年</td>
<td>吉尔吉斯斯坦</td>
<td>艾特玛托夫</td>
</tr>
<tr>
<td>断头台</td>
<td>吉尔吉斯斯坦</td>
<td>艾特玛托夫</td>
</tr>
<tr>
<td>斯通家史札记</td>
<td>加拿大</td>
<td>希尔兹</td>
</tr>
<tr>
<td>笑忘录</td>
<td>捷克</td>
<td>昆拉德</td>
</tr>
<tr>
<td><strong>不能承受的生命之轻</strong></td>
<td>捷克</td>
<td>昆拉德</td>
</tr>
<tr>
<td>冤家，一个爱情故事</td>
<td>美国</td>
<td>辛格</td>
</tr>
<tr>
<td>童爱</td>
<td>美国</td>
<td>辛格</td>
</tr>
<tr>
<td>杜宾的传记</td>
<td>美国</td>
<td>马拉默德</td>
</tr>
<tr>
<td>洪堡的礼物</td>
<td>美国</td>
<td>贝娄</td>
</tr>
<tr>
<td>更多的人死于心碎</td>
<td>美国</td>
<td>贝娄</td>
</tr>
<tr>
<td>时震</td>
<td>美国</td>
<td>冯内古特</td>
</tr>
<tr>
<td>刽子手之歌</td>
<td>美国</td>
<td>梅勒</td>
</tr>
<tr>
<td>苏菲的抉择</td>
<td>美国</td>
<td>斯泰伦</td>
</tr>
<tr>
<td>情欲艺术家</td>
<td>美国</td>
<td>霍克斯</td>
</tr>
<tr>
<td>铁草</td>
<td>美国</td>
<td>肯尼迪</td>
</tr>
<tr>
<td>最蓝的眼睛</td>
<td>美国</td>
<td>莫里森</td>
</tr>
<tr>
<td>所罗门之歌</td>
<td>美国</td>
<td>莫里森</td>
</tr>
<tr>
<td>白雪公主后传</td>
<td>美国</td>
<td>巴塞尔姆</td>
</tr>
<tr>
<td>拉格泰姆时代</td>
<td>美国</td>
<td>多克特罗</td>
</tr>
<tr>
<td>兔子回家</td>
<td>美国</td>
<td>厄普代克</td>
</tr>
<tr>
<td>变形记</td>
<td>美国</td>
<td>厄普代克</td>
</tr>
<tr>
<td>反生活</td>
<td>美国</td>
<td>罗斯</td>
</tr>
<tr>
<td>人性的污点</td>
<td>美国</td>
<td>罗斯</td>
</tr>
<tr>
<td>遗产-一个真实的故事</td>
<td>美国</td>
<td>罗斯</td>
</tr>
<tr>
<td>骏马长嘶</td>
<td>美国</td>
<td>麦卡锡</td>
</tr>
<tr>
<td>孤独鸽</td>
<td>美国</td>
<td>麦克默特里</td>
</tr>
<tr>
<td>葡萄园</td>
<td>美国</td>
<td>品钦</td>
</tr>
<tr>
<td>幽灵之家</td>
<td>美国</td>
<td>阿连德</td>
</tr>
<tr>
<td>不规则飞行</td>
<td>美国</td>
<td>纳尔逊</td>
</tr>
<tr>
<td>紫色</td>
<td>美国</td>
<td>沃克</td>
</tr>
<tr>
<td>纽约女人未眠夜</td>
<td>美国</td>
<td>提尔曼</td>
</tr>
<tr>
<td>一千英亩</td>
<td>美国</td>
<td>斯迈利</td>
</tr>
<tr>
<td>时时刻刻</td>
<td>美国</td>
<td>坎宁安</td>
</tr>
<tr>
<td>达·芬奇密码</td>
<td>美国</td>
<td>布朗</td>
</tr>
<tr>
<td>神圣的夜晚</td>
<td>摩洛哥</td>
<td>杰伦</td>
</tr>
<tr>
<td>帝国轶闻</td>
<td>墨西哥</td>
<td>帕索</td>
</tr>
<tr>
<td>七月的人民</td>
<td>南非</td>
<td>戈迪默</td>
</tr>
<tr>
<td>耻</td>
<td>南非</td>
<td>库切</td>
</tr>
<tr>
<td>修道院纪事</td>
<td>葡萄牙</td>
<td>萨拉马戈</td>
</tr>
<tr>
<td>失明症漫记</td>
<td>葡萄牙</td>
<td>萨拉马戈</td>
</tr>
<tr>
<td>失乐园</td>
<td>日本</td>
<td>渡边淳一</td>
</tr>
<tr>
<td><strong>挪威的森林</strong></td>
<td>日本</td>
<td>村上春树</td>
</tr>
<tr>
<td>无限近似于透明的蓝</td>
<td>日本</td>
<td>村上龙</td>
</tr>
<tr>
<td>厨房</td>
<td>日本</td>
<td>吉本芭娜娜</td>
</tr>
<tr>
<td>印第安的最后夏天</td>
<td>瑞士</td>
<td>谢赛克斯</td>
</tr>
<tr>
<td>哈扎尔辞典</td>
<td>塞尔维亚</td>
<td>帕维奇</td>
</tr>
<tr>
<td>老人</td>
<td>苏联</td>
<td>特里丰诺夫</td>
</tr>
<tr>
<td>红莓</td>
<td>苏联</td>
<td>舒克申</td>
</tr>
<tr>
<td>我的名字叫红</td>
<td>土耳其</td>
<td>帕慕克</td>
</tr>
<tr>
<td>独裁者的葬礼</td>
<td>委内瑞拉</td>
<td>彼特里</td>
</tr>
<tr>
<td>请听清风倾诉</td>
<td>乌拉圭</td>
<td>奥内蒂</td>
</tr>
<tr>
<td>为亡灵弹奏</td>
<td>西班牙</td>
<td>塞拉</td>
</tr>
<tr>
<td>无命运的人生</td>
<td>匈牙利</td>
<td>凯尔泰斯</td>
</tr>
<tr>
<td>蓝山</td>
<td>以色列</td>
<td>沙莱夫</td>
</tr>
<tr>
<td>玫瑰的名字</td>
<td>意大利</td>
<td>埃科</td>
</tr>
<tr>
<td>阿纳泰的贝壳</td>
<td>意大利</td>
<td>斯戈隆</td>
</tr>
<tr>
<td>人性的因素</td>
<td>英国</td>
<td>格林</td>
</tr>
<tr>
<td>河湾</td>
<td>英国</td>
<td>奈保尔</td>
</tr>
<tr>
<td>抵达之谜</td>
<td>英国</td>
<td>奈保尔</td>
</tr>
<tr>
<td>来自无人地带的明信片</td>
<td>英国</td>
<td>钱伯斯</td>
</tr>
<tr>
<td>隐之书</td>
<td>英国</td>
<td>拜厄特</td>
</tr>
<tr>
<td>时间中的孩子</td>
<td>英国</td>
<td>麦克尤恩</td>
</tr>
<tr>
<td>化学</td>
<td>英国</td>
<td>斯威夫特</td>
</tr>
<tr>
<td>长日留痕</td>
<td>英国</td>
<td>石黑一雄</td>
</tr>
<tr>
<td>卑微的神灵</td>
<td>印度</td>
<td>罗易</td>
</tr>
<tr>
<td>夜阑更深</td>
<td>印度尼西亚</td>
<td>维查雅</td>
</tr>
<tr>
<td>人世间</td>
<td>印度尼西亚</td>
<td>普拉姆迪亚</td>
</tr>
<tr>
<td>旁边的花园</td>
<td>智利</td>
<td>多诺索</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Python 的一些面试题</title>
    <url>/2021/06/18/interview-python/</url>
    <content><![CDATA[<h2 id="Python-语言特性"><a href="#Python-语言特性" class="headerlink" title="Python 语言特性"></a>Python 语言特性</h2><h2 id="1-Python的函数参数传递"><a href="#1-Python的函数参数传递" class="headerlink" title="1 Python的函数参数传递"></a>1 Python的函数参数传递</h2><p>看两个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>

<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p>
<p>通过<code>id</code>来看引用<code>a</code>的内存地址可以比较理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;func_in&quot;</span>,<span class="built_in">id</span>(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;re-point&quot;</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;func_out&quot;</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>注：具体的值在不同电脑上运行时可能不同。</p>
<p>可以看到，在执行完<code>a = 2</code>之后，<code>a</code>引用中保存的值，即内存地址发生变化，由原来<code>1</code>对象的所在的地址变成了<code>2</code>这个实体对象的内存地址。</p>
<p>而第2个例子<code>a</code>引用保存的内存值就不会发生变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;func_in&quot;</span>,<span class="built_in">id</span>(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;func_out&quot;</span>,<span class="built_in">id</span>(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>

<p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)</p>
<p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p>
<p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<h2 id="2-Python中的元类-metaclass"><a href="#2-Python中的元类-metaclass" class="headerlink" title="2 Python中的元类(metaclass)"></a>2 Python中的元类(metaclass)</h2><p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<h2 id="3-staticmethod和-classmethod"><a href="#3-staticmethod和-classmethod" class="headerlink" title="3 @staticmethod和@classmethod"></a>3 @staticmethod和@classmethod</h2><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;executing foo(%s)&quot;</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;executing foo(%s,%s)&quot;</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls,x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;executing class_foo(%s,%s)&quot;</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;executing static_foo(%s)&quot;</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
<table>
<thead>
<tr>
<th align="left">\</th>
<th align="left">实例方法</th>
<th align="left">类方法</th>
<th align="left">静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a = A()</td>
<td align="left">a.foo(x)</td>
<td align="left">a.class_foo(x)</td>
<td align="left">a.static_foo(x)</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">不可用</td>
<td align="left">A.class_foo(x)</td>
<td align="left">A.static_foo(x)</td>
</tr>
</tbody></table>
<p>更多关于这个问题:</p>
<ol>
<li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li>
<li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a><h2 id="4-类变量和实例变量"><a href="#4-类变量和实例变量" class="headerlink" title="4 类变量和实例变量"></a>4 类变量和实例变量</h2></li>
</ol>
<p><strong>类变量：</strong></p>
<blockquote>
<p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p>
</blockquote>
<p><strong>实例变量：</strong></p>
<blockquote>
<p>实例化之后，每个实例单独拥有的变量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num_of_instance = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Test.num_of_instance += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="built_in">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="built_in">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="built_in">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="built_in">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>

<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p>
<p>可以看看下面的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>

<p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<h2 id="5-Python自省"><a href="#5-Python自省" class="headerlink" title="5 Python自省"></a>5 Python自省</h2><p>这个也是python彪悍的特性.</p>
<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a),<span class="built_in">type</span>(b),<span class="built_in">type</span>(c) <span class="comment"># &lt;type &#x27;list&#x27;&gt; &lt;type &#x27;dict&#x27;&gt; &lt;type &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">isinstance</span>(a,<span class="built_in">list</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="6-字典推导式"><a href="#6-字典推导式" class="headerlink" title="6 字典推导式"></a>6 字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Python中单下划线和双下划线"><a href="#7-Python中单下划线和双下划线" class="headerlink" title="7 Python中单下划线和双下划线"></a>7 Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">&quot;, world!&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">&#x27;__superprivate&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;_MyClass__superprivate&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;_semiprivate&#x27;</span>: <span class="string">&#x27;, world!&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p>
<p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p>
<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.</p>
<p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>
<p>或者: <a href="http://www.zhihu.com/question/19754941">http://www.zhihu.com/question/19754941</a></p>
<h2 id="8-字符串格式化-和-format"><a href="#8-字符串格式化-和-format" class="headerlink" title="8 字符串格式化:%和.format"></a>8 字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure>

<p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure>

<p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p>
<p>你为什么不用它?</p>
<ul>
<li>不知道它(在读这个之前)</li>
<li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4">issue #4</a>))</li>
</ul>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<h2 id="9-迭代器和生成器"><a href="#9-迭代器和生成器" class="headerlink" title="9 迭代器和生成器"></a>9 迭代器和生成器</h2><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p>
<p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>
<p>这里有个关于生成器的创建问题面试官有考：<br>问：  将列表生成式中[]改成() 之后数据结构是否改变？<br>答案：是，从列表变为生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000028F8B774200</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p>
<h2 id="10-args-and-kwargs"><a href="#10-args-and-kwargs" class="headerlink" title="10 *args and **kwargs"></a>10 <code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p>
<p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> <span class="string">&#x27;&#123;0&#125;. &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cabbage&#x27;</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></table></figure>

<p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> <span class="string">&#x27;&#123;0&#125; = &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">&#x27;fruit&#x27;</span>, cabbage = <span class="string">&#x27;vegetable&#x27;</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure>

<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure>

<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p>
<p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;baboon&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure>

<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p>
<p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<h2 id="11-面向切面编程AOP和装饰器"><a href="#11-面向切面编程AOP和装饰器" class="headerlink" title="11 面向切面编程AOP和装饰器"></a>11 面向切面编程AOP和装饰器</h2><p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…</p>
<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p>
<p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p>
<p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<h2 id="12-鸭子类型"><a href="#12-鸭子类型" class="headerlink" title="12 鸭子类型"></a>12 鸭子类型</h2><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
<p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>
<p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p>
<p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</p>
<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不像java那样专门去弄一大堆的设计模式。</p>
<h2 id="13-Python中重载"><a href="#13-Python中重载" class="headerlink" title="13 Python中重载"></a>13 Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359">http://www.zhihu.com/question/20053359</a></p>
<p>函数重载主要是为了解决两个问题。</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h2 id="14-新式类和旧式类"><a href="#14-新式类和旧式类" class="headerlink" title="14 新式类和旧式类"></a>14 新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p>
<p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">stackoverflow</a></p>
<p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p>
<p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类继承是根据C3算法,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多.</p>
<blockquote>
<p>一个旧式类的深度优先的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br></pre></td></tr></table></figure>

<p><strong>按照经典类的查找顺序<code>从左到右深度优先</code>的规则，在访问<code>d.foo1()</code>的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过</strong></p>
<h2 id="15-new-和-init-的区别"><a href="#15-new-和-init-的区别" class="headerlink" title="15 __new__和__init__的区别"></a>15 <code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p>
<ol>
<li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li>
</ol>
<p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">stackoverflow</a></p>
<p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p>
<h2 id="16-单例模式"><a href="#16-单例模式" class="headerlink" title="16 单例模式"></a>16 单例模式</h2><blockquote>
<p>​    单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p>
</blockquote>
<h3 id="1-使用-new-方法"><a href="#1-使用-new-方法" class="headerlink" title="1 使用__new__方法"></a>1 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            orig = <span class="built_in">super</span>(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params">Singleton</span>):</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        ob = <span class="built_in">super</span>(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span>(<span class="params">Borg</span>):</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h3 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h3><p>作为python的模块是天然的单例模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><a href="http://python.jobbole.com/87294/">单例模式伯乐在线详细解释</a></strong></p>
<h2 id="17-Python中的作用域"><a href="#17-Python中的作用域" class="headerlink" title="17 Python中的作用域"></a>17 Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>
<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p>
<p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p>
<h2 id="18-GIL线程全局锁"><a href="#18-GIL线程全局锁" class="headerlink" title="18 GIL线程全局锁"></a>18 GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.<strong>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</strong></p>
<p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem">Python 最难的问题</a></p>
<p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p>
<h2 id="19-协程"><a href="#19-协程" class="headerlink" title="19 协程"></a>19 协程</h2><p>知乎被问到了,呵呵哒,跪了</p>
<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p>
<h2 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
<p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p>
<p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p>
<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p>
<h2 id="21-lambda函数"><a href="#21-lambda函数" class="headerlink" title="21 lambda函数"></a>21 lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p>
<p>推荐: <a href="http://www.zhihu.com/question/20125256">知乎</a></p>
<h2 id="22-Python函数式编程"><a href="#22-Python函数式编程" class="headerlink" title="22 Python函数式编程"></a>22 Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p>
<p>推荐: <a href="http://coolshell.cn/articles/10822.html">酷壳</a></p>
<p>python中函数式编程支持:</p>
<p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="23-Python里的拷贝"><a href="#23-Python里的拷贝" class="headerlink" title="23 Python里的拷贝"></a>23 Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)  <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;a = &#x27;</span>, a</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;b = &#x27;</span>, b</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;c = &#x27;</span>, c</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;d = &#x27;</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h2 id="24-Python垃圾回收机制"><a href="#24-Python垃圾回收机制" class="headerlink" title="24 Python垃圾回收机制"></a>24 Python垃圾回收机制</h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p>
<p>优点:</p>
<ol>
<li>简单</li>
<li>实时性</li>
</ol>
<p>缺点:</p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<h3 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<h3 id="3-分代技术"><a href="#3-分代技术" class="headerlink" title="3 分代技术"></a>3 分代技术</h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<h2 id="25-Python的List"><a href="#25-Python的List" class="headerlink" title="25 Python的List"></a>25 Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR">http://www.jianshu.com/p/J4U6rR</a></p>
<h2 id="26-Python的is"><a href="#26-Python的is" class="headerlink" title="26 Python的is"></a>26 Python的is</h2><p>is是对比地址,==是对比值</p>
<h2 id="27-read-readline和readlines"><a href="#27-read-readline和readlines" class="headerlink" title="27 read,readline和readlines"></a>27 read,readline和readlines</h2><ul>
<li>read        读取整个文件</li>
<li>readline    读取下一行,使用生成器方法</li>
<li>readlines   读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<h2 id="28-Python2和3的区别"><a href="#28-Python2和3的区别" class="headerlink" title="28 Python2和3的区别"></a>28 Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">Python 2.7.x 与 Python 3.x 的主要差异</a></p>
<h2 id="29-super-init"><a href="#29-super-init" class="headerlink" title="29 super init"></a>29 super init</h2><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p>
<p>Note that the syntax changed in Python 3.0: you can just say super().<code>__init__</code>() instead of super(ChildB, self).<code>__init__</code>() which IMO is quite a bit nicer.</p>
<p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p>
<p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440">Python2.7中的super方法浅见</a></p>
<h2 id="30-range-and-xrange"><a href="#30-range-and-xrange" class="headerlink" title="30 range and xrange"></a>30 range and xrange</h2><p>都在循环时使用，xrange内存性能更好。<br>for i in range(0, 20):<br>for i in xrange(0, 20):<br>What is the difference between range and xrange functions in Python 2.X?<br> range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.<br> xrange is a sequence object that evaluates lazily.</p>
<p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-select-poll和epoll"><a href="#1-select-poll和epoll" class="headerlink" title="1 select,poll和epoll"></a>1 select,poll和epoll</h2><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p>
<p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p>
<p><a href="http://www.cnblogs.com/Anker/p/3265058.html">selec,poll和epoll区别总结</a></p>
<p>基本上select有3个缺点:</p>
<ol>
<li>连接数受限</li>
<li>查找配对速度慢</li>
<li>数据由内核拷贝到用户态</li>
</ol>
<p>poll改善了第一个缺点</p>
<p>epoll改了三个缺点.</p>
<p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html">http://www.cnblogs.com/my_life/articles/3968782.html</a></p>
<h2 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2 调度算法"></a>2 调度算法</h2><ol>
<li>先来先服务(FCFS, First Come First Serve)</li>
<li>短作业优先(SJF, Shortest Job First)</li>
<li>最高优先权调度(Priority Scheduling)</li>
<li>时间片轮转(RR, Round Robin)</li>
<li>多级反馈队列调度(multilevel feedback queue scheduling)</li>
</ol>
<p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb">http://www.jianshu.com/p/6edf8174c1eb</a></p>
<p>实时调度算法:</p>
<ol>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>
<h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h2><p>原因:</p>
<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>
<p>必要条件:</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p>处理死锁基本方法:</p>
<ol>
<li>预防死锁(摒弃除1以外的条件)</li>
<li>避免死锁(银行家算法)</li>
<li>检测死锁(资源分配图)</li>
<li>解除死锁<ol>
<li>剥夺资源</li>
<li>撤销进程</li>
</ol>
</li>
</ol>
<p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p>
<h2 id="4-程序编译与链接"><a href="#4-程序编译与链接" class="headerlink" title="4 程序编译与链接"></a>4 程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</p>
<p>以c语言为例:</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p>
<ol>
<li>将所有的“#define”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li>
<li>删除所有注释</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。</li>
</ol>
<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p>
<h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h3><p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p>
<h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h3><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p>
<h2 id="5-静态链接和动态链接"><a href="#5-静态链接和动态链接" class="headerlink" title="5 静态链接和动态链接"></a>5 静态链接和动态链接</h2><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p>
<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p>
<h2 id="6-虚拟内存技术"><a href="#6-虚拟内存技术" class="headerlink" title="6 虚拟内存技术"></a>6 虚拟内存技术</h2><p>虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p>
<h2 id="7-分页和分段"><a href="#7-分页和分段" class="headerlink" title="7 分页和分段"></a>7 分页和分段</h2><p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>
<h3 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h3><ol>
<li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li>
<li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li>
<li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li>
</ol>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8 页面置换算法"></a>8 页面置换算法</h2><ol>
<li>最佳置换算法OPT:不可能实现</li>
<li>先进先出FIFO</li>
<li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li>
<li>clock算法</li>
</ol>
<h2 id="9-边沿触发和水平触发"><a href="#9-边沿触发和水平触发" class="headerlink" title="9 边沿触发和水平触发"></a>9 边沿触发和水平触发</h2><p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898">http://www.hollischuang.com/archives/898</a></p>
<h2 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html">http://tech.meituan.com/mysql-index.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>
<p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p>
<h2 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><ol>
<li>是一个完全开源免费的key-value内存数据库</li>
<li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li>
</ol>
<h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><blockquote>
<p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作</p>
</blockquote>
<ul>
<li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万</li>
<li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)</li>
<li>自动操作：对不同数据类型的操作都是自动的，很安全</li>
<li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。</li>
<li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ul>
<h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul>
<li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4 乐观锁和悲观锁"></a>4 乐观锁和悲观锁</h2><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p>
<h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h2><blockquote>
<p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p>
</blockquote>
<h3 id="MySQL的innodb引擎是如何实现MVCC的"><a href="#MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="MySQL的innodb引擎是如何实现MVCC的"></a><a href="http://lib.csdn.net/base/mysql">MySQL</a>的innodb引擎是如何实现MVCC的</h3><p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p>
<ul>
<li>select：满足以下两个条件innodb会返回该行数据：<ul>
<li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li>
<li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li>
</ul>
</li>
<li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li>
<li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li>
<li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li>
</ul>
<p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p>
<p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p>
<blockquote>
<p> 参考：<a href="http://blog.csdn.net/chosen0ne/article/details/18093187">MVCC浅析</a></p>
</blockquote>
<h2 id="6-MyISAM和InnoDB"><a href="#6-MyISAM和InnoDB" class="headerlink" title="6 MyISAM和InnoDB"></a>6 MyISAM和InnoDB</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211">https://segmentfault.com/a/1190000008227211</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h2><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li>
</ol>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h2><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p>
<ol>
<li>客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.</li>
<li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.</li>
<li>服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.</li>
<li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.</li>
</ol>
<p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471">http://blog.csdn.net/whuslei/article/details/6667471</a></p>
<h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h2><p>地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p>
<h2 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p>
<ol>
<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li>
</ol>
<h2 id="5-Post和Get"><a href="#5-Post和Get" class="headerlink" title="5 Post和Get"></a>5 Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322">知乎回答</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p>
<h2 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Cookie</th>
<th align="left">Session</th>
</tr>
</thead>
<tbody><tr>
<td align="left">储存位置</td>
<td align="left">客户端</td>
<td align="left">服务器端</td>
</tr>
<tr>
<td align="left">目的</td>
<td align="left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td align="left">跟踪会话</td>
</tr>
<tr>
<td align="left">安全性</td>
<td align="left">不安全</td>
<td align="left">安全</td>
</tr>
</tbody></table>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<h2 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p>
<ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li>rewrite ，比nginx 的rewrite 强大</li>
<li>模块超多，基本想到的都可以找到</li>
<li>少bug ，nginx 的bug 相对较多</li>
<li>超稳定</li>
</ul>
<h2 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h2><ol>
<li>明文保存</li>
<li>明文hash后保存,如md5</li>
<li>MD5+Salt方式,这个salt可以随机</li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h2 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h2><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1xx 报告</td>
<td align="left">接收到请求，继续进程</td>
</tr>
<tr>
<td align="left">2xx 成功</td>
<td align="left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td align="left">3xx 重定向</td>
<td align="left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td align="left">4xx 客户端出错</td>
<td align="left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td align="left">5xx 服务器出错</td>
<td align="left">服务器无法完成显然有效的请求</td>
</tr>
</tbody></table>
<p>403: Forbidden<br>404: Not Found</p>
<p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p>
<h2 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h2><ul>
<li>CSRF(Cross-site request forgery)跨站请求伪造</li>
<li>XSS(Cross Site Scripting)跨站脚本攻击</li>
</ul>
<p>CSRF重点在请求,XSS重点在脚本</p>
<h2 id="11-幂等-Idempotence"><a href="#11-幂等-Idempotence" class="headerlink" title="11 幂等 Idempotence"></a>11 幂等 Idempotence</h2><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong>。(注意是副作用)</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p>
<p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
<h2 id="12-RESTful架构-SOAP-RPC"><a href="#12-RESTful架构-SOAP-RPC" class="headerlink" title="12 RESTful架构(SOAP,RPC)"></a>12 RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<h2 id="13-SOAP"><a href="#13-SOAP" class="headerlink" title="13 SOAP"></a>13 SOAP</h2><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p>
<h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14 RPC"></a>14 RPC</h2><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p>
<p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p>
<h2 id="15-CGI和WSGI"><a href="#15-CGI和WSGI" class="headerlink" title="15 CGI和WSGI"></a>15 CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
<p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/">PEP-3333</a></p>
<h2 id="16-中间人攻击"><a href="#16-中间人攻击" class="headerlink" title="16 中间人攻击"></a>16 中间人攻击</h2><p>在GFW里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h2 id="17-c10k问题"><a href="#17-c10k问题" class="headerlink" title="17 c10k问题"></a>17 c10k问题</h2><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href="https://my.oschina.net/xianggao/blog/664275">https://my.oschina.net/xianggao/blog/664275</a></p>
<h2 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<h2 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<h2 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<ol>
<li>请求头Host字段,一个服务器多个网站</li>
<li>长链接</li>
<li>文件断点续传</li>
<li>身份认证,状态管理,Cache缓存</li>
</ol>
<p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<p>GET</p>
<p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</p>
<p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<p>HEAD</p>
<p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<p>POST</p>
<p>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</p>
<p>PUT</p>
<p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<p>DELETE</p>
<p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<p>CONNECT</p>
<p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<p>OPTIONS</p>
<p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p>
<p>TRACE</p>
<p>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</p>
<p>HTTP/1.1之后增加的方法</p>
<p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p>
<p>PATCH</p>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p>
<p>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。<br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>
<h2 id="21-Ajax"><a href="#21-Ajax" class="headerlink" title="21 Ajax"></a>21 Ajax</h2><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
<h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol>
<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h2><p>红黑树与AVL的比较：</p>
<p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p>
<p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p>
<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p>红黑树详解: <a href="https://xieguanglei.github.io/blog/post/red-black-tree.html">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p>
<p>教你透彻了解红黑树: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="1-台阶问题-斐波那契"><a href="#1-台阶问题-斐波那契" class="headerlink" title="1 台阶问题/斐波那契"></a>1 台阶问题/斐波那契</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>第二种记忆方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span>(<span class="params">func</span>):</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(i-<span class="number">1</span>) + fib(i-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>第三种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h2 id="2-变态台阶问题"><a href="#2-变态台阶问题" class="headerlink" title="2 变态台阶问题"></a>2 变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-矩形覆盖"><a href="#3-矩形覆盖" class="headerlink" title="3 矩形覆盖"></a>3 矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p>
<blockquote>
<p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-杨氏矩阵查找"><a href="#4-杨氏矩阵查找" class="headerlink" title="4 杨氏矩阵查找"></a>4 杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>使用Step-wise线性搜索。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">l, r, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> l[r][c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">l, x</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(l) - <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">len</span>(l[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    c = n</span><br><span class="line">    <span class="keyword">while</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= m:</span><br><span class="line">        value = get_value(l, r, c)</span><br><span class="line">        <span class="keyword">if</span> value == x:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> value &gt; x:</span><br><span class="line">            c = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; x:</span><br><span class="line">            r = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="5-去除列表中的重复元素"><a href="#5-去除列表中的重复元素" class="headerlink" title="5 去除列表中的重复元素"></a>5 去除列表中的重复元素</h2><p>用集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">set</span>(l))</span><br></pre></td></tr></table></figure>

<p>用字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="built_in">print</span> l2</span><br></pre></td></tr></table></figure>

<p>用字典并保持顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(<span class="built_in">set</span>(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="built_in">print</span> l2</span><br></pre></td></tr></table></figure>

<p>列表推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure>

<p>sorted排序并且用列表推导式.</p>
<p>l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>[single.append(i) for i in sorted(l) if i not in single]<br>print single</p>
<h2 id="6-链表成对调换"><a href="#6-链表成对调换" class="headerlink" title="6 链表成对调换"></a>6 链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">None</span> <span class="keyword">and</span> head.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = self.swapPairs(<span class="built_in">next</span>.<span class="built_in">next</span>)</span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h2 id="7-创建字典的方法"><a href="#7-创建字典的方法" class="headerlink" title="7 创建字典的方法"></a>7 创建字典的方法</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>, <span class="string">&#x27;port&#x27;</span>:<span class="string">&#x27;80&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items=[(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;earth&#x27;</span>),(<span class="string">&#x27;port&#x27;</span>,<span class="string">&#x27;80&#x27;</span>)]</span><br><span class="line">dict2=<span class="built_in">dict</span>(items)</span><br><span class="line">dict1=<span class="built_in">dict</span>(([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;earth&#x27;</span>],[<span class="string">&#x27;port&#x27;</span>,<span class="string">&#x27;80&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;&#125;.fromkeys((<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>),-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;x&#x27;</span>:-<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:-<span class="number">1</span>&#125;</span><br><span class="line">dict2=&#123;&#125;.fromkeys((<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>))</span><br><span class="line">dict2=&#123;<span class="string">&#x27;x&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;y&#x27;</span>:<span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-合并两个有序列表"><a href="#8-合并两个有序列表" class="headerlink" title="8 合并两个有序列表"></a>8 合并两个有序列表</h2><p>知乎远程面试要求编程</p>
<blockquote>
<p> 尾递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span>(<span class="params">l1, l2, tmp</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l1) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(l2) == <span class="number">0</span>:</span><br><span class="line">        tmp.extend(l1)</span><br><span class="line">        tmp.extend(l2)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">            tmp.append(l1[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(l2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 循环算法</p>
</blockquote>
<p>思路：</p>
<p>定义一个新的空列表</p>
<p>比较两个列表的首个元素</p>
<p>小的就插入到新列表里</p>
<p>把已经插入新列表的元素从旧列表删除</p>
<p>直到两个旧列表有一个为空</p>
<p>再把旧列表加到新列表后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def loop_merge_sort(l1, l2):</span><br><span class="line">    tmp &#x3D; []</span><br><span class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</span><br><span class="line">        if l1[0] &lt; l2[0]:</span><br><span class="line">            tmp.append(l1[0])</span><br><span class="line">            del l1[0]</span><br><span class="line">        else:</span><br><span class="line">            tmp.append(l2[0])</span><br><span class="line">            del l2[0]</span><br><span class="line">    tmp.extend(l1)</span><br><span class="line">    tmp.extend(l2)</span><br><span class="line">    return tmp</span><br></pre></td></tr></table></figure>


<blockquote>
<p>pop弹出</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sortedlist</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt;= b[<span class="number">0</span>]:</span><br><span class="line">            c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="built_in">print</span> merge_sortedlist(a,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="9-交叉链表求交点"><a href="#9-交叉链表求交点" class="headerlink" title="9 交叉链表求交点"></a>9 交叉链表求交点</h2><blockquote>
<p>其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示</p>
</blockquote>
<p><img src="http://hi.csdn.net/attachment/201106/28/0_1309244136MWLP.gif" class="lazyload" data-srcset="http://hi.csdn.net/attachment/201106/28/0_1309244136MWLP.gif" srcset="data:image/png;base64,666"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">min</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">and</span> (a[-<span class="number">1</span>] != b[-<span class="number">1</span>]):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;No&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> a[-i] != b[-i]:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;交叉节点：&quot;</span>,a[-i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一种比较正规的方法，构造链表类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    length1, lenth2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.<span class="built_in">next</span>:</span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.<span class="built_in">next</span>:</span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 长的链表先走</span></span><br><span class="line">    <span class="keyword">if</span> length1 &gt; lenth2:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length1 - length2):</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length2 - length1):</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.<span class="built_in">next</span> == l2.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>修改了一下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    length1, length2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.<span class="built_in">next</span>:</span><br><span class="line">        l1 = l1.<span class="built_in">next</span><span class="comment">#尾节点</span></span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.<span class="built_in">next</span>:</span><br><span class="line">        l2 = l2.<span class="built_in">next</span><span class="comment">#尾节点</span></span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果相交</span></span><br><span class="line">    <span class="keyword">if</span> l1.<span class="built_in">next</span> == l2.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># 长的链表先走</span></span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length1 - length2):</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> l1<span class="comment">#返回交点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length2 - length1):</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> l2<span class="comment">#返回交点</span></span><br><span class="line">    <span class="comment"># 如果不相交</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>


<p>思路: <a href="http://humaoli.blog.163.com/blog/static/13346651820141125102125995/">http://humaoli.blog.163.com/blog/static/13346651820141125102125995/</a></p>
<h2 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10 二分查找"></a>10 二分查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params"><span class="built_in">list</span>, item</span>):</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (high - low) / <span class="number">2</span> + low    <span class="comment"># 避免(high + low) / 2溢出</span></span><br><span class="line">        guess = <span class="built_in">list</span>[mid]</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span> binary_search(mylist, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考: <a href="http://blog.csdn.net/u013205877/article/details/76411718">http://blog.csdn.net/u013205877/article/details/76411718</a></p>
<h2 id="11-快排"><a href="#11-快排" class="headerlink" title="11 快排"></a>11 快排</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>


<blockquote>
<p> 更多排序问题可见：<a href="http://blog.csdn.net/mrlevo520/article/details/77829204">数据结构与算法-排序篇-Python描述</a></p>
</blockquote>
<h2 id="12-找零问题"><a href="#12-找零问题" class="headerlink" title="12 找零问题"></a>12 找零问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#values是硬币的面值values = [ 25, 21, 10, 5, 1]</span></span><br><span class="line"><span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line"><span class="comment">#money  找出来的总钱数</span></span><br><span class="line"><span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">values,valuesCounts,money,coinsUsed</span>):</span></span><br><span class="line">    <span class="comment">#遍历出从1到money所有的钱数可能</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents</span><br><span class="line">        <span class="comment">#把所有的硬币面值遍历出来和钱数做对比</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,valuesCounts):</span><br><span class="line">            <span class="keyword">if</span> (values[kind] &lt;= cents):</span><br><span class="line">                temp = coinsUsed[cents - values[kind]] +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; minCoins):</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(cents, coinsUsed[cents]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路: <a href="http://blog.csdn.net/wdxin1322/article/details/9501163">http://blog.csdn.net/wdxin1322/article/details/9501163</a></p>
<p>方法: <a href="http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html">http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html</a></p>
<h2 id="13-广度遍历和深度遍历二叉树"><a href="#13-广度遍历和深度遍历二叉树" class="headerlink" title="13 广度遍历和深度遍历二叉树"></a>13 广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p>
<h2 id="14-二叉树节点"><a href="#14-二叉树节点" class="headerlink" title="14 二叉树节点"></a>14 二叉树节点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="15-层次遍历"><a href="#15-层次遍历" class="headerlink" title="15 层次遍历"></a>15 层次遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">root</span>):</span></span><br><span class="line">    row = [root]</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(row)</span><br><span class="line">        row = [kid <span class="keyword">for</span> item <span class="keyword">in</span> row <span class="keyword">for</span> kid <span class="keyword">in</span> (item.left, item.right) <span class="keyword">if</span> kid]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="16-深度遍历"><a href="#16-深度遍历" class="headerlink" title="16 深度遍历"></a>16 深度遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span> root.data</span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lookup(tree)</span><br><span class="line">    deep(tree)</span><br></pre></td></tr></table></figure>

<h2 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h2><p>深度遍历改变顺序就OK了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#二叉树的遍历</span></span><br><span class="line"><span class="comment">#简单的二叉树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value,left,right</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="comment">#中序遍历:遍历左子树,访问当前节点,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_travelsal</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        mid_travelsal(root.left)</span><br><span class="line">    <span class="comment">#访问当前节点</span></span><br><span class="line">    print(root.value)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        mid_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#前序遍历:访问当前节点,遍历左子树,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_travelsal</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="built_in">print</span> (root.value)</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        pre_travelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        pre_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#后续遍历:遍历左子树,遍历右子树,访问当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_trvelsal</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        post_trvelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        post_trvelsal(root.right)</span><br><span class="line">    <span class="built_in">print</span> (root.value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span>(<span class="params">pre, center</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = Node(pre[<span class="number">0</span>])</span><br><span class="line">    index = center.index(pre[<span class="number">0</span>])</span><br><span class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</span><br><span class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line">    <span class="built_in">print</span> root.data</span><br></pre></td></tr></table></figure>

<h2 id="21-单链表逆置"><a href="#21-单链表逆置" class="headerlink" title="21 单链表逆置"></a>21 单链表逆置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">link = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">3</span>, Node(<span class="number">4</span>, Node(<span class="number">5</span>, Node(<span class="number">6</span>, Node(<span class="number">7</span>, Node(<span class="number">8</span>, Node(<span class="number">9</span>)))))))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span>(<span class="params">link</span>):</span></span><br><span class="line">    pre = link</span><br><span class="line">    cur = link.<span class="built_in">next</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">root = rev(link)</span><br><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    <span class="built_in">print</span> root.data</span><br><span class="line">    root = root.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>思路: <a href="http://blog.csdn.net/feliciafay/article/details/6841115">http://blog.csdn.net/feliciafay/article/details/6841115</a></p>
<p>方法: <a href="http://www.xuebuyuan.com/2066385.html?mobile=1">http://www.xuebuyuan.com/2066385.html?mobile=1</a></p>
<h2 id="22-两个字符串是否是变位词"><a href="#22-两个字符串是否是变位词" class="headerlink" title="22 两个字符串是否是变位词"></a>22 两个字符串是否是变位词</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anagram</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @:param s1: The first string</span></span><br><span class="line"><span class="string">    @:param s2: The second string</span></span><br><span class="line"><span class="string">    @:return true or false</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution1</span>(<span class="params">s1,s2</span>):</span></span><br><span class="line">        alist = <span class="built_in">list</span>(s2)</span><br><span class="line"></span><br><span class="line">        pos1 = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos1 &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> stillOK:</span><br><span class="line">            pos2 = <span class="number">0</span></span><br><span class="line">            found = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> pos2 &lt; <span class="built_in">len</span>(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">                <span class="keyword">if</span> s1[pos1] == alist[pos2]:</span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos2 = pos2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                alist[pos2] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            pos1 = pos1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution1(<span class="string">&#x27;abcd&#x27;</span>,<span class="string">&#x27;dcba&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution2</span>(<span class="params">s1,s2</span>):</span></span><br><span class="line">        alist1 = <span class="built_in">list</span>(s1)</span><br><span class="line">        alist2 = <span class="built_in">list</span>(s2)</span><br><span class="line"></span><br><span class="line">        alist1.sort()</span><br><span class="line">        alist2.sort()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        matches = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> matches:</span><br><span class="line">            <span class="keyword">if</span> alist1[pos] == alist2[pos]:</span><br><span class="line">                pos = pos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matches = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matches</span><br><span class="line"></span><br><span class="line">    print(Solution2(<span class="string">&#x27;abcde&#x27;</span>,<span class="string">&#x27;edcbg&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution3</span>(<span class="params">s1,s2</span>):</span></span><br><span class="line">        c1 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        c2 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">            pos = <span class="built_in">ord</span>(s1[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            c1[pos] = c1[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">            pos = <span class="built_in">ord</span>(s2[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            c2[pos] = c2[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="number">26</span> <span class="keyword">and</span> stillOK:</span><br><span class="line">            <span class="keyword">if</span> c1[j] == c2[j]:</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution3(<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pleap&#x27;</span>))</span><br></pre></td></tr></table></figure>




<h2 id="23-动态规划问题"><a href="#23-动态规划问题" class="headerlink" title="23 动态规划问题"></a>23 动态规划问题</h2><blockquote>
<p> 可参考：<a href="http://blog.csdn.net/mrlevo520/article/details/75676160">动态规划(DP)的整理-Python描述</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
</search>
